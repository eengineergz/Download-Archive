<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Combined_____-_____Doc</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="redux-docs">Redux DOCS</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><strong>General</strong>
<ul>
<li><a href="faq/General.md#when-should-i-learn-redux">When should I learn Redux?</a></li>
<li><a href="faq/General.md#when-should-i-use-redux">When should I use Redux?</a></li>
<li><a href="faq/General.md#can-redux-only-be-used-with-react">Can Redux only be used with React?</a></li>
<li><a href="faq/General.md#do-i-need-to-have-a-particular-build-tool-to-use-redux">Do I need to have a particular build tool to use Redux?</a></li>
</ul></li>
<li><strong>Reducers</strong>
<ul>
<li><a href="faq/Reducers.md#how-do-i-share-state-between-two-reducers-do-i-have-to-use-combinereducers">How do I share state between two reducers? Do I have to use combineReducers?</a></li>
<li><a href="faq/Reducers.md#do-i-have-to-use-the-switch-statement-to-handle-actions">Do I have to use the switch statement to handle actions?</a></li>
</ul></li>
<li><strong>Organizing State</strong>
<ul>
<li><a href="faq/OrganizingState.md#do-i-have-to-put-all-my-state-into-redux-should-i-ever-use-reacts-setstate">Do I have to put all my state into Redux? Should I ever use React’s setState()?</a></li>
<li><a href="faq/OrganizingState.md#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state">Can I put functions, promises, or other non-serializable items in my store state?</a></li>
<li><a href="faq/OrganizingState.md#how-do-i-organize-nested-or-duplicate-data-in-my-state">How do I organize nested or duplicate data in my state?</a></li>
<li><a href="faq/OrganizingState.md#should-i-put-form-state-or-other-ui-state-in-my-store">Should I put form state or other UI state in my store?</a></li>
</ul></li>
<li><strong>Store Setup</strong>
<ul>
<li><a href="faq/StoreSetup.md#can-or-should-i-create-multiple-stores-can-i-import-my-store-directly-and-use-it-in-components-myself">Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</a></li>
<li><a href="faq/StoreSetup.md#is-it-ok-to-have-more-than-one-middleware-chain-in-my-store-enhancer-what-is-the-difference-between-next-and-dispatch-in-a-middleware-function">Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?</a></li>
<li><a href="faq/StoreSetup.md#how-do-i-subscribe-to-only-a-portion-of-the-state-can-i-get-the-dispatched-action-as-part-of-the-subscription">How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</a></li>
</ul></li>
<li><strong>Actions</strong>
<ul>
<li><a href="faq/Actions.md#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants">Why should type be a string, or at least serializable? Why should my action types be constants?</a></li>
<li><a href="faq/Actions.md#is-there-always-a-one-to-one-mapping-between-reducers-and-actions">Is there always a one-to-one mapping between reducers and actions?</a></li>
<li><a href="faq/Actions.md#how-can-i-represent-side-effects-such-as-ajax-calls-why-do-we-need-things-like-action-creators-thunks-and-middleware-to-do-async-behavior">How can I represent “side effects” such as AJAX calls? Why do we need things like “action creators”, “thunks”, and “middleware” to do async behavior?</a></li>
<li><a href="faq/Actions.md#what-async-middleware-should-i-use-how-do-you-decide-between-thunks-sagas-observables-or-something-else">What async middleware should I use? How do you decide between thunks, sagas, observables, or something else?</a></li>
<li><a href="faq/Actions.md#should-i-dispatch-multiple-actions-in-a-row-from-one-action-creator">Should I dispatch multiple actions in a row from one action creator?</a></li>
</ul></li>
<li><strong>Immutable Data</strong>
<ul>
<li><a href="faq/ImmutableData.md#what-are-the-benefits-of-immutability">What are the benefits of immutability?</a></li>
<li><a href="faq/ImmutableData.md#why-is-immutability-required-by-redux">Why is immutability required by Redux?</a></li>
<li><a href="faq/ImmutableData.md#what-approaches-are-there-for-handling-data-immutability-do-i-have-to-use-immer">What approaches are there for handling data immutability? Do I have to use Immer?</a></li>
<li><a href="faq/ImmutableData.md#what-are-the-issues-with-using-plain-javascript-for-immutable-operations">What are the issues with using JavaScript for immutable operations?</a></li>
</ul></li>
<li><strong>Code Structure</strong>
<ul>
<li><a href="faq/CodeStructure.md#what-should-my-file-structure-look-like-how-should-i-group-my-action-creators-and-reducers-in-my-project-where-should-my-selectors-go">What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</a></li>
<li><a href="faq/CodeStructure.md#how-should-i-split-my-logic-between-reducers-and-action-creators-where-should-my-business-logic-go">How should I split my logic between reducers and action creators? Where should my “business logic” go?</a></li>
<li><a href="faq/CodeStructure.md#why-should-i-use-action-creators">Why should I use action creators?</a></li>
<li><a href="faq/CodeStructure.md#where-should-websockets-and-other-persistent-connections-live">Where should websockets and other persistent connections live?</a></li>
<li><a href="faq/CodeStructure.md#how-can-i-use-the-redux-store-in-non-component-files">How can I use the Redux store in non-component files?</a></li>
</ul></li>
<li><strong>Performance</strong>
<ul>
<li><a href="faq/Performance.md#how-well-does-redux-scale-in-terms-of-performance-and-architecture">How well does Redux “scale” in terms of performance and architecture?</a></li>
<li><a href="faq/Performance.md#wont-calling-all-my-reducers-for-each-action-be-slow">Won’t calling “all my reducers” for each action be slow?</a></li>
<li><a href="faq/Performance.md#do-i-have-to-deep-clone-my-state-in-a-reducer-isnt-copying-my-state-going-to-be-slow">Do I have to deep-clone my state in a reducer? Isn’t copying my state going to be slow?</a></li>
<li><a href="faq/Performance.md#how-can-i-reduce-the-number-of-store-update-events">How can I reduce the number of store update events?</a></li>
<li><a href="faq/Performance.md#will-having-one-state-tree-cause-memory-problems-will-dispatching-many-actions-take-up-memory">Will having “one state tree” cause memory problems? Will dispatching many actions take up memory?</a></li>
<li><a href="faq/Performance.md#will-caching-remote-data-cause-memory-problems">Will caching remote data cause memory problems?</a></li>
</ul></li>
<li><strong>Design Decisions</strong>
<ul>
<li><a href="faq/DesignDecisions.md#why-doesnt-redux-pass-the-state-and-action-to-subscribers">Why doesn’t Redux pass the state and action to subscribers?</a></li>
<li><a href="faq/DesignDecisions.md#why-doesnt-redux-support-using-classes-for-actions-and-reducers">Why doesn’t Redux support using classes for actions and reducers?</a></li>
<li><a href="faq/DesignDecisions.md#why-does-the-middleware-signature-use-currying">Why does the middleware signature use currying?</a></li>
<li><a href="faq/DesignDecisions.md#why-does-applymiddleware-use-a-closure-for-dispatch">Why does applyMiddleware use a closure for dispatch?</a></li>
<li><a href="faq/DesignDecisions.md#why-doesnt-combinereducers-include-a-third-argument-with-the-entire-state-when-it-calls-each-reducer">Why doesn’t <code>combineReducers</code> include a third argument with the entire state when it calls each reducer?</a></li>
<li><a href="faq/DesignDecisions.md#why-doesnt-mapdispatchtoprops-allow-use-of-return-values-from-getstate-or-mapstatetoprops">Why doesn’t mapDispatchToProps allow use of return values from <code>getState()</code> or <code>mapStateToProps()</code>?</a></li>
</ul></li>
<li><strong>React Redux</strong>
<ul>
<li><a href="faq/ReactRedux.md#why-should-i-use-react-redux">Why should I use React-Redux?</a></li>
<li><a href="faq/ReactRedux.md#why-isnt-my-component-re-rendering-or-my-mapstatetoprops-running">Why isn’t my component re-rendering, or my mapStateToProps running?</a></li>
<li><a href="faq/ReactRedux.md#why-is-my-component-re-rendering-too-often">Why is my component re-rendering too often?</a></li>
<li><a href="faq/ReactRedux.md#how-can-i-speed-up-my-mapstatetoprops">How can I speed up my mapStateToProps?</a></li>
<li><a href="faq/ReactRedux.md#why-dont-i-have-this-props-dispatch-available-in-my-connected-component">Why don’t I have this.props.dispatch available in my connected component?</a></li>
<li><a href="faq/ReactRedux.md#should-i-only-connect-my-top-component-or-can-i-connect-multiple-components-in-my-tree">Should I only connect my top component, or can I connect multiple components in my tree?</a></li>
</ul></li>
<li><strong>Miscellaneous</strong>
<ul>
<li><a href="faq/Miscellaneous.md#are-there-any-larger-real-redux-projects">Are there any larger, “real” Redux projects?</a></li>
<li><a href="faq/Miscellaneous.md#how-can-i-implement-authentication-in-redux">How can I implement authentication in Redux?</a></li>
</ul></li>
</ul>
<hr />
<p>id: core-concepts title: Core Concepts description: “Introduction &gt; Core Concepts: A quick overview of Redux’s key idea, reducer functions”</p>
<hr />
<h1 id="core-concepts">Core Concepts</h1>
<p>Imagine your app’s state is described as a plain object. For example, the state of a todo app might look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">todos</span><span class="op">:</span> [<span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Eat food&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="op">},</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Exercise&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="op">}</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="dt">visibilityFilter</span><span class="op">:</span> <span class="st">&#39;SHOW_COMPLETED&#39;</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>This object is like a “model” except that there are no setters. This is so that different parts of the code can’t change the state arbitrarily, causing hard-to-reproduce bugs.</p>
<p>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don’t introduce any magic?) that describes what happened. Here are a few example actions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;ADD_TODO&#39;</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Go to swimming pool&#39;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;TOGGLE_TODO&#39;</span><span class="op">,</span> <span class="dt">index</span><span class="op">:</span> <span class="dv">1</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;SET_VISIBILITY_FILTER&#39;</span><span class="op">,</span> <span class="dt">filter</span><span class="op">:</span> <span class="st">&#39;SHOW_ALL&#39;</span> <span class="op">}</span></a></code></pre></div>
<p>Enforcing that every change is described as an action lets us have a clear understanding of what’s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it—it’s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">visibilityFilter</span>(state <span class="op">=</span> <span class="st">&quot;SHOW_ALL&quot;</span><span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="cf">if</span> (<span class="va">action</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&quot;SET_VISIBILITY_FILTER&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">return</span> <span class="va">action</span>.<span class="at">filter</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="kw">function</span> <span class="at">todos</span>(state <span class="op">=</span> []<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="cf">case</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb3-12" title="12">      <span class="cf">return</span> <span class="va">state</span>.<span class="at">concat</span>([<span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="va">action</span>.<span class="at">text</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span> <span class="op">}</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="cf">case</span> <span class="st">&quot;TOGGLE_TODO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb3-14" title="14">      <span class="cf">return</span> <span class="va">state</span>.<span class="at">map</span>((todo<span class="op">,</span> index) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb3-15" title="15">        <span class="va">action</span>.<span class="at">index</span> <span class="op">===</span> index</a>
<a class="sourceLine" id="cb3-16" title="16">          <span class="op">?</span> <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="va">todo</span>.<span class="at">text</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="op">!</span><span class="va">todo</span>.<span class="at">completed</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb3-17" title="17">          : todo</a>
<a class="sourceLine" id="cb3-18" title="18">      )<span class="op">;</span></a>
<a class="sourceLine" id="cb3-19" title="19">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb3-20" title="20">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb3-21" title="21">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-22" title="22"><span class="op">}</span></a></code></pre></div>
<p>And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="at">todoApp</span>(state <span class="op">=</span> <span class="op">{},</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">todos</span><span class="op">:</span> <span class="at">todos</span>(<span class="va">state</span>.<span class="at">todos</span><span class="op">,</span> action)<span class="op">,</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="dt">visibilityFilter</span><span class="op">:</span> <span class="at">visibilityFilter</span>(<span class="va">state</span>.<span class="at">visibilityFilter</span><span class="op">,</span> action)<span class="op">,</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>This is basically the whole idea of Redux. Note that we haven’t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</p>
<hr />
<p>id: ecosystem title: Ecosystem description: ‘Introduction &gt; Ecosystem: Links to popular, recommended, and interesting Redux-related libraries’</p>
<hr />
<h1 id="ecosystem">Ecosystem</h1>
<p>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions, and the community has created a wide variety of helpful addons, libraries, and tools. You don’t need to use any of these addons to use Redux, but they can help make it easier to implement features and solve problems in your application.</p>
<p>For an extensive catalog of libraries, addons, and tools related to Redux, check out the <a href="https://github.com/markerikson/redux-ecosystem-links">Redux Ecosystem Links</a> list. Also, the <a href="https://github.com/markerikson/react-redux-links">React/Redux Links</a> list contains tutorials and other useful resources for anyone learning React or Redux.</p>
<p>This page lists some of the Redux-related addons that the Redux maintainers have vetted personally, or that have shown widespread adoption in the community. Don’t let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the “staff picks”, and don’t hesitate to submit a PR if you’ve built something wonderful with Redux.</p>
<h2 id="table-of-contents-1">Table of Contents</h2>
<ul>
<li><a href="#ecosystem">Ecosystem</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#library-integration-and-bindings">Library Integration and Bindings</a></li>
<li><a href="#reducers">Reducers</a>
<ul>
<li><a href="#reducer-combination">Reducer Combination</a></li>
<li><a href="#reducer-composition">Reducer Composition</a></li>
<li><a href="#higher-order-reducers">Higher-Order Reducers</a></li>
</ul></li>
<li><a href="#actions">Actions</a></li>
<li><a href="#utilities">Utilities</a></li>
<li><a href="#store">Store</a>
<ul>
<li><a href="#change-subscriptions">Change Subscriptions</a></li>
<li><a href="#batching">Batching</a></li>
<li><a href="#persistence">Persistence</a></li>
</ul></li>
<li><a href="#immutable-data">Immutable Data</a>
<ul>
<li><a href="#data-structures">Data Structures</a></li>
<li><a href="#immutable-update-utilities">Immutable Update Utilities</a></li>
<li><a href="#immutableredux-interop">Immutable/Redux Interop</a></li>
</ul></li>
<li><a href="#side-effects">Side Effects</a>
<ul>
<li><a href="#widely-used">Widely Used</a></li>
<li><a href="#promises">Promises</a></li>
</ul></li>
<li><a href="#middleware">Middleware</a>
<ul>
<li><a href="#networks-and-sockets">Networks and Sockets</a></li>
<li><a href="#async-behavior">Async Behavior</a></li>
<li><a href="#analytics">Analytics</a></li>
</ul></li>
<li><a href="#entities-and-collections">Entities and Collections</a></li>
<li><a href="#component-state-and-encapsulation">Component State and Encapsulation</a></li>
<li><a href="#dev-tools">Dev Tools</a>
<ul>
<li><a href="#debuggers-and-viewers">Debuggers and Viewers</a></li>
<li><a href="#devtools-monitors">DevTools Monitors</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#mutation-detection">Mutation Detection</a></li>
</ul></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#routing">Routing</a></li>
<li><a href="#forms">Forms</a></li>
<li><a href="#higher-level-abstractions">Higher-Level Abstractions</a></li>
<li><a href="#community-conventions">Community Conventions</a></li>
</ul></li>
</ul>
<h2 id="library-integration-and-bindings">Library Integration and Bindings</h2>
<p><strong><a href="https://github.com/reduxjs/react-redux">reduxjs/react-redux</a></strong> <br /> The official React bindings for Redux, maintained by the Redux team</p>
<p><strong><a href="https://github.com/angular-redux/ng-redux">angular-redux/ng-redux</a></strong> <br /> Angular 1 bindings for Redux</p>
<p><strong><a href="https://github.com/ember-redux/ember-redux">ember-redux/ember-redux</a></strong> <br /> Ember bindings for Redux</p>
<p><strong><a href="https://github.com/glimmer-redux/glimmer-redux">glimmer-redux/glimmer-redux</a></strong> <br /> Redux bindings for Ember’s Glimmer component engine</p>
<p><strong><a href="https://github.com/tur-nr/polymer-redux">tur-nr/polymer-redux</a></strong> <br /> Redux bindings for Polymer</p>
<p><strong><a href="https://github.com/lastmjs/redux-store-element">lastmjs/redux-store-element</a></strong> Redux bindings for custom elements</p>
<h2 id="reducers">Reducers</h2>
<h4 id="reducer-combination">Reducer Combination</h4>
<p><strong><a href="https://gitlab.com/ryo33/combine-section-reducers">ryo33/combineSectionReducers</a></strong> <br /> An expanded version of <code>combineReducers</code>, which allows passing <code>state</code> as a third argument to all slice reducers.</p>
<p><strong><a href="https://github.com/KodersLab/topologically-combine-reducers">KodersLab/topologically-combine-reducers</a></strong> <br /> A <code>combineReducers</code> variation that allows defining cross-slice dependencies for ordering and data passing</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">var</span> masterReducer <span class="op">=</span> <span class="at">topologicallyCombineReducers</span>(</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="op">{</span> auth<span class="op">,</span> users<span class="op">,</span> todos <span class="op">},</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="co">// define the dependency tree</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="op">{</span> <span class="dt">auth</span><span class="op">:</span> [<span class="st">&quot;users&quot;</span>]<span class="op">,</span> <span class="dt">todos</span><span class="op">:</span> [<span class="st">&quot;auth&quot;</span>] <span class="op">}</span></a>
<a class="sourceLine" id="cb5-5" title="5">)<span class="op">;</span></a></code></pre></div>
<h4 id="reducer-composition">Reducer Composition</h4>
<p><strong><a href="https://github.com/acdlite/reduce-reducers">acdlite/reduce-reducers</a></strong> <br /> Provides sequential composition of reducers at the same level</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">const</span> combinedReducer <span class="op">=</span> <span class="at">combineReducers</span>(<span class="op">{</span> users<span class="op">,</span> posts<span class="op">,</span> comments <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> rootReducer <span class="op">=</span> <span class="at">reduceReducers</span>(</a>
<a class="sourceLine" id="cb6-3" title="3">  combinedReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb6-4" title="4">  otherTopLevelFeatureReducer</a>
<a class="sourceLine" id="cb6-5" title="5">)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/mhelmer/redux-xforms">mhelmer/redux-xforms</a></strong> <br /> A collection of composable reducer transformers</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">const</span> createByFilter <span class="op">=</span> (predicate<span class="op">,</span> mapActionToKey) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="at">compose</span>(</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="at">withInitialState</span>(<span class="op">{}</span>)<span class="op">,</span> <span class="co">// inject initial state as {}</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="at">withFilter</span>(predicate)<span class="op">,</span> <span class="co">// let through if action has filterName</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="at">updateSlice</span>(mapActionToKey)<span class="op">,</span> <span class="co">// update a single key in the state</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="at">isolateSlice</span>(mapActionToKey) <span class="co">// run the reducer on a single state slice</span></a>
<a class="sourceLine" id="cb7-7" title="7">  )<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/adrienjt/redux-data-structures">adrienjt/redux-data-structures</a></strong> <br /> Reducer factory functions for common data structures: counters, maps, lists (queues, stacks), sets</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">const</span> myCounter <span class="op">=</span> <span class="at">counter</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="dt">incrementActionTypes</span><span class="op">:</span> [<span class="st">&quot;INCREMENT&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="dt">decrementActionTypes</span><span class="op">:</span> [<span class="st">&quot;DECREMENT&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="higher-order-reducers">Higher-Order Reducers</h4>
<p><strong><a href="https://github.com/omnidan/redux-undo">omnidan/redux-undo</a></strong> <br /> Effortless undo/redo and action history for your reducers</p>
<p><strong><a href="https://github.com/omnidan/redux-ignore">omnidan/redux-ignore</a></strong> <br /> Ignore redux actions by array or filter function</p>
<p><strong><a href="https://github.com/omnidan/redux-recycle">omnidan/redux-recycle</a></strong> <br /> Reset the redux state on certain actions</p>
<p><strong><a href="https://github.com/ForbesLindesay/redux-optimist">ForbesLindesay/redux-optimist</a></strong> <br /> A reducer enhancer to enable type-agnostic optimistic updates</p>
<h2 id="actions">Actions</h2>
<p><strong><a href="https://github.com/reduxactions/redux-actions">reduxactions/redux-actions</a></strong> <br /> Flux Standard Action utilities for Redux</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">const</span> increment <span class="op">=</span> <span class="at">createAction</span>(<span class="st">&quot;INCREMENT&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">const</span> reducer <span class="op">=</span> <span class="at">handleActions</span>(<span class="op">{</span> [increment]<span class="op">:</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> state <span class="op">+</span> <span class="dv">1</span> <span class="op">},</span> <span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">increment</span>())<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/BerkeleyTrue/redux-create-types">BerkeleyTrue/redux-create-types</a></strong> <br /> Creates standard and async action types based on namespaces</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="im">export</span> <span class="kw">const</span> types <span class="op">=</span> <span class="at">createTypes</span>(</a>
<a class="sourceLine" id="cb10-2" title="2">  [<span class="st">&quot;openModal&quot;</span><span class="op">,</span> <span class="at">createAsyncTypes</span>(<span class="st">&quot;fetch&quot;</span>)]<span class="op">,</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="st">&quot;app&quot;</span></a>
<a class="sourceLine" id="cb10-4" title="4">)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">// { openModal : &quot;app.openModal&quot;, fetch : { start : &quot;app.fetch.start&quot;, complete: &#39;app.fetch.complete&#39; } }</span></a></code></pre></div>
<p><strong><a href="https://github.com/maxhallinan/kreighter">maxhallinan/kreighter</a></strong> <br /> Generates action creators based on types and expected fields</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">const</span> formatTitle <span class="op">=</span> (id<span class="op">,</span> title) <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" title="2">  id<span class="op">,</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="dt">title</span><span class="op">:</span> <span class="at">toTitleCase</span>(title)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">const</span> updateBazTitle <span class="op">=</span> <span class="at">fromType</span>(<span class="st">&quot;UPDATE_BAZ_TITLE&quot;</span><span class="op">,</span> formatTitle)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="at">updateBazTitle</span>(<span class="dv">1</span><span class="op">,</span> <span class="st">&quot;foo bar baz&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co">// -&gt; { type: &#39;UPDATE_BAZ_TITLE&#39;, id: 1, title: &#39;Foo Bar Baz&#39;, }</span></a></code></pre></div>
<h2 id="utilities">Utilities</h2>
<p><strong><a href="https://github.com/reduxjs/reselect">reduxjs/reselect</a></strong> <br /> Creates composable memoized selector functions for efficiently deriving data from the store state</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">const</span> taxSelector <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb12-2" title="2">  [subtotalSelector<span class="op">,</span> taxPercentSelector]<span class="op">,</span></a>
<a class="sourceLine" id="cb12-3" title="3">  (subtotal<span class="op">,</span> taxPercent) <span class="kw">=&gt;</span> subtotal <span class="op">*</span> (taxPercent / <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb12-4" title="4">)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/paularmstrong/normalizr">paularmstrong/normalizr</a></strong> <br /> Normalizes nested JSON according to a schema</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">const</span> user <span class="op">=</span> <span class="kw">new</span> <span class="va">schema</span>.<span class="at">Entity</span>(<span class="st">&quot;users&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">const</span> comment <span class="op">=</span> <span class="kw">new</span> <span class="va">schema</span>.<span class="at">Entity</span>(<span class="st">&quot;comments&quot;</span><span class="op">,</span> <span class="op">{</span> <span class="dt">commenter</span><span class="op">:</span> user <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="kw">const</span> article <span class="op">=</span> <span class="kw">new</span> <span class="va">schema</span>.<span class="at">Entity</span>(<span class="st">&quot;articles&quot;</span><span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="dt">author</span><span class="op">:</span> user<span class="op">,</span></a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="dt">comments</span><span class="op">:</span> [comment]<span class="op">,</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">const</span> normalizedData <span class="op">=</span> <span class="at">normalize</span>(originalData<span class="op">,</span> article)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/planttheidea/selectorator">planttheidea/selectorator</a></strong> <br /> Abstractions over Reselect for common selector use cases</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">const</span> getBarBaz <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb14-2" title="2">  [<span class="st">&quot;foo.bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb14-3" title="3">  (bar<span class="op">,</span> baz) <span class="kw">=&gt;</span> <span class="vs">`</span><span class="sc">${</span>bar<span class="sc">}</span><span class="vs"> </span><span class="sc">${</span>baz<span class="sc">}</span><span class="vs">`</span></a>
<a class="sourceLine" id="cb14-4" title="4">)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="at">getBarBaz</span>(<span class="op">{</span> <span class="dt">foo</span><span class="op">:</span> <span class="op">{</span> <span class="dt">bar</span><span class="op">:</span> <span class="st">&quot;a&quot;</span> <span class="op">},</span> <span class="dt">baz</span><span class="op">:</span> <span class="st">&quot;b&quot;</span> <span class="op">}</span>)<span class="op">;</span> <span class="co">// &quot;a b&quot;</span></a></code></pre></div>
<h2 id="store">Store</h2>
<h4 id="change-subscriptions">Change Subscriptions</h4>
<p><strong><a href="https://github.com/jprichardson/redux-watch">jprichardson/redux-watch</a></strong> <br /> Watch for state changes based on key paths or selectors</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">let</span> w <span class="op">=</span> <span class="at">watch</span>(() <span class="kw">=&gt;</span> <span class="at">mySelector</span>(<span class="va">store</span>.<span class="at">getState</span>()))<span class="op">;</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="va">store</span>.<span class="at">subscribe</span>(</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="at">w</span>((newVal<span class="op">,</span> oldVal) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(newval<span class="op">,</span> oldVal)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="op">}</span>)</a>
<a class="sourceLine" id="cb15-6" title="6">)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/ashaffer/redux-subscribe">ashaffer/redux-subscribe</a></strong> <br /> Centralized subscriptions to state changes based on paths</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="va">store</span>.<span class="at">dispatch</span>( <span class="at">subscribe</span>(<span class="st">&quot;users.byId.abcd&quot;</span><span class="op">,</span> <span class="st">&quot;subscription1&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{}</span> )<span class="op">;</span></a></code></pre></div>
<h4 id="batching">Batching</h4>
<p><strong><a href="https://github.com/tappleby/redux-batched-subscribe">tappleby/redux-batched-subscribe</a></strong> <br /> Store enhancer that can debounce subscription notifications</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">const</span> debounceNotify <span class="op">=</span> <span class="va">_</span>.<span class="at">debounce</span>((notify) <span class="kw">=&gt;</span> <span class="at">notify</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(</a>
<a class="sourceLine" id="cb17-3" title="3">  reducer<span class="op">,</span></a>
<a class="sourceLine" id="cb17-4" title="4">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="at">batchedSubscribe</span>(debounceNotify)</a>
<a class="sourceLine" id="cb17-6" title="6">)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/manaflair/redux-batch">manaflair/redux-batch</a></strong> <br /> Store enhancer that allows dispatching arrays of actions</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer<span class="op">,</span> reduxBatch)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="va">store</span>.<span class="at">dispatch</span>([<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;INCREMENT&quot;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;INCREMENT&quot;</span> <span class="op">}</span>])<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/laysent/redux-batch-actions-enhancer">laysent/redux-batch-actions-enhancer</a></strong> <br /> Store enhancer that accepts batched actions</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer<span class="op">,</span> initialState<span class="op">,</span> <span class="at">batch</span>().<span class="at">enhancer</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">createAction</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;INCREMENT&quot;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;INCREMENT&quot;</span> <span class="op">}</span>))<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/tshelburne/redux-batched-actions">tshelburne/redux-batched-actions</a></strong> <br /> Higher-order reducer that handles batched actions</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(<span class="at">enableBatching</span>(reducer)<span class="op">,</span> initialState)<span class="op">;</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">batchActions</span>([<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;INCREMENT&quot;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;INCREMENT&quot;</span> <span class="op">}</span>]))<span class="op">;</span></a></code></pre></div>
<h4 id="persistence">Persistence</h4>
<p><strong><a href="https://github.com/rt2zz/redux-persist">rt2zz/redux-persist</a></strong> <br /> Persist and rehydrate a Redux store, with many extensible options</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer<span class="op">,</span> <span class="at">autoRehydrate</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="at">persistStore</span>(store)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/react-stack/redux-storage">react-stack/redux-storage</a></strong> <br /> Persistence layer for Redux with flexible backends</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">const</span> reducer <span class="op">=</span> <span class="va">storage</span>.<span class="at">reducer</span>(<span class="at">combineReducers</span>(reducers))<span class="op">;</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">const</span> engine <span class="op">=</span> <span class="at">createEngineLocalStorage</span>(<span class="st">&quot;my-save-key&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">const</span> storageMiddleware <span class="op">=</span> <span class="va">storage</span>.<span class="at">createMiddleware</span>(engine)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer<span class="op">,</span> <span class="at">applyMiddleware</span>(storageMiddleware))<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/redux-offline/redux-offline">redux-offline/redux-offline</a></strong> <br /> Persistent store for Offline-First apps, with support for optimistic UIs</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer<span class="op">,</span> <span class="at">offline</span>(offlineConfig))<span class="op">;</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;FOLLOW_USER_REQUEST&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb23-4" title="4">  <span class="dt">meta</span><span class="op">:</span> <span class="op">{</span> <span class="dt">offline</span><span class="op">:</span> <span class="op">{</span> <span class="dt">effect</span><span class="op">:</span> <span class="op">{},</span> <span class="dt">commit</span><span class="op">:</span> <span class="op">{},</span> <span class="dt">rollback</span><span class="op">:</span> <span class="op">{}</span> <span class="op">}</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h2 id="immutable-data">Immutable Data</h2>
<p><strong><a href="https://github.com/immerjs/immer">ImmerJS/immer</a></strong> <br /> Immutable updates with normal mutative code, using Proxies</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">const</span> nextState <span class="op">=</span> <span class="at">produce</span>(baseState<span class="op">,</span> (draftState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb24-2" title="2">  <span class="va">draftState</span>.<span class="at">push</span>(<span class="op">{</span> <span class="dt">todo</span><span class="op">:</span> <span class="st">&quot;Tweet about it&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-3" title="3">  draftState[<span class="dv">1</span>].<span class="at">done</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h2 id="side-effects">Side Effects</h2>
<h4 id="widely-used">Widely Used</h4>
<p><strong><a href="https://github.com/gaearon/redux-thunk">gaearon/redux-thunk</a></strong> <br /> Dispatch functions, which are called and given <code>dispatch</code> and <code>getState</code> as parameters. This acts as a loophole for AJAX calls and other async behavior.</p>
<p><strong>Best for</strong>: getting started, simple async and complex synchronous logic.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">function</span> <span class="at">fetchData</span>(someValue) <span class="op">{</span></a>
<a class="sourceLine" id="cb25-2" title="2">    <span class="cf">return</span> (dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb25-3" title="3">        <span class="at">dispatch</span>(<span class="op">{</span><span class="dt">type </span><span class="op">:</span> <span class="st">&quot;REQUEST_STARTED&quot;</span><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5">        <span class="va">myAjaxLib</span>.<span class="at">post</span>(<span class="st">&quot;/someEndpoint&quot;</span><span class="op">,</span> <span class="op">{</span><span class="dt">data </span><span class="op">:</span> someValue<span class="op">}</span>)</a>
<a class="sourceLine" id="cb25-6" title="6">            .<span class="at">then</span>(response <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="op">{</span><span class="dt">type </span><span class="op">:</span> <span class="st">&quot;REQUEST_SUCCEEDED&quot;</span><span class="op">,</span> <span class="dt">payload </span><span class="op">:</span> response<span class="op">}</span>)</a>
<a class="sourceLine" id="cb25-7" title="7">            .<span class="at">catch</span>(error <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="op">{</span><span class="dt">type </span><span class="op">:</span> <span class="st">&quot;REQUEST_FAILED&quot;</span><span class="op">,</span> <span class="dt">error </span><span class="op">:</span> error<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-8" title="8">    <span class="op">};</span></a>
<a class="sourceLine" id="cb25-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb25-10" title="10"></a>
<a class="sourceLine" id="cb25-11" title="11"><span class="kw">function</span> <span class="at">addTodosIfAllowed</span>(todoText) <span class="op">{</span></a>
<a class="sourceLine" id="cb25-12" title="12">    <span class="cf">return</span> (dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb25-13" title="13">        <span class="kw">const</span> state <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb25-14" title="14"></a>
<a class="sourceLine" id="cb25-15" title="15">        <span class="cf">if</span>(<span class="va">state</span>.<span class="va">todos</span>.<span class="at">length</span> <span class="op">&lt;</span> MAX_TODOS) <span class="op">{</span></a>
<a class="sourceLine" id="cb25-16" title="16">            <span class="at">dispatch</span>(<span class="op">{</span><span class="dt">type </span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span> <span class="dt">text </span><span class="op">:</span> todoText<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-17" title="17">        <span class="op">}</span></a>
<a class="sourceLine" id="cb25-18" title="18">    <span class="op">}</span></a>
<a class="sourceLine" id="cb25-19" title="19"><span class="op">}</span></a></code></pre></div>
<p><strong><a href="https://github.com/redux-saga/redux-saga">redux-saga/redux-saga</a></strong> <br /> Handle async logic using synchronous-looking generator functions. Sagas return descriptions of effects, which are executed by the saga middleware, and act like “background threads” for JS applications.</p>
<p><strong>Best for</strong>: complex async logic, decoupled workflows</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">function</span><span class="op">*</span> <span class="at">fetchData</span>(action) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="kw">const</span> <span class="op">{</span> someValue <span class="op">}</span> <span class="op">=</span> action<span class="op">;</span></a>
<a class="sourceLine" id="cb26-3" title="3">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="kw">const</span> response <span class="op">=</span> <span class="kw">yield</span> <span class="at">call</span>(<span class="va">myAjaxLib</span>.<span class="at">post</span><span class="op">,</span> <span class="st">&quot;/someEndpoint&quot;</span><span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb26-5" title="5">      <span class="dt">data</span><span class="op">:</span> someValue<span class="op">,</span></a>
<a class="sourceLine" id="cb26-6" title="6">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-7" title="7">    <span class="kw">yield</span> <span class="at">put</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;REQUEST_SUCCEEDED&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> response <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-8" title="8">  <span class="op">}</span> <span class="cf">catch</span> (error) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="kw">yield</span> <span class="at">put</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;REQUEST_FAILED&quot;</span><span class="op">,</span> <span class="dt">error</span><span class="op">:</span> error <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="op">}</span></a>
<a class="sourceLine" id="cb26-12" title="12"></a>
<a class="sourceLine" id="cb26-13" title="13"><span class="kw">function</span><span class="op">*</span> <span class="at">addTodosIfAllowed</span>(action) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-14" title="14">  <span class="kw">const</span> <span class="op">{</span> todoText <span class="op">}</span> <span class="op">=</span> action<span class="op">;</span></a>
<a class="sourceLine" id="cb26-15" title="15">  <span class="kw">const</span> todos <span class="op">=</span> <span class="kw">yield</span> <span class="at">select</span>((state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-16" title="16"></a>
<a class="sourceLine" id="cb26-17" title="17">  <span class="cf">if</span> (<span class="va">todos</span>.<span class="at">length</span> <span class="op">&lt;</span> MAX_TODOS) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-18" title="18">    <span class="kw">yield</span> <span class="at">put</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> todoText <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb26-20" title="20"><span class="op">}</span></a></code></pre></div>
<p><strong><a href="https://github.com/redux-observable/redux-observable">redux-observable/redux-observable</a></strong></p>
<p>Handle async logic using RxJS observable chains called “epics”. Compose and cancel async actions to create side effects and more.</p>
<p><strong>Best for</strong>: complex async logic, decoupled workflows</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">const</span> loginRequestEpic <span class="op">=</span> (action$) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb27-2" title="2">  action$</a>
<a class="sourceLine" id="cb27-3" title="3">    .<span class="at">ofType</span>(LOGIN_REQUEST)</a>
<a class="sourceLine" id="cb27-4" title="4">    .<span class="at">mergeMap</span>((<span class="op">{</span> <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> username<span class="op">,</span> password <span class="op">}</span> <span class="op">}</span>) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb27-5" title="5">      <span class="va">Observable</span>.<span class="at">from</span>(<span class="at">postLogin</span>(username<span class="op">,</span> password))</a>
<a class="sourceLine" id="cb27-6" title="6">        .<span class="at">map</span>(loginSuccess)</a>
<a class="sourceLine" id="cb27-7" title="7">        .<span class="at">catch</span>(loginFailure)</a>
<a class="sourceLine" id="cb27-8" title="8">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb27-9" title="9"></a>
<a class="sourceLine" id="cb27-10" title="10"><span class="kw">const</span> loginSuccessfulEpic <span class="op">=</span> (action$) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb27-11" title="11">  action$</a>
<a class="sourceLine" id="cb27-12" title="12">    .<span class="at">ofType</span>(LOGIN_SUCCESS)</a>
<a class="sourceLine" id="cb27-13" title="13">    .<span class="at">delay</span>(<span class="dv">2000</span>)</a>
<a class="sourceLine" id="cb27-14" title="14">    .<span class="at">mergeMap</span>((<span class="op">{</span> <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> msg <span class="op">}</span> <span class="op">}</span>) <span class="kw">=&gt;</span> <span class="at">showMessage</span>(msg))<span class="op">;</span></a>
<a class="sourceLine" id="cb27-15" title="15"></a>
<a class="sourceLine" id="cb27-16" title="16"><span class="kw">const</span> rootEpic <span class="op">=</span> <span class="at">combineEpics</span>(loginRequestEpic<span class="op">,</span> loginSuccessfulEpic)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/redux-loop/redux-loop">redux-loop/redux-loop</a></strong></p>
<p>A port of the Elm Architecture to Redux that allows you to sequence your effects naturally and purely by returning them from your reducers. Reducers now return both a state value and a side effect description.</p>
<p><strong>Best for</strong>: trying to be as much like Elm as possible in Redux+JS</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb28-1" title="1"><span class="im">export</span> <span class="kw">const</span> reducer <span class="op">=</span> (state <span class="op">=</span> <span class="op">{},</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-2" title="2">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb28-3" title="3">    <span class="cf">case</span> <span class="va">ActionType</span>.<span class="at">LOGIN_REQUEST</span><span class="op">:</span></a>
<a class="sourceLine" id="cb28-4" title="4">      <span class="kw">const</span> <span class="op">{</span> username<span class="op">,</span> password <span class="op">}</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb28-5" title="5">      <span class="cf">return</span> <span class="at">loop</span>(</a>
<a class="sourceLine" id="cb28-6" title="6">        <span class="op">{</span> <span class="dt">pending</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb28-7" title="7">        <span class="va">Effect</span>.<span class="at">promise</span>(loginPromise<span class="op">,</span> username<span class="op">,</span> password)</a>
<a class="sourceLine" id="cb28-8" title="8">      )<span class="op">;</span></a>
<a class="sourceLine" id="cb28-9" title="9">    <span class="cf">case</span> <span class="va">ActionType</span>.<span class="at">LOGIN_SUCCESS</span><span class="op">:</span></a>
<a class="sourceLine" id="cb28-10" title="10">      <span class="kw">const</span> <span class="op">{</span> user<span class="op">,</span> msg <span class="op">}</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb28-11" title="11">      <span class="cf">return</span> <span class="at">loop</span>(</a>
<a class="sourceLine" id="cb28-12" title="12">        <span class="op">{</span> <span class="dt">pending</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> user <span class="op">},</span></a>
<a class="sourceLine" id="cb28-13" title="13">        <span class="va">Effect</span>.<span class="at">promise</span>(delayMessagePromise<span class="op">,</span> msg<span class="op">,</span> <span class="dv">2000</span>)</a>
<a class="sourceLine" id="cb28-14" title="14">      )<span class="op">;</span></a>
<a class="sourceLine" id="cb28-15" title="15">    <span class="cf">case</span> <span class="va">ActionType</span>.<span class="at">LOGIN_FAILURE</span><span class="op">:</span></a>
<a class="sourceLine" id="cb28-16" title="16">      <span class="cf">return</span> <span class="op">{</span> <span class="dt">pending</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="dt">err</span><span class="op">:</span> <span class="va">action</span>.<span class="at">payload</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb28-17" title="17">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb28-18" title="18">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb28-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-20" title="20"><span class="op">};</span></a></code></pre></div>
<p><strong><a href="https://github.com/jeffbski/redux-logic">jeffbski/redux-logic</a></strong></p>
<p>Side effects lib built with observables, but allows use of callbacks, promises, async/await, or observables. Provides declarative processing of actions.</p>
<p><strong>Best for</strong>: very decoupled async logic</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">const</span> loginLogic <span class="op">=</span> <span class="at">createLogic</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb29-2" title="2">  <span class="dt">type</span><span class="op">:</span> <span class="va">Actions</span>.<span class="at">LOGIN_REQUEST</span><span class="op">,</span></a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4">  <span class="at">process</span>(<span class="op">{</span> getState<span class="op">,</span> action <span class="op">},</span> dispatch<span class="op">,</span> done) <span class="op">{</span></a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="kw">const</span> <span class="op">{</span> username<span class="op">,</span> password <span class="op">}</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb29-6" title="6"></a>
<a class="sourceLine" id="cb29-7" title="7">    <span class="at">postLogin</span>(username<span class="op">,</span> password)</a>
<a class="sourceLine" id="cb29-8" title="8">      .<span class="at">then</span>(</a>
<a class="sourceLine" id="cb29-9" title="9">        (<span class="op">{</span> user<span class="op">,</span> msg <span class="op">}</span>) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-10" title="10">          <span class="at">dispatch</span>(<span class="at">loginSucceeded</span>(user))<span class="op">;</span></a>
<a class="sourceLine" id="cb29-11" title="11"></a>
<a class="sourceLine" id="cb29-12" title="12">          <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="at">showMessage</span>(msg))<span class="op">,</span> <span class="dv">2000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb29-13" title="13">        <span class="op">},</span></a>
<a class="sourceLine" id="cb29-14" title="14">        (err) <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="at">loginFailure</span>(err))</a>
<a class="sourceLine" id="cb29-15" title="15">      )</a>
<a class="sourceLine" id="cb29-16" title="16">      .<span class="at">then</span>(done)<span class="op">;</span></a>
<a class="sourceLine" id="cb29-17" title="17">  <span class="op">},</span></a>
<a class="sourceLine" id="cb29-18" title="18"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="promises">Promises</h4>
<p><strong><a href="https://github.com/acdlite/redux-promise">acdlite/redux-promise</a></strong> <br /> Dispatch promises as action payloads, and have FSA-compliant actions dispatched as the promise resolves or rejects.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb30-1" title="1"><span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;FETCH_DATA&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> <span class="va">myAjaxLib</span>.<span class="at">get</span>(<span class="st">&quot;/data&quot;</span>) <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">// will dispatch either {type : &quot;FETCH_DATA&quot;, payload : response} if resolved,</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="co">// or dispatch {type : &quot;FETCH_DATA&quot;, payload : error, error : true} if rejected</span></a></code></pre></div>
<p><strong><a href="https://github.com/lelandrichardson/redux-pack">lelandrichardson/redux-pack</a></strong> <br /> Sensible, declarative, convention-based promise handling that guides users in a good direction without exposing the full power of dispatch.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb31-1" title="1"><span class="at">dispatch</span>(<span class="op">{</span><span class="dt">type </span><span class="op">:</span> <span class="st">&quot;FETCH_DATA&quot;</span><span class="op">,</span> <span class="dt">payload </span><span class="op">:</span> <span class="va">myAjaxLib</span>.<span class="at">get</span>(<span class="st">&quot;/data&quot;</span>) <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="co">// in a reducer:</span></a>
<a class="sourceLine" id="cb31-4" title="4">        <span class="cf">case</span> <span class="st">&quot;FETCH_DATA&quot;</span><span class="op">:</span> <span class="op">=</span></a>
<a class="sourceLine" id="cb31-5" title="5">            <span class="cf">return</span> <span class="at">handle</span>(state<span class="op">,</span> action<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-6" title="6">                <span class="dt">start</span><span class="op">:</span> prevState <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb31-7" title="7">                  ...<span class="at">prevState</span><span class="op">,</span></a>
<a class="sourceLine" id="cb31-8" title="8">                  <span class="dt">isLoading</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb31-9" title="9">                  <span class="dt">fooError</span><span class="op">:</span> <span class="kw">null</span></a>
<a class="sourceLine" id="cb31-10" title="10">                <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb31-11" title="11">                <span class="dt">finish</span><span class="op">:</span> prevState <span class="kw">=&gt;</span> (<span class="op">{</span> ...<span class="at">prevState</span><span class="op">,</span> <span class="dt">isLoading</span><span class="op">:</span> <span class="kw">false</span> <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb31-12" title="12">                <span class="dt">failure</span><span class="op">:</span> prevState <span class="kw">=&gt;</span> (<span class="op">{</span> ...<span class="at">prevState</span><span class="op">,</span> <span class="dt">fooError</span><span class="op">:</span> payload <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb31-13" title="13">                <span class="dt">success</span><span class="op">:</span> prevState <span class="kw">=&gt;</span> (<span class="op">{</span> ...<span class="at">prevState</span><span class="op">,</span> <span class="dt">foo</span><span class="op">:</span> payload <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb31-14" title="14">            <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h2 id="middleware">Middleware</h2>
<h4 id="networks-and-sockets">Networks and Sockets</h4>
<p><strong><a href="https://github.com/svrcekmichal/redux-axios-middleware">svrcekmichal/redux-axios-middleware</a></strong> <br /> Fetches data with Axios and dispatches start/success/fail actions</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb32-1" title="1"><span class="im">export</span> <span class="kw">const</span> <span class="at">loadCategories</span>() <span class="kw">=&gt;</span> (<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;LOAD&#39;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> <span class="dt">request </span><span class="op">:</span> <span class="op">{</span> <span class="dt">url</span><span class="op">:</span> <span class="st">&#39;/categories&#39;</span><span class="op">}</span> <span class="op">}</span> <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/agraboso/redux-api-middleware">agraboso/redux-api-middleware</a></strong> <br /> Reads API call actions, fetches, and dispatches FSAs</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">const</span> fetchUsers <span class="op">=</span> () <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb33-2" title="2">  [CALL_API]<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb33-3" title="3">    <span class="dt">endpoint</span><span class="op">:</span> <span class="st">&quot;http://www.example.com/api/users&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb33-4" title="4">    <span class="dt">method</span><span class="op">:</span> <span class="st">&quot;GET&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="dt">types</span><span class="op">:</span> [<span class="st">&quot;REQUEST&quot;</span><span class="op">,</span> <span class="st">&quot;SUCCESS&quot;</span><span class="op">,</span> <span class="st">&quot;FAILURE&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb33-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/itaylor/redux-socket.io">itaylor/redux-socket.io</a></strong> <br /> An opinionated connector between socket.io and redux.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(reducer<span class="op">,</span> <span class="at">applyMiddleware</span>(socketIoMiddleware))<span class="op">;</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;server/hello&quot;</span><span class="op">,</span> <span class="dt">data</span><span class="op">:</span> <span class="st">&quot;Hello!&quot;</span> <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/tiberiuc/redux-react-firebase">tiberiuc/redux-react-firebase</a></strong> <br /> Integration between Firebase, React, and Redux</p>
<h4 id="async-behavior">Async Behavior</h4>
<p><strong><a href="https://github.com/rt2zz/redux-action-buffer">rt2zz/redux-action-buffer</a></strong> <br /> Buffers all actions into a queue until a breaker condition is met, at which point the queue is released</p>
<p><strong><a href="https://github.com/wyze/redux-debounce">wyze/redux-debounce</a></strong> <br /> FSA-compliant middleware for Redux to debounce actions.</p>
<p><strong><a href="https://github.com/mathieudutour/redux-queue-offline">mathieudutour/redux-queue-offline</a></strong> <br /> Queue actions when offline and dispatch them when getting back online.</p>
<h4 id="analytics">Analytics</h4>
<p><strong><a href="https://github.com/rangle/redux-beacon">rangle/redux-beacon</a></strong> <br /> Integrates with any analytics services, can track while offline, and decouples analytics logic from app logic</p>
<p><strong><a href="https://github.com/markdalgleish/redux-analytics">markdalgleish/redux-analytics</a></strong> <br /> Watches for Flux Standard Actions with meta analytics values and processes them</p>
<h2 id="entities-and-collections">Entities and Collections</h2>
<p><strong><a href="https://github.com/tommikaikkonen/redux-orm">tommikaikkonen/redux-orm</a></strong> <br /> A simple immutable ORM to manage relational data in your Redux store.</p>
<p><strong><a href="https://github.com/Versent/redux-crud">Versent/redux-crud</a></strong> <br /> Convention-based actions and reducers for CRUD logic</p>
<p><strong><a href="https://github.com/kwelch/entities-reducer">kwelch/entities-reducer</a></strong> <br /> A higher-order reducer that handles data from Normalizr</p>
<p><strong><a href="https://github.com/amplitude/redux-query">amplitude/redux-query</a></strong> <br /> Declare colocated data dependencies with your components, run queries when components mount, perform optimistic updates, and trigger server changes with Redux actions.</p>
<p><strong><a href="https://github.com/cantierecreativo/redux-bees">cantierecreativo/redux-bees</a></strong> <br /> Declarative JSON-API interaction that normalizes data, with a React HOC that can run queries</p>
<p><strong><a href="https://github.com/GetAmbassador/redux-clerk">GetAmbassador/redux-clerk</a></strong> <br /> Async CRUD handling with normalization, optimistic updates, sync/async action creators, selectors, and an extendable reducer.</p>
<p><strong><a href="https://github.com/shoutem/redux-io">shoutem/redux-io</a></strong> <br /> JSON-API abstraction with async CRUD, normalization, optimistic updates, caching, data status, and error handling.</p>
<p><strong><a href="https://github.com/jmeas/redux-resource">jmeas/redux-resource</a></strong> <br /> A tiny but powerful system for managing ‘resources’: data that is persisted to remote servers.</p>
<h2 id="component-state-and-encapsulation">Component State and Encapsulation</h2>
<p><strong><a href="https://github.com/threepointone/redux-react-local">threepointone/redux-react-local</a></strong> <br /> Local component state in Redux, with handling for component actions</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1">@<span class="at">local</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb35-2" title="2">  <span class="dt">ident</span><span class="op">:</span> <span class="st">&#39;counter&#39;</span><span class="op">,</span> <span class="dt">initial</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">reducer </span><span class="op">:</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="va">action</span>.<span class="at">me</span> <span class="op">?</span> state <span class="op">+</span> <span class="dv">1</span> : state <span class="op">}</span></a>
<a class="sourceLine" id="cb35-3" title="3">})</a>
<a class="sourceLine" id="cb35-4" title="4"><span class="kw">class</span> Counter <span class="kw">extends</span> <span class="va">React</span>.<span class="at">Component</span> <span class="op">{</span></a></code></pre></div>
<p><strong><a href="https://github.com/epeli/lean-redux">epeli/lean-redux</a></strong> <br /> Makes component state in Redux as easy as setState</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">const</span> DynamicCounters <span class="op">=</span> <span class="at">connectLean</span>(</a>
<a class="sourceLine" id="cb36-2" title="2">    scope<span class="op">:</span> <span class="st">&quot;dynamicCounters&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb36-3" title="3">    <span class="at">getInitialState</span>() <span class="kw">=&gt;</span> (<span class="op">{</span><span class="dt">counterCount </span><span class="op">:</span> <span class="dv">1</span><span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb36-4" title="4">    addCounter<span class="op">,</span> removeCounter</a>
<a class="sourceLine" id="cb36-5" title="5">)(CounterList)<span class="op">;</span></a></code></pre></div>
<p><strong><a href="https://github.com/DataDog/redux-doghouse">DataDog/redux-doghouse</a></strong> <br /> Aims to make reusable components easier to build with Redux by scoping actions and reducers to a particular instance of a component.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">const</span> scopeableActions <span class="op">=</span> <span class="kw">new</span> <span class="at">ScopedActionFactory</span>(actionCreators)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="kw">const</span> actionCreatorsScopedToA <span class="op">=</span> <span class="va">scopeableActions</span>.<span class="at">scope</span>(<span class="st">&quot;a&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="va">actionCreatorsScopedToA</span>.<span class="at">foo</span>(<span class="st">&quot;bar&quot;</span>)<span class="op">;</span> <span class="co">//{ type: SET_FOO, value: &#39;bar&#39;, scopeID: &#39;a&#39; }</span></a>
<a class="sourceLine" id="cb37-4" title="4"></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="kw">const</span> boundScopeableActions <span class="op">=</span> <span class="at">bindScopedActionFactories</span>(</a>
<a class="sourceLine" id="cb37-6" title="6">  scopeableActions<span class="op">,</span></a>
<a class="sourceLine" id="cb37-7" title="7">  <span class="va">store</span>.<span class="at">dispatch</span></a>
<a class="sourceLine" id="cb37-8" title="8">)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-9" title="9"><span class="kw">const</span> scopedReducers <span class="op">=</span> <span class="at">scopeReducers</span>(reducers)<span class="op">;</span></a></code></pre></div>
<h2 id="dev-tools">Dev Tools</h2>
<h4 id="debuggers-and-viewers">Debuggers and Viewers</h4>
<p><strong><a href="https://github.com/reduxjs/redux-devtools">reduxjs/redux-devtools</a></strong></p>
<p>Dan Abramov’s original Redux DevTools implementation, built for in-app display of state and time-travel debugging</p>
<p><strong><a href="https://github.com/zalmoxisus/redux-devtools-extension">zalmoxisus/redux-devtools-extension</a></strong></p>
<p>Mihail Diordiev’s browser extension, which bundles multiple state monitor views and adds integration with the browser’s own dev tools</p>
<p><strong><a href="https://github.com/infinitered/reactotron">infinitered/reactotron</a></strong></p>
<p>A cross-platform Electron app for inspecting React and React Native apps, including app state, API requests, perf, errors, sagas, and action dispatching.</p>
<h4 id="devtools-monitors">DevTools Monitors</h4>
<p><strong><a href="https://github.com/reduxjs/redux-devtools/tree/master/packages/redux-devtools-log-monitor">Log Monitor</a></strong> <br /> The default monitor for Redux DevTools with a tree view</p>
<p><strong><a href="https://github.com/reduxjs/redux-devtools/tree/master/packages/redux-devtools-dock-monitor">Dock Monitor</a></strong> <br /> A resizable and movable dock for Redux DevTools monitors</p>
<p><strong><a href="https://github.com/calesce/redux-slider-monitor">Slider Monitor</a></strong> <br /> A custom monitor for Redux DevTools to replay recorded Redux actions</p>
<p><strong><a href="https://github.com/whetstone/redux-devtools-diff-monitor">Diff Monitor</a></strong> <br /> A monitor for Redux DevTools that diffs the Redux store mutations between actions</p>
<p><strong><a href="https://github.com/bvaughn/redux-devtools-filterable-log-monitor/">Filterable Log Monitor</a></strong> <br /> Filterable tree view monitor for Redux DevTools</p>
<p><strong><a href="https://github.com/zalmoxisus/redux-devtools-filter-actions">Filter Actions</a></strong> <br /> Redux DevTools composable monitor with the ability to filter actions</p>
<h4 id="logging">Logging</h4>
<p><strong><a href="https://github.com/evgenyrodionov/redux-logger">evgenyrodionov/redux-logger</a></strong> <br /> Logging middleware that shows actions, states, and diffs</p>
<p><strong><a href="https://github.com/inakianduaga/redux-state-history">inakianduaga/redux-state-history</a></strong> <br /> Enhancer that provides time-travel and efficient action recording capabilities, including import/export of action logs and action playback.</p>
<p><strong><a href="https://github.com/joshwcomeau/redux-vcr">joshwcomeau/redux-vcr</a></strong> <br /> Record and replay user sessions in real-time</p>
<p><strong><a href="https://github.com/socialtables/redux-unhandled-action">socialtables/redux-unhandled-action</a></strong> <br /> Warns about actions that produced no state changes in development</p>
<h4 id="mutation-detection">Mutation Detection</h4>
<p><strong><a href="https://github.com/leoasis/redux-immutable-state-invariant">leoasis/redux-immutable-state-invariant</a></strong> <br /> Middleware that throws an error when you try to mutate your state either inside a dispatch or between dispatches.</p>
<p><strong><a href="https://github.com/flexport/mutation-sentinel">flexport/mutation-sentinel</a></strong> <br /> Helps you deeply detect mutations at runtime and enforce immutability in your codebase.</p>
<p><strong><a href="https://github.com/mmahalwy/redux-pure-connect">mmahalwy/redux-pure-connect</a></strong> <br /> Check and log whether react-redux’s connect method is passed <code>mapState</code> functions that create impure props.</p>
<h2 id="testing">Testing</h2>
<p><strong><a href="https://github.com/arnaudbenard/redux-mock-store">arnaudbenard/redux-mock-store</a></strong> <br /> A mock store that saves dispatched actions in an array for assertions</p>
<p><strong><a href="https://github.com/Workable/redux-test-belt">Workable/redux-test-belt</a></strong> <br /> Extends the store API to make it easier assert, isolate, and manipulate the store</p>
<p><strong><a href="https://github.com/conorhastings/redux-test-recorder">conorhastings/redux-test-recorder</a></strong> <br /> Middleware to automatically generate reducers tests based on actions in the app</p>
<p><strong><a href="https://github.com/wix/redux-testkit">wix/redux-testkit</a></strong> <br /> Complete and opinionated testkit for testing Redux projects (reducers, selectors, actions, thunks)</p>
<p><strong><a href="https://github.com/jfairbank/redux-saga-test-plan">jfairbank/redux-saga-test-plan</a></strong> <br /> Makes integration and unit testing of sagas a breeze</p>
<h2 id="routing">Routing</h2>
<p><strong><a href="https://github.com/supasate/connected-react-router">supasate/connected-react-router</a></strong> Synchronize React Router 4 state with your Redux store.</p>
<p><strong><a href="https://github.com/faceyspacey/redux-first-router">faceyspacey/redux-first-router</a></strong> <br /> Seamless Redux-first routing. Think of your app in states, not routes, not components, while keeping the address bar in sync. Everything is state. Connect your components and just dispatch flux standard actions.</p>
<h2 id="forms">Forms</h2>
<p><strong><a href="https://github.com/erikras/redux-form">erikras/redux-form</a></strong> <br /> A full-featured library to enable a React HTML form to store its state in Redux.</p>
<p><strong><a href="https://github.com/davidkpiano/react-redux-form">davidkpiano/react-redux-form</a></strong> <br /> React Redux Form is a collection of reducer creators and action creators that make implementing even the most complex and custom forms with React and Redux simple and performant.</p>
<h2 id="higher-level-abstractions">Higher-Level Abstractions</h2>
<p><strong><a href="https://github.com/keajs/kea">keajs/kea</a></strong> <br /> An abstraction over Redux, Redux-Saga and Reselect. Provides a framework for your app’s actions, reducers, selectors and sagas. It empowers Redux, making it as simple to use as setState. It reduces boilerplate and redundancy, while retaining composability.</p>
<p><strong><a href="https://github.com/TheComfyChair/redux-scc">TheComfyChair/redux-scc</a></strong> <br /> Takes a defined structure and uses ‘behaviors’ to create a set of actions, reducer responses and selectors.</p>
<p><strong><a href="https://github.com/Bloomca/redux-tiles">Bloomca/redux-tiles</a></strong> <br /> Provides minimal abstraction on top of Redux, to allow easy composability, easy async requests, and sane testability.</p>
<h2 id="community-conventions">Community Conventions</h2>
<p><strong><a href="https://github.com/acdlite/flux-standard-action">Flux Standard Action</a></strong> <br /> A human-friendly standard for Flux action objects</p>
<p><strong><a href="https://github.com/gajus/canonical-reducer-composition">Canonical Reducer Composition</a></strong> <br /> An opinionated standard for nested reducer composition</p>
<p><strong><a href="https://github.com/erikras/ducks-modular-redux">Ducks: Redux Reducer Bundles</a></strong> <br /> A proposal for bundling reducers, action types and actions</p>
<hr />
<p>id: examples title: Examples description: ‘Introduction &gt; Examples: Redux interactive example apps’</p>
<hr />
<h1 id="examples">Examples</h1>
<p>Redux is distributed with a few examples in its <a href="https://github.com/reduxjs/redux/tree/master/examples">source code</a>. Most of these examples are also on <a href="https://codesandbox.io">CodeSandbox</a>, an online editor that lets you play with the examples online.</p>
<h2 id="counter-vanilla">Counter Vanilla</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/counter-vanilla">Counter Vanilla</a> example:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb38-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="bu">cd</span> redux/examples/counter-vanilla</a>
<a class="sourceLine" id="cb38-4" title="4"><span class="ex">open</span> index.html</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/counter-vanilla">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/counter-vanilla/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</p>
<h2 id="counter">Counter</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/counter">Counter</a> example:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb39-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb39-2" title="2"></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="bu">cd</span> redux/examples/counter</a>
<a class="sourceLine" id="cb39-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb39-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/counter">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/counter/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant <a href="https://github.com/reduxjs/react-redux">React Redux</a> bindings instead.</p>
<p>This example includes tests.</p>
<h2 id="todos">Todos</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/todos">Todos</a> example:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb40-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb40-2" title="2"></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="bu">cd</span> redux/examples/todos</a>
<a class="sourceLine" id="cb40-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb40-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/todos">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/todos/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use <a href="https://github.com/reduxjs/react-redux">React Redux</a> to generate container components from your presentational components.</p>
<p>This example includes tests.</p>
<h2 id="todos-with-undo">Todos with Undo</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/todos-with-undo">Todos with Undo</a> example:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb41-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb41-2" title="2"></a>
<a class="sourceLine" id="cb41-3" title="3"><span class="bu">cd</span> redux/examples/todos-with-undo</a>
<a class="sourceLine" id="cb41-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb41-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/todos-with-undo">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/todos-with-undo/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with <a href="https://github.com/omnidan/redux-undo">Redux Undo</a> lets you add a Undo/Redo functionality to your app with a few lines of code.</p>
<h2 id="todomvc">TodoMVC</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/todomvc">TodoMVC</a> example:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb42-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb42-2" title="2"></a>
<a class="sourceLine" id="cb42-3" title="3"><span class="bu">cd</span> redux/examples/todomvc</a>
<a class="sourceLine" id="cb42-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb42-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/todomvc">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/todomvc/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This is the classical <a href="http://todomvc.com/">TodoMVC</a> example. It’s here for the sake of comparison, but it covers the same points as the Todos example.</p>
<p>This example includes tests.</p>
<h2 id="shopping-cart">Shopping Cart</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/shopping-cart">Shopping Cart</a> example:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb43-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb43-2" title="2"></a>
<a class="sourceLine" id="cb43-3" title="3"><span class="bu">cd</span> redux/examples/shopping-cart</a>
<a class="sourceLine" id="cb43-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb43-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/shopping-cart">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/shopping-cart/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with <a href="https://github.com/fcomb/redux-logger">Redux Logger</a> and conditional dispatching of actions with <a href="https://github.com/gaearon/redux-thunk">Redux Thunk</a> middleware.</p>
<h2 id="tree-view">Tree View</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/tree-view">Tree View</a> example:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb44-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="bu">cd</span> redux/examples/tree-view</a>
<a class="sourceLine" id="cb44-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb44-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/tree-view">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/tree-view/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</p>
<p>This example includes tests.</p>
<h2 id="async">Async</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/async">Async</a> example:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb45-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="bu">cd</span> redux/examples/async</a>
<a class="sourceLine" id="cb45-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb45-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/async">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/async/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses <a href="https://github.com/gaearon/redux-thunk">Redux Thunk</a> middleware to encapsulate asynchronous side effects.</p>
<h2 id="universal">Universal</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/universal">Universal</a> example:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb46-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb46-2" title="2"></a>
<a class="sourceLine" id="cb46-3" title="3"><span class="bu">cd</span> redux/examples/universal</a>
<a class="sourceLine" id="cb46-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb46-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>This is a basic demonstration of <a href="../usage/ServerRendering.md">server rendering</a> with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</p>
<h2 id="real-world">Real World</h2>
<p>Run the <a href="https://github.com/reduxjs/redux/tree/master/examples/real-world">Real World</a> example:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb47-1" title="1"><span class="fu">git</span> clone https://github.com/reduxjs/redux.git</a>
<a class="sourceLine" id="cb47-2" title="2"></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="bu">cd</span> redux/examples/real-world</a>
<a class="sourceLine" id="cb47-4" title="4"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb47-5" title="5"><span class="ex">npm</span> start</a></code></pre></div>
<p>Or check out the <a href="https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/real-world">sandbox</a>:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux/tree/master/examples/real-world/?runonclick=1" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</p>
<h2 id="more-examples">More Examples</h2>
<p>You can find more examples in the <a href="https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md">Redux Apps and Examples</a> page of the <a href="https://github.com/markerikson/redux-ecosystem-links">Redux Addons Catalog</a>.</p>
<hr />
<p>id: getting-started title: Getting Started with Redux description: ‘Introduction &gt; Getting Started: Resources to get started learning and using Redux’</p>
<hr />
<p>import LiteYouTubeEmbed from ‘react-lite-youtube-embed’; import ‘react-lite-youtube-embed/dist/LiteYouTubeEmbed.css’</p>
<p>Redux is a predictable state container for JavaScript apps.</p>
<p>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as <a href="https://github.com/reduxjs/redux-devtools">live code editing combined with a time traveling debugger</a>.</p>
<p>You can use Redux together with <a href="https://reactjs.org">React</a>, or with any other view library. It is tiny (2kB, including dependencies), but has a large ecosystem of addons available.</p>
<h2 id="installation">Installation</h2>
<h3 id="redux-toolkit">Redux Toolkit</h3>
<p><a href="https://redux-toolkit.js.org"><strong>Redux Toolkit</strong></a> is our official recommended approach for writing Redux logic. It wraps around the Redux core, and contains packages and functions that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications.</p>
<p>RTK includes utilities that help simplify many common use cases, including <a href="https://redux-toolkit.js.org/api/configureStore">store setup</a>, <a href="https://redux-toolkit.js.org/api/createreducer">creating reducers and writing immutable update logic</a>, and even <a href="https://redux-toolkit.js.org/api/createslice">creating entire “slices” of state at once</a>.</p>
<p>Whether you’re a brand new Redux user setting up your first project, or an experienced user who wants to simplify an existing application, <strong><a href="https://redux-toolkit.js.org/">Redux Toolkit</a></strong> can help you make your Redux code better.</p>
<p>Redux Toolkit is available as a package on NPM for use with a module bundler or in a Node application:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb48-1" title="1"><span class="co"># NPM</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="ex">npm</span> install @reduxjs/toolkit</a>
<a class="sourceLine" id="cb48-3" title="3"></a>
<a class="sourceLine" id="cb48-4" title="4"><span class="co"># Yarn</span></a>
<a class="sourceLine" id="cb48-5" title="5"><span class="ex">yarn</span> add @reduxjs/toolkit</a></code></pre></div>
<h3 id="create-a-react-redux-app">Create a React Redux App</h3>
<p>The recommended way to start new apps with React and Redux is by using the <a href="https://github.com/reduxjs/cra-template-redux">official Redux+JS template</a> or <a href="https://github.com/reduxjs/cra-template-redux-typescript">Redux+TS template</a> for <a href="https://github.com/facebook/create-react-app">Create React App</a>, which takes advantage of <strong><a href="https://redux-toolkit.js.org/">Redux Toolkit</a></strong> and React Redux’s integration with React components.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb49-1" title="1"><span class="co"># Redux + Plain JS template</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="ex">npx</span> create-react-app my-app --template redux</a>
<a class="sourceLine" id="cb49-3" title="3"></a>
<a class="sourceLine" id="cb49-4" title="4"><span class="co"># Redux + TypeScript template</span></a>
<a class="sourceLine" id="cb49-5" title="5"><span class="ex">npx</span> create-react-app my-app --template redux-typescript</a></code></pre></div>
<h3 id="redux-core">Redux Core</h3>
<p>The Redux core library is available as a package on NPM for use with a module bundler or in a Node application:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb50-1" title="1"><span class="co"># NPM</span></a>
<a class="sourceLine" id="cb50-2" title="2"><span class="ex">npm</span> install redux</a>
<a class="sourceLine" id="cb50-3" title="3"></a>
<a class="sourceLine" id="cb50-4" title="4"><span class="co"># Yarn</span></a>
<a class="sourceLine" id="cb50-5" title="5"><span class="ex">yarn</span> add redux</a></code></pre></div>
<p>It is also available as a precompiled UMD package that defines a <code>window.Redux</code> global variable. The UMD package can be used as a <a href="https://unpkg.com/redux/dist/redux.js"><code>&lt;script&gt;</code> tag</a> directly.</p>
<p>For more details, see the <a href="Installation.md">Installation</a> page.</p>
<h2 id="basic-example">Basic Example</h2>
<p>The whole global state of your app is stored in an object tree inside a single <em>store</em>. The only way to change the state tree is to create an <em>action</em>, an object describing what happened, and <em>dispatch</em> it to the store. To specify how state gets updated in response to an action, you write pure <em>reducer</em> functions that calculate a new state based on the old state and the action.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb51-1" title="1"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb51-2" title="2"></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="co">/**</span></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="co"> * This is a reducer - a function that takes a current state value and an</span></a>
<a class="sourceLine" id="cb51-5" title="5"><span class="co"> * action object describing &quot;what happened&quot;, and returns a new state value.</span></a>
<a class="sourceLine" id="cb51-6" title="6"><span class="co"> * A reducer&#39;s function signature is: (state, action) =&gt; newState</span></a>
<a class="sourceLine" id="cb51-7" title="7"><span class="co"> *</span></a>
<a class="sourceLine" id="cb51-8" title="8"><span class="co"> * The Redux state should contain only plain JS objects, arrays, and primitives.</span></a>
<a class="sourceLine" id="cb51-9" title="9"><span class="co"> * The root state value is usually an object.  It&#39;s important that you should</span></a>
<a class="sourceLine" id="cb51-10" title="10"><span class="co"> * not mutate the state object, but return a new object if the state changes.</span></a>
<a class="sourceLine" id="cb51-11" title="11"><span class="co"> *</span></a>
<a class="sourceLine" id="cb51-12" title="12"><span class="co"> * You can use any conditional logic you want in a reducer. In this example,</span></a>
<a class="sourceLine" id="cb51-13" title="13"><span class="co"> * we use a switch statement, but it&#39;s not required.</span></a>
<a class="sourceLine" id="cb51-14" title="14"><span class="co"> */</span></a>
<a class="sourceLine" id="cb51-15" title="15"><span class="kw">function</span> <span class="at">counterReducer</span>(state <span class="op">=</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span> <span class="op">},</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb51-16" title="16">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb51-17" title="17">    <span class="cf">case</span> <span class="st">&quot;counter/incremented&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb51-18" title="18">      <span class="cf">return</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="va">state</span>.<span class="at">value</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb51-19" title="19">    <span class="cf">case</span> <span class="st">&quot;counter/decremented&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb51-20" title="20">      <span class="cf">return</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="va">state</span>.<span class="at">value</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb51-21" title="21">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb51-22" title="22">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb51-23" title="23">  <span class="op">}</span></a>
<a class="sourceLine" id="cb51-24" title="24"><span class="op">}</span></a>
<a class="sourceLine" id="cb51-25" title="25"></a>
<a class="sourceLine" id="cb51-26" title="26"><span class="co">// Create a Redux store holding the state of your app.</span></a>
<a class="sourceLine" id="cb51-27" title="27"><span class="co">// Its API is { subscribe, dispatch, getState }.</span></a>
<a class="sourceLine" id="cb51-28" title="28"><span class="kw">let</span> store <span class="op">=</span> <span class="at">createStore</span>(counterReducer)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-29" title="29"></a>
<a class="sourceLine" id="cb51-30" title="30"><span class="co">// You can use subscribe() to update the UI in response to state changes.</span></a>
<a class="sourceLine" id="cb51-31" title="31"><span class="co">// Normally you&#39;d use a view binding library (e.g. React Redux) rather than subscribe() directly.</span></a>
<a class="sourceLine" id="cb51-32" title="32"><span class="co">// There may be additional use cases where it&#39;s helpful to subscribe as well.</span></a>
<a class="sourceLine" id="cb51-33" title="33"></a>
<a class="sourceLine" id="cb51-34" title="34"><span class="va">store</span>.<span class="at">subscribe</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>()))<span class="op">;</span></a>
<a class="sourceLine" id="cb51-35" title="35"></a>
<a class="sourceLine" id="cb51-36" title="36"><span class="co">// The only way to mutate the internal state is to dispatch an action.</span></a>
<a class="sourceLine" id="cb51-37" title="37"><span class="co">// The actions can be serialized, logged or stored and later replayed.</span></a>
<a class="sourceLine" id="cb51-38" title="38"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-39" title="39"><span class="co">// {value: 1}</span></a>
<a class="sourceLine" id="cb51-40" title="40"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-41" title="41"><span class="co">// {value: 2}</span></a>
<a class="sourceLine" id="cb51-42" title="42"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/decremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-43" title="43"><span class="co">// {value: 1}</span></a></code></pre></div>
<p>Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called <em>actions</em>. Then you write a special function called a <em>reducer</em> to decide how every action transforms the entire application’s state.</p>
<p>In a typical Redux app, there is just a single store with a single root reducing function. As your app grows, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.</p>
<p>This architecture might seem like a lot for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</p>
<h3 id="redux-toolkit-example">Redux Toolkit Example</h3>
<p>Redux Toolkit simplifies the process of writing Redux logic and setting up the store. With Redux Toolkit, that same logic looks like:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb52-1" title="1"><span class="im">import</span> <span class="op">{</span> createSlice<span class="op">,</span> configureStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb52-2" title="2"></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="kw">const</span> counterSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb52-4" title="4">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;counter&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb52-5" title="5">  <span class="dt">initialState</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-6" title="6">    <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb52-7" title="7">  <span class="op">},</span></a>
<a class="sourceLine" id="cb52-8" title="8">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-9" title="9">    <span class="dt">incremented</span><span class="op">:</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-10" title="10">      <span class="co">// Redux Toolkit allows us to write &quot;mutating&quot; logic in reducers. It</span></a>
<a class="sourceLine" id="cb52-11" title="11">      <span class="co">// doesn&#39;t actually mutate the state because it uses the Immer library,</span></a>
<a class="sourceLine" id="cb52-12" title="12">      <span class="co">// which detects changes to a &quot;draft state&quot; and produces a brand new</span></a>
<a class="sourceLine" id="cb52-13" title="13">      <span class="co">// immutable state based off those changes</span></a>
<a class="sourceLine" id="cb52-14" title="14">      <span class="va">state</span>.<span class="at">value</span> <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb52-15" title="15">    <span class="op">},</span></a>
<a class="sourceLine" id="cb52-16" title="16">    <span class="dt">decremented</span><span class="op">:</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-17" title="17">      <span class="va">state</span>.<span class="at">value</span> <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb52-18" title="18">    <span class="op">},</span></a>
<a class="sourceLine" id="cb52-19" title="19">  <span class="op">},</span></a>
<a class="sourceLine" id="cb52-20" title="20"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb52-21" title="21"></a>
<a class="sourceLine" id="cb52-22" title="22"><span class="im">export</span> <span class="kw">const</span> <span class="op">{</span> incremented<span class="op">,</span> decremented <span class="op">}</span> <span class="op">=</span> <span class="va">counterSlice</span>.<span class="at">actions</span><span class="op">;</span></a>
<a class="sourceLine" id="cb52-23" title="23"></a>
<a class="sourceLine" id="cb52-24" title="24"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb52-25" title="25">  <span class="dt">reducer</span><span class="op">:</span> <span class="va">counterSlice</span>.<span class="at">reducer</span><span class="op">,</span></a>
<a class="sourceLine" id="cb52-26" title="26"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb52-27" title="27"></a>
<a class="sourceLine" id="cb52-28" title="28"><span class="co">// Can still subscribe to the store</span></a>
<a class="sourceLine" id="cb52-29" title="29"><span class="va">store</span>.<span class="at">subscribe</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>()))<span class="op">;</span></a>
<a class="sourceLine" id="cb52-30" title="30"></a>
<a class="sourceLine" id="cb52-31" title="31"><span class="co">// Still pass action objects to `dispatch`, but they&#39;re created for us</span></a>
<a class="sourceLine" id="cb52-32" title="32"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">incremented</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb52-33" title="33"><span class="co">// {value: 1}</span></a>
<a class="sourceLine" id="cb52-34" title="34"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">incremented</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb52-35" title="35"><span class="co">// {value: 2}</span></a>
<a class="sourceLine" id="cb52-36" title="36"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">decremented</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb52-37" title="37"><span class="co">// {value: 1}</span></a></code></pre></div>
<p>Redux Toolkit allows us to write shorter logic that’s easier to read, while still following the same Redux behavior and data flow.</p>
<h2 id="learn-redux">Learn Redux</h2>
<p>We have a variety of resources available to help you learn Redux.</p>
<h3 id="redux-essentials-tutorial">Redux Essentials Tutorial</h3>
<p>The <a href="../tutorials/essentials/part-1-overview-concepts.md"><strong>Redux Essentials tutorial</strong></a> is a “top-down” tutorial that teaches “how to use Redux the right way”, using our latest recommended APIs and best practices. We recommend starting there.</p>
<h3 id="redux-fundamentals-tutorial">Redux Fundamentals Tutorial</h3>
<p>The <a href="../tutorials/fundamentals/part-1-overview.md"><strong>Redux Fundamentals tutorial</strong></a> is a “bottom-up” tutorial that teaches “how Redux works” from first principles and without any abstractions, and why standard Redux usage patterns exist.</p>
<h3 id="learn-modern-redux-livestream">Learn Modern Redux Livestream</h3>
<p>Redux maintainer Mark Erikson appeared on the “Learn with Jason” show to explain how we recommend using Redux today. The show includes a live-coded example app that shows how to use Redux Toolkit and React-Redux hooks with Typescript, as well as the new RTK Query data fetching APIs.</p>
<p>See <a href="https://www.learnwithjason.dev/let-s-learn-modern-redux">the “Learn Modern Redux” show notes page</a> for a transcript and links to the example app source.</p>
<p><LiteYouTubeEmbed
    id="9zySeP5vH9c"
    title="Learn Modern Redux - Redux Toolkit, React-Redux Hooks, and RTK Query"
/></p>
<h3 id="additional-tutorials">Additional Tutorials</h3>
<ul>
<li>The Redux repository contains several example projects demonstrating various aspects of how to use Redux. Almost all examples have a corresponding CodeSandbox sandbox. This is an interactive version of the code that you can play with online. See the complete list of examples in the <strong><a href="./Examples.md">Examples page</a></strong>.</li>
<li>Redux creator Dan Abramov’s <strong>free <a href="https://app.egghead.io/playlists/fundamentals-of-redux-course-from-dan-abramov-bd5cc867">“Getting Started with Redux” video series</a></strong> and <strong><a href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux">Building React Applications with Idiomatic Redux</a></strong> video courses on Egghead.io</li>
<li>Redux maintainer Mark Erikson’s <strong><a href="https://blog.isquaredsoftware.com/2018/03/presentation-reactathon-redux-fundamentals/">“Redux Fundamentals” conference talk</a></strong> and <a href="https://blog.isquaredsoftware.com/2018/06/redux-fundamentals-workshop-slides/"><strong>“Redux Fundamentals” workshop slides</strong></a></li>
<li>Dave Ceddia’s post <a href="https://daveceddia.com/redux-tutorial/"><strong>A Complete React Redux Tutorial for Beginners</strong></a></li>
</ul>
<h3 id="other-resources">Other Resources</h3>
<ul>
<li>The <strong><a href="../FAQ.md">Redux FAQ</a></strong> answers many common questions about how to use Redux, and the <strong><a href="../usage/index.md">“Using Redux” docs section</a></strong> has information on handling derived data, testing, structuring reducer logic, and reducing boilerplate.</li>
<li>Redux maintainer Mark Erikson’s <strong><a href="https://blog.isquaredsoftware.com/series/practical-redux/">“Practical Redux” tutorial series</a></strong> demonstrates real-world intermediate and advanced techniques for working with React and Redux (also available as <strong><a href="https://www.educative.io/collection/5687753853370368/5707702298738688">an interactive course on Educative.io</a></strong>).</li>
<li>The <strong><a href="https://github.com/markerikson/react-redux-links">React/Redux links list</a></strong> has categorized articles on working with <a href="https://github.com/markerikson/react-redux-links/blob/master/redux-reducers-selectors.md">reducers and selectors</a>, <a href="https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md">managing side effects</a>, <a href="https://github.com/markerikson/react-redux-links/blob/master/redux-architecture.md">Redux architecture and best practices</a>, and more.</li>
<li>Our community has created thousands of Redux-related libraries, addons, and tools. The <strong><a href="./Ecosystem.md">“Ecosystem” docs page</a></strong> lists our recommendations, and there’s a complete listing available in the <strong><a href="https://github.com/markerikson/redux-ecosystem-links">Redux addons catalog</a></strong>.</li>
</ul>
<h2 id="help-and-discussion">Help and Discussion</h2>
<p>The <strong><a href="https://discord.gg/0ZcbPKXt5bZ6au5t">#redux channel</a></strong> of the <strong><a href="https://www.reactiflux.com">Reactiflux Discord community</a></strong> is our official resource for all questions related to learning and using Redux. Reactiflux is a great place to hang out, ask questions, and learn - come join us!</p>
<p>You can also ask questions on <a href="https://stackoverflow.com">Stack Overflow</a> using the <strong><a href="https://stackoverflow.com/questions/tagged/redux">#redux tag</a></strong>.</p>
<p>If you have a bug report or need to leave other feedback, <a href="https://github.com/reduxjs/redux">please file an issue on the Github repo</a></p>
<h2 id="should-you-use-redux">Should You Use Redux?</h2>
<p>Redux is a valuable tool for organizing your state, but you should also consider whether it’s appropriate for your situation. <strong>Don’t use Redux just because someone said you should - take some time to understand the potential benefits and tradeoffs of using it</strong>.</p>
<p>Here are some suggestions on when it makes sense to use Redux:</p>
<ul>
<li>You have reasonable amounts of data changing over time</li>
<li>You need a single source of truth for your state</li>
<li>You find that keeping all your state in a top-level component is no longer sufficient</li>
</ul>
<blockquote>
<p><strong>For more thoughts on how Redux is meant to be used, see:</strong></p>
<ul>
<li><strong><a href="../faq/General.md#when-should-i-use-redux">Redux FAQ: When should I use Redux?</a></strong></li>
<li><p><strong><a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">You Might Not Need Redux</a></strong></p></li>
<li><p><strong><a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/">The Tao of Redux, Part 1 - Implementation and Intent</a></strong></p></li>
<li><strong><a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/">The Tao of Redux, Part 2 - Practice and Philosophy</a></strong></li>
<li><p><strong><a href="../FAQ.md">Redux FAQ</a></strong></p></li>
</ul>
</blockquote>
<hr />
<p>id: installation title: Installation description: ‘Introduction &gt; Installation: Installation instructions for Redux and related packages’</p>
<hr />
<h1 id="installation-1">Installation</h1>
<h2 id="redux-toolkit-1">Redux Toolkit</h2>
<p>Redux Toolkit includes the Redux core, as well as other key packages we feel are essential for building Redux applications (such as Redux Thunk and Reselect).</p>
<p>It’s available as a package on NPM for use with a module bundler or in a Node application:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb53-1" title="1"><span class="co"># NPM</span></a>
<a class="sourceLine" id="cb53-2" title="2"><span class="ex">npm</span> install @reduxjs/toolkit</a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="co"># Yarn</span></a>
<a class="sourceLine" id="cb53-5" title="5"><span class="ex">yarn</span> add @reduxjs/toolkit</a></code></pre></div>
<p>It’s also available as a UMD build, which can be loaded from <a href="https://unpkg.com/@reduxjs/toolkit/dist/">the <code>dist</code> folder on unpkg</a>. The UMD builds make Redux Toolkit available as a <code>window.RTK</code> global variable.</p>
<h2 id="redux-core-1">Redux Core</h2>
<p>To install the stable version:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb54-1" title="1"><span class="co"># NPM</span></a>
<a class="sourceLine" id="cb54-2" title="2"><span class="ex">npm</span> install redux</a>
<a class="sourceLine" id="cb54-3" title="3"></a>
<a class="sourceLine" id="cb54-4" title="4"><span class="co"># Yarn</span></a>
<a class="sourceLine" id="cb54-5" title="5"><span class="ex">yarn</span> add redux</a></code></pre></div>
<p>If you’re not, you can <a href="https://unpkg.com/redux/">access these files on unpkg</a>, download them, or point your package manager to them.</p>
<p>Most commonly, people consume Redux as a collection of <a href="http://www.commonjs.org/">CommonJS</a> modules. These modules are what you get when you import <code>redux</code> in a <a href="https://webpack.js.org/">Webpack</a>, <a href="http://browserify.org/">Browserify</a>, or a Node environment. If you like to live on the edge and use <a href="https://rollupjs.org">Rollup</a>, we support that as well.</p>
<p>If you don’t use a module bundler, it’s also fine. The <code>redux</code> npm package includes precompiled production and development <a href="https://github.com/umdjs/umd">UMD</a> builds in the <a href="https://unpkg.com/redux/dist/"><code>dist</code> folder</a>. They can be used directly without a bundler and are thus compatible with many popular JavaScript module loaders and environments. For example, you can drop a UMD build as a <a href="https://unpkg.com/redux/dist/redux.js"><code>&lt;script&gt;</code> tag</a> on the page, or <a href="https://github.com/reduxjs/redux/pull/1181#issuecomment-167361975">tell Bower to install it</a>. The UMD builds make Redux available as a <code>window.Redux</code> global variable.</p>
<p>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in <a href="https://caniuse.com/#feat=es5">any modern browser</a>. You don’t need to use Babel or a module bundler to <a href="https://redux.js.org/introduction/examples#counter-vanilla">get started with Redux</a>.</p>
<h2 id="complementary-packages">Complementary Packages</h2>
<p>Most likely, you’ll also need <a href="https://github.com/reduxjs/react-redux">the React bindings</a> and <a href="https://github.com/reduxjs/redux-devtools">the developer tools</a>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb55-1" title="1"><span class="ex">npm</span> install react-redux</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="ex">npm</span> install --save-dev redux-devtools</a></code></pre></div>
<p>Note that unlike Redux itself, many packages in the Redux ecosystem don’t provide UMD builds, so we recommend using CommonJS module bundlers like <a href="https://webpack.js.org/">Webpack</a> and <a href="http://browserify.org/">Browserify</a> for the most comfortable development experience.</p>
<h2 id="create-a-react-redux-app-1">Create a React Redux App</h2>
<p>The recommended way to start new apps with React and Redux is by using the <a href="https://github.com/reduxjs/cra-template-redux">official Redux+JS template</a> or <a href="https://github.com/reduxjs/cra-template-redux-typescript">Redux+TS template</a> for <a href="https://github.com/facebook/create-react-app">Create React App</a>, which takes advantage of <strong><a href="https://redux-toolkit.js.org/">Redux Toolkit</a></strong> and React Redux’s integration with React components.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb56-1" title="1"><span class="co"># Redux + Plain JS template</span></a>
<a class="sourceLine" id="cb56-2" title="2"><span class="ex">npx</span> create-react-app my-app --template redux</a>
<a class="sourceLine" id="cb56-3" title="3"></a>
<a class="sourceLine" id="cb56-4" title="4"><span class="co"># Redux + TypeScript template</span></a>
<a class="sourceLine" id="cb56-5" title="5"><span class="ex">npx</span> create-react-app my-app --template redux-typescript</a></code></pre></div>
<hr />
<p>id: learning-resources title: Learning Resources description: ‘Introduction &gt; Learning Resources: Additional articles and resources for learning Redux’</p>
<hr />
<h1 id="learning-resources">Learning Resources</h1>
<p>The Redux docs are intended to teach the basic concepts of Redux, as well as explain key concepts for use in real-world applications. However, the docs can’t cover everything. Happily, there are many other great resources available for learning Redux. We encourage you to check them out. Many of them cover topics that are beyond the scope of the docs, or describe the same topics in other ways that may work better for your learning style.</p>
<p>This page includes our recommendations for some of the best external resources available to learn Redux. For an additional extensive list of tutorials, articles, and other resources on React, Redux, Javascript, and related topics, see the <a href="https://github.com/markerikson/react-redux-links">React/Redux Links list</a>.</p>
<h2 id="basic-introductions">Basic Introductions</h2>
<p><em>Tutorials that teach the basic concepts of Redux and how to use it</em></p>
<ul>
<li><p><strong>Intro to React, Redux, and Typescript</strong> <br /> <a href="https://blog.isquaredsoftware.com/2020/12/presentations-react-redux-ts-intro/" class="uri">https://blog.isquaredsoftware.com/2020/12/presentations-react-redux-ts-intro/</a> <br /> Redux maintainer Mark Erikson’s slideset that covers the basics of React, Redux, and TypeScript. Redux topics include stores, reducers, middleware, React-Redux, and Redux Toolkit.</p></li>
<li><p><strong>Learn Modern Redux - Redux Toolkit, React-Redux Hooks, and RTK Query</strong> <br /> <a href="https://www.learnwithjason.dev/let-s-learn-modern-redux" class="uri">https://www.learnwithjason.dev/let-s-learn-modern-redux</a> <br /> An episode of the “Learn with Jason” show, with Redux maintainer Mark Erikson as guest. The episode features a live-coded app, and shows how to create a new React+TS project, add the Redux packages, and set up Redux Toolkit and React-Redux from scratch (including our recommended TS hooks configuration). It also shows how to use the upcoming RTK Query data fetching API and display that data in a UI.</p></li>
<li><p><strong>Redux Tutorial: An Overview and Walkthrough</strong> <br /> <a href="https://www.taniarascia.com/redux-react-guide/" class="uri">https://www.taniarascia.com/redux-react-guide/</a> <br /> A well-written tutorial from Tania Rascia that quickly explains key Redux concepts, and shows how to put together a basic Redux + React app using vanilla Redux and Redux Toolkit.</p></li>
<li><p><strong>Redux for Beginners - The Brain-Friendly Guide to Learning Redux</strong> <br /> <a href="https://www.freecodecamp.org/news/redux-for-beginners-the-brain-friendly-guide-to-redux/" class="uri">https://www.freecodecamp.org/news/redux-for-beginners-the-brain-friendly-guide-to-redux/</a> <br /> An easy-to-follow tutorial that builds a small todo app with Redux Toolkit and React-Redux, including data fetching.</p></li>
<li><p><strong>Redux made easy with Redux Toolkit and Typescript</strong> <br /> <a href="https://www.mattbutton.com/redux-made-easy-with-redux-toolkit-and-typescript/" class="uri">https://www.mattbutton.com/redux-made-easy-with-redux-toolkit-and-typescript/</a> <br /> A helpful tutorial that shows how to use Redux Toolkit and TypeScript together to write Redux applications, and how RTK simplifies typical Redux usage.</p></li>
<li><p><strong>Redux: From Twitter Hype to Production</strong> <br/> <a href="https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/" class="uri">https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/</a> <br/> A well-produced slideshow that visually steps through core Redux concepts, usage with React, project organization, and side effects with thunks and sagas. Has some good animated diagrams demonstrating how data flows through a React+Redux architecture.</p></li>
</ul>
<h2 id="using-redux-with-react">Using Redux With React</h2>
<p><em>Explanations of the React-Redux bindings library</em></p>
<ul>
<li><p><strong>Modernizing a Legacy Redux Application with React-Redux Hooks</strong> <br /> <a href="https://app.egghead.io/playlists/modernizing-a-legacy-redux-application-with-react-hooks-c528" class="uri">https://app.egghead.io/playlists/modernizing-a-legacy-redux-application-with-react-hooks-c528</a> <br /> A video series that shows the differences between the earlier <code>connect</code> API and the newer React-Redux hooks API, and how to use those hooks in your components.</p></li>
<li><p><strong>Why Redux is Useful in React Apps</strong> <br/> <a href="https://www.fullstackreact.com/articles/redux-with-mark-erikson/" class="uri">https://www.fullstackreact.com/articles/redux-with-mark-erikson/</a> <br/> An explanation of some of the benefits of using Redux with React, including sharing data between components and hot module reloading.</p></li>
</ul>
<h2 id="project-based-tutorials">Project-Based Tutorials</h2>
<p><em>Tutorials that teach Redux concepts by building projects, including larger “real-world”-type applications</em></p>
<ul>
<li><strong>Practical Redux</strong> <br/> <a href="https://blog.isquaredsoftware.com/2016/10/practical-redux-part-0-introduction/" class="uri">https://blog.isquaredsoftware.com/2016/10/practical-redux-part-0-introduction/</a> <br/> <a href="https://blog.isquaredsoftware.com/series/practical-redux/" class="uri">https://blog.isquaredsoftware.com/series/practical-redux/</a> <br/> An ongoing series of posts intended to demonstrate a number of specific Redux techniques by building a sample application, based on the MekHQ application for managing Battletech campaigns. Written by Redux co-maintainer Mark Erikson. Covers topics like managing relational data, connecting multiple components and lists, complex reducer logic for features, handling forms, showing modal dialogs, and much more. (Note: this is an older series, and today we recommend newer patterns for writing Redux code. However, many of the principles in this series are still valuable.)</li>
</ul>
<h2 id="redux-implementation">Redux Implementation</h2>
<p><em>Explanations of how Redux works internally, by writing miniature reimplementations</em></p>
<ul>
<li><p><strong>Getting Started with Redux - Video Series</strong> <br/> <a href="https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867" class="uri">https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867</a> <br/> <a href="https://github.com/tayiorbeii/egghead.io_redux_course_notes" class="uri">https://github.com/tayiorbeii/egghead.io_redux_course_notes</a> <br/> Dan Abramov, the creator of Redux, demonstrates various concepts in 30 short (2-5 minute) videos. The linked Github repo contains notes and transcriptions of the videos.</p></li>
<li><p><strong>Building React Applications with Idiomatic Redux - Video Series</strong> <br/> <a href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux" class="uri">https://egghead.io/courses/building-react-applications-with-idiomatic-redux</a> <br/> <a href="https://github.com/tayiorbeii/egghead.io_idiomatic_redux_course_notes" class="uri">https://github.com/tayiorbeii/egghead.io_idiomatic_redux_course_notes</a> <br/> Dan Abramov’s second video tutorial series, continuing directly after the first. Includes lessons on store initial state, using Redux with React Router, using “selector” functions, normalizing state, use of Redux middleware, async action creators, and more. The linked Github repo contains notes and transcriptions of the videos.</p></li>
<li><p><strong>Live React: Hot Reloading and Time Travel</strong> <br/> <a href="https://youtube.com/watch?v=xsSnOQynTHs" class="uri">https://youtube.com/watch?v=xsSnOQynTHs</a> <br/> Dan Abramov’s original conference talk that introduced Redux. See how constraints enforced by Redux make hot reloading with time travel easy</p></li>
<li><p><strong>Build Yourself a Redux</strong> <br/> <a href="https://zapier.com/engineering/how-to-build-redux/" class="uri">https://zapier.com/engineering/how-to-build-redux/</a> <br/> An excellent in-depth “build a mini-Redux” article, which covers not only Redux’s core, but also <code>connect</code> and middleware as well.</p></li>
<li><p><strong>Connect.js explained</strong> <br/> <a href="https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e" class="uri">https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e</a> <br/> A very simplified version of React Redux’s <code>connect()</code> function that illustrates the basic implementation</p></li>
<li><p><strong>Let’s Write Redux!</strong> <br/> <a href="https://www.jamasoftware.com/blog/lets-write-redux/" class="uri">https://www.jamasoftware.com/blog/lets-write-redux/</a> <br/> Walks through writing a miniature version of Redux step-by-step, to help explain the concepts and implementation.</p></li>
</ul>
<h2 id="reducers-1">Reducers</h2>
<p><em>Articles discussing ways to write reducer functions</em></p>
<ul>
<li><p><strong>Taking Advantage of <code>combineReducers</code></strong> <br/> <a href="https://randycoulman.com/blog/2016/11/22/taking-advantage-of-combinereducers/" class="uri">https://randycoulman.com/blog/2016/11/22/taking-advantage-of-combinereducers/</a> <br/> Examples of using <code>combineReducers</code> multiple times to produce a state tree, and some thoughts on tradeoffs in various approaches to reducer logic.</p></li>
<li><p><strong>The Power of Higher-Order Reducers</strong> <br/> <a href="https://slides.com/omnidan/hor#/" class="uri">https://slides.com/omnidan/hor#/</a> <br/> A slideshow from the author of redux-undo and other libraries, explaining the concept of higher-order reducers and how they can be used</p></li>
<li><p><strong>Reducer composition with Higher Order Reducers</strong> <br/> <a href="https://medium.com/@mange_vibration/reducer-composition-with-higher-order-reducers-35c3977ed08f" class="uri">https://medium.com/@mange_vibration/reducer-composition-with-higher-order-reducers-35c3977ed08f</a> <br/> Some great examples of writing small functions that can be composed together to perform larger specific reducer tasks, such as providing initial state, filtering, updating specific keys, and more.</p></li>
<li><p><strong>Higher Order Reducers - It just sounds scary</strong> <br/> <a href="https://medium.com/@danielkagan/high-order-reducers-it-just-sounds-scary-2b9e5dbfc705" class="uri">https://medium.com/@danielkagan/high-order-reducers-it-just-sounds-scary-2b9e5dbfc705</a> <br/> Explains how reducers can be composed like Lego bricks to create reusable and testable reducer logic.</p></li>
</ul>
<h2 id="selectors">Selectors</h2>
<p><em>Explanations of how and why to use selector functions to read values from state</em></p>
<ul>
<li><p><strong>Idiomatic Redux: Using Reselect Selectors for Encapsulation and Performance</strong> <br/> <a href="https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/" class="uri">https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/</a> <br/> A complete guide to why you should use selector functions with Redux, how to use the Reselect library to write optimized selectors, and advanced tips for improving performance.</p></li>
<li><p><strong>ReactCasts #8: Selectors in Redux</strong> <br/> <a href="https://www.youtube.com/watch?v=frT3to2ACCw" class="uri">https://www.youtube.com/watch?v=frT3to2ACCw</a> <br/> A great overview of why and how to use selector functions to retrieve data from the store, and derive additional data from store values</p></li>
<li><p><strong>Optimizing React Redux Application Development with Reselect</strong> <br/> <a href="https://codebrahma.com/reselect-tutorial-optimizing-react-redux-application-development-with-reselect/" class="uri">https://codebrahma.com/reselect-tutorial-optimizing-react-redux-application-development-with-reselect/</a> <br/> A good tutorial on Reselect. Covers the concept of “selector functions”, how to use Reselect’s API, and how to use memoized selectors to improve performance.</p></li>
<li><p><strong>Usage of Reselect in a React-Redux Application</strong> <br/> <a href="https://dashbouquet.com/blog/frontend-development/usage-of-reselect-in-a-react-redux-application" class="uri">https://dashbouquet.com/blog/frontend-development/usage-of-reselect-in-a-react-redux-application</a> <br/> Discusses the importance of memoized selectors for performance, and good practices for using Reselect.</p></li>
<li><p><strong>React, Reselect, and Redux</strong> <br/> <a href="https://medium.com/@parkerdan/react-reselect-and-redux-b34017f8194c" class="uri">https://medium.com/@parkerdan/react-reselect-and-redux-b34017f8194c</a> <br/> An explanation of how Reselect’s memoized selector functions are useful in Redux apps, and how to create unique selector instances for each component instance.</p></li>
</ul>
<h2 id="normalization">Normalization</h2>
<p><em>How to structure the Redux store like a database for best performance</em></p>
<ul>
<li><p><strong>Querying a Redux Store</strong> <br/> <a href="https://medium.com/@adamrackis/querying-a-redux-store-37db8c7f3b0f" class="uri">https://medium.com/@adamrackis/querying-a-redux-store-37db8c7f3b0f</a> <br/> A look at best practices for organizing and storing data in Redux, including normalizing data and use of selector functions.</p></li>
<li><p><strong>Normalizing Redux Stores for Maximum Code Reuse</strong> <br/> <a href="https://medium.com/@adamrackis/normalizing-redux-stores-for-maximum-code-reuse-ae6e3844ae95" class="uri">https://medium.com/@adamrackis/normalizing-redux-stores-for-maximum-code-reuse-ae6e3844ae95</a> <br/> Thoughts on how normalized Redux stores enable some useful data handling approaches, with examples of using selector functions to denormalize hierarchical data.</p></li>
<li><p><strong>Advanced Redux Entity Normalization</strong> <br/> <a href="https://medium.com/@dcousineau/advanced-redux-entity-normalization-f5f1fe2aefc5" class="uri">https://medium.com/@dcousineau/advanced-redux-entity-normalization-f5f1fe2aefc5</a> <br/> Describes a “keyWindow” concept for tracking subsets of entities in state, similar to an SQL “view”. A useful extension to the idea of normalized data.</p></li>
</ul>
<h2 id="middleware-1">Middleware</h2>
<p><em>Explanations and examples of how middleware work and how to write them</em></p>
<ul>
<li><p><strong>Exploring Redux Middlewares</strong> <br/> <a href="https://blog.krawaller.se/posts/exploring-redux-middleware/" class="uri">https://blog.krawaller.se/posts/exploring-redux-middleware/</a> <br/> Understanding middlewares through a series of small experiments</p></li>
<li><p><strong>Redux Middleware Tutorial</strong> <br/> <a href="https://www.pshrmn.com/tutorials/react/redux-middleware/" class="uri">https://www.pshrmn.com/tutorials/react/redux-middleware/</a> <br/> An overview of what middleware is, how <code>applyMiddleware</code> works, and how to write middleware.</p></li>
<li><p><strong>ReactCasts #6: Redux Middleware</strong> <br/> <a href="https://www.youtube.com/watch?v=T-qtHI1qHIg" class="uri">https://www.youtube.com/watch?v=T-qtHI1qHIg</a> <br/> A screencast that describes how middleware fit into Redux, their uses, and how to implement a custom middleware</p></li>
<li><p><strong>A Beginner’s Guide to Redux Middleware</strong> <br/> <a href="https://www.codementor.io/reactjs/tutorial/beginner-s-guide-to-redux-middleware" class="uri">https://www.codementor.io/reactjs/tutorial/beginner-s-guide-to-redux-middleware</a> <br/> A useful explanation of middleware use cases, with numerous examples</p></li>
<li><p><strong>Functional Composition in Javascript</strong> <br/> <a href="https://joecortopassi.com/articles/functional-composition-in-javascript/" class="uri">https://joecortopassi.com/articles/functional-composition-in-javascript/</a> <br/> Breaking down how the <code>compose</code> function works</p></li>
</ul>
<h2 id="side-effects---basics">Side Effects - Basics</h2>
<p><em>Introductions to handling async behavior in Redux</em></p>
<ul>
<li><p><strong>Stack Overflow: Dispatching Redux Actions with a Timeout</strong> <br/> <a href="https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559" class="uri">https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559</a> <br/> Dan Abramov explains the basics of managing async behavior in Redux, walking through a progressive series of approaches (inline async calls, async action creators, thunk middleware).</p></li>
<li><p><strong>Stack Overflow: Why do we need middleware for async flow in Redux?</strong> <br/> <a href="https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594" class="uri">https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594</a> <br/> Dan Abramov gives reasons for using thunks and async middleware, and some useful patterns for using thunks.</p></li>
<li><p><strong>What the heck is a “thunk”?</strong> <br/> <a href="https://daveceddia.com/what-is-a-thunk/" class="uri">https://daveceddia.com/what-is-a-thunk/</a> <br/> A quick explanation for what the word “thunk” means in general, and for Redux specifically.</p></li>
<li><p><strong>Thunks in Redux: The Basics</strong> <br/> <a href="https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60" class="uri">https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60</a> <br/> A detailed look at what thunks are, what they solve, and how to use them.</p></li>
</ul>
<h2 id="side-effects---advanced">Side Effects - Advanced</h2>
<p><em>Advanced tools and techniques for managing async behavior</em></p>
<ul>
<li><p><strong>What is the right way to do asynchronous operations in Redux?</strong> <br/> <a href="https://decembersoft.com/posts/what-is-the-right-way-to-do-asynchronous-operations-in-redux/" class="uri">https://decembersoft.com/posts/what-is-the-right-way-to-do-asynchronous-operations-in-redux/</a> <br/> An excellent look at the most popular libraries for Redux side effects, with comparisons of how each one works.</p></li>
<li><p><strong>Redux 4 Ways</strong> <br/> <a href="https://medium.com/react-native-training/redux-4-ways-95a130da0cdc" class="uri">https://medium.com/react-native-training/redux-4-ways-95a130da0cdc</a> <br/> Side-by-side comparisons of implementing some basic data fetching using thunks, sagas, observables, and a promise middleware</p></li>
<li><p><strong>Idiomatic Redux: Thoughts on Thunks, Sagas, Abstractions, and Reusability</strong> <br/> <a href="https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/" class="uri">https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/</a> <br/> A response to several “thunks are bad” concerns, arguing that thunks (and sagas) are still a valid approach for managing complex sync logic and async side effects.</p></li>
<li><p><strong>Javascript Power Tools: Redux-Saga</strong> <br/> <a href="https://formidable.com/blog/2017/javascript-power-tools-redux-saga/" class="uri">https://formidable.com/blog/2017/javascript-power-tools-redux-saga/</a> <br/> <a href="https://formidable.com/blog/2017/composition-patterns-in-redux-saga/" class="uri">https://formidable.com/blog/2017/composition-patterns-in-redux-saga/</a> <br/> <a href="https://formidable.com/blog/2017/real-world-redux-saga-patterns/" class="uri">https://formidable.com/blog/2017/real-world-redux-saga-patterns/</a> <br/> A fantastic series that teaches the concepts, implementation, and benefits behind Redux-Saga, including how ES6 generators are used to control function flow, how sagas can be composed together to accomplish concurrency, and practical use cases for sagas.</p></li>
<li><p><strong>Exploring Redux Sagas</strong> <br/> <a href="https://medium.com/onfido-tech/exploring-redux-sagas-cc1fca2015ee" class="uri">https://medium.com/onfido-tech/exploring-redux-sagas-cc1fca2015ee</a> <br/> An excellent article that explores how to use sagas to provide a glue layer to implement decoupled business logic in a Redux application.</p></li>
<li><p><strong>Taming Redux with Sagas</strong> <br/> <a href="https://objectpartners.com/2017/11/20/taming-redux-with-sagas/" class="uri">https://objectpartners.com/2017/11/20/taming-redux-with-sagas/</a> <br/> A good overview of Redux-Saga, including info on generator functions, use cases for sagas, using sagas to deal with promises, and testing sagas.</p></li>
<li><p><strong>Reactive Redux State with RxJS</strong> <br/> <a href="https://ivanjov.com/reactive-redux-state-with-rxjs/" class="uri">https://ivanjov.com/reactive-redux-state-with-rxjs/</a> <br/> Describes the concept of “Reactive Programming” and the RxJS library, and shows how to use redux-observable to fetch data, along with examples of testing.</p></li>
<li><p><strong>Using redux-observable to handle asynchronous logic in Redux</strong> <br/> <a href="https://medium.com/dailyjs/using-redux-observable-to-handle-asynchronous-logic-in-redux-d49194742522" class="uri">https://medium.com/dailyjs/using-redux-observable-to-handle-asynchronous-logic-in-redux-d49194742522</a> <br/> An extended post that compares a thunk-based implementation of handling a line-drawing example vs an observable-based implementation.</p></li>
</ul>
<h2 id="thinking-in-redux">Thinking in Redux</h2>
<p><em>Deeper looks at how Redux is meant to be used, and why it works the way it does</em></p>
<ul>
<li><p><strong>When (and when not) to reach for Redux</strong> <br /> <a href="https://changelog.com/posts/when-and-when-not-to-reach-for-redux" class="uri">https://changelog.com/posts/when-and-when-not-to-reach-for-redux</a> <br /> Redux maintainer Mark Erikson describes the problems Redux was created to solve, and how it compares to other commonly used tools.</p></li>
<li><p><strong>You Might Not Need Redux</strong> <br/> <a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" class="uri">https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367</a> <br/> Dan Abramov discusses the tradeoffs involved in using Redux.</p></li>
<li><p><strong>Idiomatic Redux: The Tao of Redux, Part 1 - Implementation and Intent</strong> <br/> <a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/" class="uri">https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/</a> <br/> A deep dive into how Redux actually works, the constraints it asks you to follow, and the intent behind its design and usage.</p></li>
<li><p><strong>Idiomatic Redux: The Tao of Redux, Part 2 - Practice and Philosophy</strong> <br/> <a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/" class="uri">https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/</a> <br/> A follow-up look at why common Redux usage patterns exist, other ways that Redux can be used, and thoughts on the pros and cons of those different patterns and approaches.</p></li>
<li><p><strong>What’s So Great About Redux?</strong> <br/> <a href="https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b" class="uri">https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b</a> <br/> Deep and fascinating analysis of how Redux compares to OOP and message-passing, how typical Redux usage can devolve towards Java-like “setter” functions with more boilerplate, and something of a plea for a higher-level “blessed” abstraction on top of Redux to make it easier to work with and learn for newbies. Very worth reading.</p></li>
</ul>
<h2 id="redux-architecture">Redux Architecture</h2>
<p><em>Patterns and practices for structuring larger Redux applications</em></p>
<ul>
<li><p><strong>Avoiding Accidental Complexity When Structuring Your App State</strong> <br/> <a href="https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a" class="uri">https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a</a> <br/> An excellent set of guidelines for organizing your Redux store structure.</p></li>
<li><p><strong>Redux Step by Step: A Simple and Robust Workflow for Real Life Apps</strong> <br/> <a href="https://hackernoon.com/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092" class="uri">https://hackernoon.com/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092</a> <br/> A follow-up to the “Accidental Complexity” article, discussing principle</p></li>
<li><p><strong>Things I Wish I Knew About Redux</strong> <br/> <a href="https://medium.com/horrible-hacks/things-i-wish-i-knew-about-redux-9924abf2f9e0" class="uri">https://medium.com/horrible-hacks/things-i-wish-i-knew-about-redux-9924abf2f9e0</a> <br/> <a href="https://www.reddit.com/r/javascript/comments/4taau2/things_i_wish_i_knew_about_redux/" class="uri">https://www.reddit.com/r/javascript/comments/4taau2/things_i_wish_i_knew_about_redux/</a> <br/> A number of excellent tips and lessons learned after building an app with Redux. Includes info on connecting components, selecting data, and app/project structure. Additional discussion on Reddit.</p></li>
<li><p><strong>React+Redux: Tips and Best Practices for Clean, Reliable, &amp; Maintainable Code</strong> <br/> <a href="https://speakerdeck.com/goopscoop/react-plus-redux-tips-and-best-practices-for-clean-reliable-and-scalable-code" class="uri">https://speakerdeck.com/goopscoop/react-plus-redux-tips-and-best-practices-for-clean-reliable-and-scalable-code</a> <br/> An excellent slideshow with a wide variety of tips and suggestions, including keeping action creators simple and data manipulation in reducers, abstracting away API calls, avoiding spreading props, and more.</p></li>
<li><p><strong>Redux for state management in large web apps</strong> <br/> <a href="https://blog.mapbox.com/redux-for-state-management-in-large-web-apps-c7f3fab3ce9b" class="uri">https://blog.mapbox.com/redux-for-state-management-in-large-web-apps-c7f3fab3ce9b</a> <br/> Excellent discussion and examples of idiomatic Redux architecture, and how Mapbox applies those approaches to their Mapbox Studio application.</p></li>
</ul>
<h2 id="apps-and-examples">Apps and Examples</h2>
<ul>
<li><p><strong>React-Redux RealWorld Example: TodoMVC for the Real World</strong> <br/> <a href="https://github.com/GoThinkster/redux-review" class="uri">https://github.com/GoThinkster/redux-review</a> <br/> An example full-stack “real world” application built with Redux. Demos a Medium-like social blogging site that includes JWT authentication, CRUD, favoriting articles, following users, routing, and more. The RealWorld project also includes many other implementations of the front and back ends of the site, specifically intended to show how different server and client implementations of the same project and API spec compare with each other.</p></li>
<li><p><strong>Project Mini-Mek</strong> <br/> <a href="https://github.com/markerikson/project-minimek" class="uri">https://github.com/markerikson/project-minimek</a> <br/> A sample app to demonstrate various useful Redux techniques, accompanying the “Practical Redux” blog series at <a href="https://blog.isquaredsoftware.com/series/practical-redux" class="uri">https://blog.isquaredsoftware.com/series/practical-redux</a></p></li>
<li><p><strong>react-redux-yelp-clone</strong> <br/> <a href="https://github.com/mohamed-ismat/react-redux-yelp-clone" class="uri">https://github.com/mohamed-ismat/react-redux-yelp-clone</a> <br/> An adaptation of the “Yelp Clone” app by FullStackReact. It extends the original by using Redux and Redux Saga instead of local state, as well as React Router v4, styled-components, and other modern standards. Based on the React-Boilerplate starter kit.</p></li>
<li><p><strong>WordPress-Calypso</strong> <br/> <a href="https://github.com/Automattic/wp-calypso" class="uri">https://github.com/Automattic/wp-calypso</a> <br/> The new JavaScript- and API-powered WordPress.com</p></li>
<li><p><strong>Sound-Redux</strong> <br/> <a href="https://github.com/andrewngu/sound-redux" class="uri">https://github.com/andrewngu/sound-redux</a> <br/> A Soundcloud client built with React / Redux</p></li>
<li><p><strong>Webamp</strong> <br/> <a href="https://webamp.org" class="uri">https://webamp.org</a> <br/> <a href="https://github.com/captbaritone/webamp" class="uri">https://github.com/captbaritone/webamp</a> <br/> An in-browser recreation of Winamp2, built with React and Redux. Actually plays MP3s, and lets you load in local MP3 files.</p></li>
<li><p><strong>Tello</strong> <br/> <a href="https://github.com/joshwcomeau/Tello" class="uri">https://github.com/joshwcomeau/Tello</a> <br/> A simple and delightful way to track and manage TV shows</p></li>
<li><p><strong>io-808</strong> <br/> <a href="https://github.com/vincentriemer/io-808" class="uri">https://github.com/vincentriemer/io-808</a> <br/> An attempt at a fully recreated web-based TR-808 drum machine</p></li>
</ul>
<h2 id="redux-docs-translations">Redux Docs Translations</h2>
<ul>
<li><a href="http://camsong.github.io/redux-in-chinese/">中文文档</a> — Chinese</li>
<li><a href="https://github.com/chentsulin/redux">繁體中文文件</a> — Traditional Chinese</li>
<li><a href="https://github.com/rajdee/redux-in-russian">Redux in Russian</a> — Russian</li>
<li><a href="https://es.redux.js.org/">Redux en Español</a> - Spanish</li>
<li><a href="https://ko.redux.js.org/">Redux in Korean</a> - Korean</li>
</ul>
<h2 id="books">Books</h2>
<ul>
<li><p><strong>Redux in Action</strong> <br/> <a href="https://www.manning.com/books/redux-in-action" class="uri">https://www.manning.com/books/redux-in-action</a> <br/> A comprehensive book that covers many key aspects of using Redux, including the basics of reducers and actions and use with React, complex middlewares and side effects, application structure, performance, testing, and much more. Does a great job of explaining the pros, cons, and tradeoffs of many approaches to using Redux. Personally recommended by Redux co-maintainer Mark Erikson.</p></li>
<li><p><strong>The Complete Redux Book</strong> <br/> <a href="https://leanpub.com/redux-book" class="uri">https://leanpub.com/redux-book</a> <br/> How do I manage a large state in production? Why do I need store enhancers? What is the best way to handle form validations? Get the answers to all these questions and many more using simple terms and sample code. Learn everything you need to use Redux to build complex and production-ready web applications. (Note: now permanently free!)</p></li>
<li><p><strong>Taming the State in React</strong> <br/> <a href="https://www.robinwieruch.de/learn-react-redux-mobx-state-management/" class="uri">https://www.robinwieruch.de/learn-react-redux-mobx-state-management/</a> <br/> If you have learned React with the previous book of the author called The Road to learn React, Taming the State in React will be the perfect blend to learn about basic and advanced state management in React. You will start out with learning only Redux without React. Afterward, the book shows you how to connect Redux to your React application. The advanced chapters will teach you about normalization, naming, selectors and asynchronous actions. In the end, you will set up and build a real world application with React and Redux.</p></li>
</ul>
<h2 id="courses">Courses</h2>
<ul>
<li><p><strong>Modern React with Redux, by Stephen Grider (paid)</strong> <br/> <a href="https://www.udemy.com/react-redux/" class="uri">https://www.udemy.com/react-redux/</a> <br/> Master the fundamentals of React and Redux with this tutorial as you develop apps with React Router, Webpack, and ES6. This course will get you up and running quickly, and teach you the core knowledge you need to deeply understand and build React components and structure applications with Redux.</p></li>
<li><p><strong>Redux, by Tyler McGinnis (paid)</strong> <br/> <a href="https://tylermcginnis.com/courses/redux/" class="uri">https://tylermcginnis.com/courses/redux/</a> <br/> When learning Redux, you need to learn it in the context of an app big enough to see the benefits. That’s why this course is huge. A better name might be <em>“Real World Redux”</em>. If you’re sick of “todo list” Redux tutorials, you’ve come to the right place. In this course we’ll talk all about what makes Redux special for managing state in your application. We’ll build an actual “real world” application so you can see how Redux handles edge cases like optimistic updates and error handling. We’ll also cover many other technologies that work well with Redux, Firebase, and CSS Modules.</p></li>
<li><p><strong>Learn Redux, by Wes Bos (free)</strong> <br/> <a href="https://learnredux.com/" class="uri">https://learnredux.com/</a> <br/> A video course that walks through building ‘Reduxstagram’ — a simple photo app that will simplify the core ideas behind Redux, React Router and React.js</p></li>
</ul>
<h2 id="more-resources">More Resources</h2>
<ul>
<li><a href="https://github.com/markerikson/react-redux-links">React-Redux Links</a> is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES6, and more.</li>
<li><a href="https://github.com/markerikson/redux-ecosystem-links">Redux Ecosystem Links</a> is a categorized collection of Redux-related libraries, addons, and utilities.</li>
<li><a href="https://github.com/xgrommx/awesome-redux">Awesome Redux</a> is an extensive list of Redux-related repositories.</li>
<li><a href="https://dev.to/t/redux">DEV Community</a> is a place to share Redux projects, articles and tutorials as well as start discussions and ask for feedback on Redux-related topics. Developers of all skill-levels are welcome to take part.</li>
</ul>
<h1 id="introduction">Introduction</h1>
<ul>
<li><a href="CoreConcepts.md">Core Concepts</a></li>
<li><a href="LearningResources.md">Learning Resources</a></li>
<li><a href="Ecosystem.md">Ecosystem</a></li>
<li><a href="Examples.md">Examples</a></li>
</ul>
<hr />
<p>id: code-splitting title: Code Splitting</p>
<hr />
<h1 id="code-splitting">Code Splitting</h1>
<p>In large web applications, it is often desirable to split up the app code into multiple JS bundles that can be loaded on-demand. This strategy, called ‘code splitting’, helps to increase performance of your application by reducing the size of the initial JS payload that must be fetched.</p>
<p>To code split with Redux, we want to be able to dynamically add reducers to the store. However, Redux really only has a single root reducer function. This root reducer is normally generated by calling <code>combineReducers()</code> or a similar function when the application is initialized. In order to dynamically add more reducers, we need to call that function again to re-generate the root reducer. Below, we discuss some approaches to solving this problem and reference two libraries that provide this functionality.</p>
<h2 id="basic-principle">Basic Principle</h2>
<h3 id="using-replacereducer">Using <code>replaceReducer</code></h3>
<p>The Redux store exposes a <code>replaceReducer</code> function, which replaces the current active root reducer function with a new root reducer function. Calling it will swap the internal reducer function reference, and dispatch an action to help any newly-added slice reducers initialize themselves:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">const</span> newRootReducer <span class="op">=</span> <span class="at">combineReducers</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb57-2" title="2">  <span class="dt">existingSlice</span><span class="op">:</span> existingSliceReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb57-3" title="3">  <span class="dt">newSlice</span><span class="op">:</span> newSliceReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-5" title="5"></a>
<a class="sourceLine" id="cb57-6" title="6"><span class="va">store</span>.<span class="at">replaceReducer</span>(newRootReducer)<span class="op">;</span></a></code></pre></div>
<h2 id="reducer-injection-approaches">Reducer Injection Approaches</h2>
<h3 id="defining-an-injectreducer-function">Defining an <code>injectReducer</code> function</h3>
<p>We will likely want to call <code>store.replaceReducer()</code> from anywhere in the application. Because of that, it’s helpful to define a reusable <code>injectReducer()</code> function that keeps references to all of the existing slice reducers, and attach that to the store instance.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb58-1" title="1"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb58-2" title="2"></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="co">// Define the Reducers that will always be present in the application</span></a>
<a class="sourceLine" id="cb58-4" title="4"><span class="kw">const</span> staticReducers <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb58-5" title="5">  <span class="dt">users</span><span class="op">:</span> usersReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb58-6" title="6">  <span class="dt">posts</span><span class="op">:</span> postsReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb58-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb58-8" title="8"></a>
<a class="sourceLine" id="cb58-9" title="9"><span class="co">// Configure the store</span></a>
<a class="sourceLine" id="cb58-10" title="10"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="at">configureStore</span>(initialState) <span class="op">{</span></a>
<a class="sourceLine" id="cb58-11" title="11">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(<span class="at">createReducer</span>()<span class="op">,</span> initialState)<span class="op">;</span></a>
<a class="sourceLine" id="cb58-12" title="12"></a>
<a class="sourceLine" id="cb58-13" title="13">  <span class="co">// Add a dictionary to keep track of the registered async reducers</span></a>
<a class="sourceLine" id="cb58-14" title="14">  <span class="va">store</span>.<span class="at">asyncReducers</span> <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb58-15" title="15"></a>
<a class="sourceLine" id="cb58-16" title="16">  <span class="co">// Create an inject reducer function</span></a>
<a class="sourceLine" id="cb58-17" title="17">  <span class="co">// This function adds the async reducer, and creates a new combined reducer</span></a>
<a class="sourceLine" id="cb58-18" title="18">  <span class="va">store</span>.<span class="at">injectReducer</span> <span class="op">=</span> (key<span class="op">,</span> asyncReducer) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb58-19" title="19">    <span class="va">store</span>.<span class="at">asyncReducers</span>[key] <span class="op">=</span> asyncReducer<span class="op">;</span></a>
<a class="sourceLine" id="cb58-20" title="20">    <span class="va">store</span>.<span class="at">replaceReducer</span>(<span class="at">createReducer</span>(<span class="va">store</span>.<span class="at">asyncReducers</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb58-21" title="21">  <span class="op">};</span></a>
<a class="sourceLine" id="cb58-22" title="22"></a>
<a class="sourceLine" id="cb58-23" title="23">  <span class="co">// Return the modified store</span></a>
<a class="sourceLine" id="cb58-24" title="24">  <span class="cf">return</span> store<span class="op">;</span></a>
<a class="sourceLine" id="cb58-25" title="25"><span class="op">}</span></a>
<a class="sourceLine" id="cb58-26" title="26"></a>
<a class="sourceLine" id="cb58-27" title="27"><span class="kw">function</span> <span class="at">createReducer</span>(asyncReducers) <span class="op">{</span></a>
<a class="sourceLine" id="cb58-28" title="28">  <span class="cf">return</span> <span class="at">combineReducers</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb58-29" title="29">    ...<span class="at">staticReducers</span><span class="op">,</span></a>
<a class="sourceLine" id="cb58-30" title="30">    ...<span class="at">asyncReducers</span><span class="op">,</span></a>
<a class="sourceLine" id="cb58-31" title="31">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb58-32" title="32"><span class="op">}</span></a></code></pre></div>
<p>Now, one just needs to call <code>store.injectReducer</code> to add a new reducer to the store.</p>
<h3 id="using-a-reducer-manager">Using a ‘Reducer Manager’</h3>
<p>Another approach is to create a ‘Reducer Manager’ object, which keeps track of all the registered reducers and exposes a <code>reduce()</code> function. Consider the following example:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb59-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">createReducerManager</span>(initialReducers) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-2" title="2">  <span class="co">// Create an object which maps keys to reducers</span></a>
<a class="sourceLine" id="cb59-3" title="3">  <span class="kw">const</span> reducers <span class="op">=</span> <span class="op">{</span> ...<span class="at">initialReducers</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb59-4" title="4"></a>
<a class="sourceLine" id="cb59-5" title="5">  <span class="co">// Create the initial combinedReducer</span></a>
<a class="sourceLine" id="cb59-6" title="6">  <span class="kw">let</span> combinedReducer <span class="op">=</span> <span class="at">combineReducers</span>(reducers)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-7" title="7"></a>
<a class="sourceLine" id="cb59-8" title="8">  <span class="co">// An array which is used to delete state keys when reducers are removed</span></a>
<a class="sourceLine" id="cb59-9" title="9">  <span class="kw">let</span> keysToRemove <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb59-10" title="10"></a>
<a class="sourceLine" id="cb59-11" title="11">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-12" title="12">    <span class="dt">getReducerMap</span><span class="op">:</span> () <span class="kw">=&gt;</span> reducers<span class="op">,</span></a>
<a class="sourceLine" id="cb59-13" title="13"></a>
<a class="sourceLine" id="cb59-14" title="14">    <span class="co">// The root reducer function exposed by this object</span></a>
<a class="sourceLine" id="cb59-15" title="15">    <span class="co">// This will be passed to the store</span></a>
<a class="sourceLine" id="cb59-16" title="16">    <span class="dt">reduce</span><span class="op">:</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-17" title="17">      <span class="co">// If any reducers have been removed, clean up their state first</span></a>
<a class="sourceLine" id="cb59-18" title="18">      <span class="cf">if</span> (<span class="va">keysToRemove</span>.<span class="at">length</span> <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-19" title="19">        state <span class="op">=</span> <span class="op">{</span> ...<span class="at">state</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb59-20" title="20">        <span class="cf">for</span> (<span class="kw">let</span> key <span class="kw">of</span> keysToRemove) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-21" title="21">          <span class="kw">delete</span> state[key]<span class="op">;</span></a>
<a class="sourceLine" id="cb59-22" title="22">        <span class="op">}</span></a>
<a class="sourceLine" id="cb59-23" title="23">        keysToRemove <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb59-24" title="24">      <span class="op">}</span></a>
<a class="sourceLine" id="cb59-25" title="25"></a>
<a class="sourceLine" id="cb59-26" title="26">      <span class="co">// Delegate to the combined reducer</span></a>
<a class="sourceLine" id="cb59-27" title="27">      <span class="cf">return</span> <span class="at">combinedReducer</span>(state<span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-28" title="28">    <span class="op">},</span></a>
<a class="sourceLine" id="cb59-29" title="29"></a>
<a class="sourceLine" id="cb59-30" title="30">    <span class="co">// Adds a new reducer with the specified key</span></a>
<a class="sourceLine" id="cb59-31" title="31">    <span class="dt">add</span><span class="op">:</span> (key<span class="op">,</span> reducer) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-32" title="32">      <span class="cf">if</span> (<span class="op">!</span>key <span class="op">||</span> reducers[key]) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-33" title="33">        <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb59-34" title="34">      <span class="op">}</span></a>
<a class="sourceLine" id="cb59-35" title="35"></a>
<a class="sourceLine" id="cb59-36" title="36">      <span class="co">// Add the reducer to the reducer mapping</span></a>
<a class="sourceLine" id="cb59-37" title="37">      reducers[key] <span class="op">=</span> reducer<span class="op">;</span></a>
<a class="sourceLine" id="cb59-38" title="38"></a>
<a class="sourceLine" id="cb59-39" title="39">      <span class="co">// Generate a new combined reducer</span></a>
<a class="sourceLine" id="cb59-40" title="40">      combinedReducer <span class="op">=</span> <span class="at">combineReducers</span>(reducers)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-41" title="41">    <span class="op">},</span></a>
<a class="sourceLine" id="cb59-42" title="42"></a>
<a class="sourceLine" id="cb59-43" title="43">    <span class="co">// Removes a reducer with the specified key</span></a>
<a class="sourceLine" id="cb59-44" title="44">    <span class="dt">remove</span><span class="op">:</span> (key) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-45" title="45">      <span class="cf">if</span> (<span class="op">!</span>key <span class="op">||</span> <span class="op">!</span>reducers[key]) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-46" title="46">        <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb59-47" title="47">      <span class="op">}</span></a>
<a class="sourceLine" id="cb59-48" title="48"></a>
<a class="sourceLine" id="cb59-49" title="49">      <span class="co">// Remove it from the reducer mapping</span></a>
<a class="sourceLine" id="cb59-50" title="50">      <span class="kw">delete</span> reducers[key]<span class="op">;</span></a>
<a class="sourceLine" id="cb59-51" title="51"></a>
<a class="sourceLine" id="cb59-52" title="52">      <span class="co">// Add the key to the list of keys to clean up</span></a>
<a class="sourceLine" id="cb59-53" title="53">      <span class="va">keysToRemove</span>.<span class="at">push</span>(key)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-54" title="54"></a>
<a class="sourceLine" id="cb59-55" title="55">      <span class="co">// Generate a new combined reducer</span></a>
<a class="sourceLine" id="cb59-56" title="56">      combinedReducer <span class="op">=</span> <span class="at">combineReducers</span>(reducers)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-57" title="57">    <span class="op">},</span></a>
<a class="sourceLine" id="cb59-58" title="58">  <span class="op">};</span></a>
<a class="sourceLine" id="cb59-59" title="59"><span class="op">}</span></a>
<a class="sourceLine" id="cb59-60" title="60"></a>
<a class="sourceLine" id="cb59-61" title="61"><span class="kw">const</span> staticReducers <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-62" title="62">  <span class="dt">users</span><span class="op">:</span> usersReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb59-63" title="63">  <span class="dt">posts</span><span class="op">:</span> postsReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb59-64" title="64"><span class="op">};</span></a>
<a class="sourceLine" id="cb59-65" title="65"></a>
<a class="sourceLine" id="cb59-66" title="66"><span class="im">export</span> <span class="kw">function</span> <span class="at">configureStore</span>(initialState) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-67" title="67">  <span class="kw">const</span> reducerManager <span class="op">=</span> <span class="at">createReducerManager</span>(staticReducers)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-68" title="68"></a>
<a class="sourceLine" id="cb59-69" title="69">  <span class="co">// Create a store with the root reducer function being the one exposed by the manager.</span></a>
<a class="sourceLine" id="cb59-70" title="70">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(<span class="va">reducerManager</span>.<span class="at">reduce</span><span class="op">,</span> initialState)<span class="op">;</span></a>
<a class="sourceLine" id="cb59-71" title="71"></a>
<a class="sourceLine" id="cb59-72" title="72">  <span class="co">// Optional: Put the reducer manager on the store so it is easily accessible</span></a>
<a class="sourceLine" id="cb59-73" title="73">  <span class="va">store</span>.<span class="at">reducerManager</span> <span class="op">=</span> reducerManager<span class="op">;</span></a>
<a class="sourceLine" id="cb59-74" title="74"><span class="op">}</span></a></code></pre></div>
<p>To add a new reducer, one can now call <code>store.reducerManager.add("asyncState", asyncReducer)</code>.</p>
<p>To remove a reducer, one can now call <code>store.reducerManager.remove("asyncState")</code></p>
<h2 id="libraries-and-frameworks">Libraries and Frameworks</h2>
<p>There are a few good libraries out there that can help you add the above functionality automatically:</p>
<ul>
<li><a href="https://github.com/Microsoft/redux-dynamic-modules"><code>redux-dynamic-modules</code></a>: This library introduces the concept of a ‘Redux Module’, which is a bundle of Redux artifacts (reducers, middleware) that should be dynamically loaded. It also exposes a React higher-order component to load ‘modules’ when areas of the application come online. Additionally, it has integrations with libraries like <code>redux-thunk</code> and <code>redux-saga</code> which also help dynamically load their artifacts (thunks, sagas).</li>
<li><a href="https://github.com/markerikson/redux-ecosystem-links/blob/master/reducers.md#dynamic-reducer-injection">Redux Ecosystem Links: Reducers - Dynamic Reducer Injection</a></li>
</ul>
<hr />
<p>id: configuring-your-store title: Configuring Your Store sidebar_label: Configuring Your Store</p>
<hr />
<h1 id="configuring-your-store">Configuring Your Store</h1>
<p>In the <a href="../tutorials/fundamentals/part-1-overview.md">“Redux Fundamentals” tutorial</a>, we introduced the fundamental Redux concepts by building an example Todo list app. As part of that, we talked about <a href="../tutorials/fundamentals/part-4-store.md">how to create and configure a Redux store</a>.</p>
<p>We will now explore how to customise the store to add extra functionality. We’ll start with the source code from <a href="../tutorials/fundamentals/part-5-ui-and-react.md">“Redux Fundamentals” part 5: UI and React</a>. You can view the source from this stage of the tutorial in <a href="https://github.com/reduxjs/redux-fundamentals-example-app/tree/checkpoint-5-uiAllActions">the example app repository on Github</a>, or <a href="https://codesandbox.io/s/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-5-uiAllActions/">in your browser via CodeSandbox</a>.</p>
<h2 id="creating-the-store">Creating the store</h2>
<p>First, let’s look at the original <code>index.js</code> file in which we created our store:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb60-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb60-2" title="2"><span class="im">import</span> <span class="op">{</span> render <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb60-3" title="3"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb60-4" title="4"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb60-5" title="5"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb60-6" title="6"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./components/App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb60-7" title="7"></a>
<a class="sourceLine" id="cb60-8" title="8"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer)<span class="op">;</span></a>
<a class="sourceLine" id="cb60-9" title="9"></a>
<a class="sourceLine" id="cb60-10" title="10"><span class="at">render</span>(</a>
<a class="sourceLine" id="cb60-11" title="11">  <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb60-12" title="12">    <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb60-13" title="13">  &lt;/Provider<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb60-14" title="14">  <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;root&quot;</span>)</a>
<a class="sourceLine" id="cb60-15" title="15">)<span class="op">;</span></a></code></pre></div>
<p>In this code, we pass our reducers to the Redux <code>createStore</code> function, which returns a <code>store</code> object. We then pass this object to the <code>react-redux</code> <code>Provider</code> component, which is rendered at the top of our component tree.</p>
<p>This ensures that any time we connect to Redux in our app via <code>react-redux</code> <code>connect</code>, the store is available to our components.</p>
<h2 id="extending-redux-functionality">Extending Redux functionality</h2>
<p>Most apps extend the functionality of their Redux store by adding middleware or store enhancers <em>(note: middleware is common, enhancers are less common)</em>. Middleware adds extra functionality to the Redux <code>dispatch</code> function; enhancers add extra functionality to the Redux store.</p>
<p>We will add two middlewares and one enhancer:</p>
<ul>
<li>The <a href="https://github.com/reduxjs/redux-thunk"><code>redux-thunk</code> middleware</a>, which allows simple asynchronous use of dispatch.</li>
<li>A middleware which logs dispatched actions and the resulting new state.</li>
<li>An enhancer which logs the time taken for the reducers to process each action.</li>
</ul>
<h4 id="install-redux-thunk">Install <code>redux-thunk</code></h4>
<div class="sourceCode" id="cb61"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb61-1" title="1"><span class="ex">npm</span> install redux-thunk</a></code></pre></div>
<h4 id="middlewarelogger.js">middleware/logger.js</h4>
<div class="sourceCode" id="cb62"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb62-1" title="1"><span class="kw">const</span> logger <span class="op">=</span> (store) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-2" title="2">  <span class="va">console</span>.<span class="at">group</span>(<span class="va">action</span>.<span class="at">type</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-3" title="3">  <span class="va">console</span>.<span class="at">info</span>(<span class="st">&quot;dispatching&quot;</span><span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-4" title="4">  <span class="kw">let</span> result <span class="op">=</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb62-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;next state&quot;</span><span class="op">,</span> <span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb62-6" title="6">  <span class="va">console</span>.<span class="at">groupEnd</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb62-7" title="7">  <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb62-8" title="8"><span class="op">};</span></a>
<a class="sourceLine" id="cb62-9" title="9"></a>
<a class="sourceLine" id="cb62-10" title="10"><span class="im">export</span> <span class="im">default</span> logger<span class="op">;</span></a></code></pre></div>
<h4 id="enhancersmonitorreducer.js">enhancers/monitorReducer.js</h4>
<div class="sourceCode" id="cb63"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb63-1" title="1"><span class="kw">const</span> round <span class="op">=</span> (number) <span class="kw">=&gt;</span> <span class="va">Math</span>.<span class="at">round</span>(number <span class="op">*</span> <span class="dv">100</span>) / <span class="dv">100</span><span class="op">;</span></a>
<a class="sourceLine" id="cb63-2" title="2"></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="kw">const</span> monitorReducerEnhancer <span class="op">=</span></a>
<a class="sourceLine" id="cb63-4" title="4">  (createStore) <span class="kw">=&gt;</span> (reducer<span class="op">,</span> initialState<span class="op">,</span> enhancer) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-5" title="5">    <span class="kw">const</span> monitoredReducer <span class="op">=</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-6" title="6">      <span class="kw">const</span> start <span class="op">=</span> <span class="va">performance</span>.<span class="at">now</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb63-7" title="7">      <span class="kw">const</span> newState <span class="op">=</span> <span class="at">reducer</span>(state<span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-8" title="8">      <span class="kw">const</span> end <span class="op">=</span> <span class="va">performance</span>.<span class="at">now</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb63-9" title="9">      <span class="kw">const</span> diff <span class="op">=</span> <span class="at">round</span>(end <span class="op">-</span> start)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-10" title="10"></a>
<a class="sourceLine" id="cb63-11" title="11">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;reducer process time:&quot;</span><span class="op">,</span> diff)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-12" title="12"></a>
<a class="sourceLine" id="cb63-13" title="13">      <span class="cf">return</span> newState<span class="op">;</span></a>
<a class="sourceLine" id="cb63-14" title="14">    <span class="op">};</span></a>
<a class="sourceLine" id="cb63-15" title="15"></a>
<a class="sourceLine" id="cb63-16" title="16">    <span class="cf">return</span> <span class="at">createStore</span>(monitoredReducer<span class="op">,</span> initialState<span class="op">,</span> enhancer)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-17" title="17">  <span class="op">};</span></a>
<a class="sourceLine" id="cb63-18" title="18"></a>
<a class="sourceLine" id="cb63-19" title="19"><span class="im">export</span> <span class="im">default</span> monitorReducerEnhancer<span class="op">;</span></a></code></pre></div>
<p>Let’s add these to our existing <code>index.js</code>.</p>
<ul>
<li>First, we need to import <code>redux-thunk</code> plus our <code>loggerMiddleware</code> and <code>monitorReducerEnhancer</code>, plus two extra functions provided by Redux: <code>applyMiddleware</code> and <code>compose</code>.</li>
<li>We then use <code>applyMiddleware</code> to create a store enhancer which will apply our <code>loggerMiddleware</code> and the <code>thunkMiddleware</code> to the store’s dispatch function.</li>
<li><p>Next, we use <code>compose</code> to compose our new <code>middlewareEnhancer</code> and our <code>monitorReducerEnhancer</code> into one function.</p>
<p>This is needed because you can only pass one enhancer into <code>createStore</code>. To use multiple enhancers, you must first compose them into a single larger enhancer, as shown in this example.</p></li>
<li><p>Finally, we pass this new <code>composedEnhancers</code> function into <code>createStore</code> as its third argument. <em>Note: the second argument, which we will ignore, lets you preloaded state into the store.</em></p></li>
</ul>
<div class="sourceCode" id="cb64"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb64-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-2" title="2"><span class="im">import</span> <span class="op">{</span> render <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-3" title="3"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-4" title="4"><span class="im">import</span> <span class="op">{</span> applyMiddleware<span class="op">,</span> createStore<span class="op">,</span> compose <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-5" title="5"><span class="im">import</span> thunkMiddleware <span class="im">from</span> <span class="st">&quot;redux-thunk&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-6" title="6"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-7" title="7"><span class="im">import</span> loggerMiddleware <span class="im">from</span> <span class="st">&quot;./middleware/logger&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-8" title="8"><span class="im">import</span> monitorReducerEnhancer <span class="im">from</span> <span class="st">&quot;./enhancers/monitorReducer&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-9" title="9"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./components/App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb64-10" title="10"></a>
<a class="sourceLine" id="cb64-11" title="11"><span class="kw">const</span> middlewareEnhancer <span class="op">=</span> <span class="at">applyMiddleware</span>(loggerMiddleware<span class="op">,</span> thunkMiddleware)<span class="op">;</span></a>
<a class="sourceLine" id="cb64-12" title="12"><span class="kw">const</span> composedEnhancers <span class="op">=</span> <span class="at">compose</span>(middlewareEnhancer<span class="op">,</span> monitorReducerEnhancer)<span class="op">;</span></a>
<a class="sourceLine" id="cb64-13" title="13"></a>
<a class="sourceLine" id="cb64-14" title="14"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> <span class="kw">undefined</span><span class="op">,</span> composedEnhancers)<span class="op">;</span></a>
<a class="sourceLine" id="cb64-15" title="15"></a>
<a class="sourceLine" id="cb64-16" title="16"><span class="at">render</span>(</a>
<a class="sourceLine" id="cb64-17" title="17">  <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb64-18" title="18">    <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb64-19" title="19">  &lt;/Provider<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb64-20" title="20">  <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;root&quot;</span>)</a>
<a class="sourceLine" id="cb64-21" title="21">)<span class="op">;</span></a></code></pre></div>
<h2 id="problems-with-this-approach">Problems with this approach</h2>
<p>While this code works, for a typical app it is not ideal.</p>
<p>Most apps use more than one middleware, and each middleware often requires some initial setup. The extra noise added to the <code>index.js</code> can quickly make it hard to maintain, because the logic is not cleanly organised.</p>
<h2 id="the-solution-configurestore">The solution: <code>configureStore</code></h2>
<p>The solution to this problem is to create a new <code>configureStore</code> function which encapsulates our store creation logic, which can then be located in its own file to ease extensibility.</p>
<p>The end goal is for our <code>index.js</code> to look like this:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb65-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-2" title="2"><span class="im">import</span> <span class="op">{</span> render <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-4" title="4"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./components/App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-5" title="5"><span class="im">import</span> configureStore <span class="im">from</span> <span class="st">&quot;./configureStore&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-6" title="6"></a>
<a class="sourceLine" id="cb65-7" title="7"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb65-8" title="8"></a>
<a class="sourceLine" id="cb65-9" title="9"><span class="at">render</span>(</a>
<a class="sourceLine" id="cb65-10" title="10">  <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb65-11" title="11">    <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb65-12" title="12">  &lt;/Provider<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb65-13" title="13">  <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;root&quot;</span>)</a>
<a class="sourceLine" id="cb65-14" title="14">)<span class="op">;</span></a></code></pre></div>
<p>All the logic related to configuring the store - including importing reducers, middleware, and enhancers - is handled in a dedicated file.</p>
<p>To achieve this, <code>configureStore</code> function looks like this:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb66-1" title="1"><span class="im">import</span> <span class="op">{</span> applyMiddleware<span class="op">,</span> compose<span class="op">,</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb66-2" title="2"><span class="im">import</span> thunkMiddleware <span class="im">from</span> <span class="st">&quot;redux-thunk&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb66-3" title="3"></a>
<a class="sourceLine" id="cb66-4" title="4"><span class="im">import</span> monitorReducersEnhancer <span class="im">from</span> <span class="st">&quot;./enhancers/monitorReducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb66-5" title="5"><span class="im">import</span> loggerMiddleware <span class="im">from</span> <span class="st">&quot;./middleware/logger&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb66-6" title="6"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb66-7" title="7"></a>
<a class="sourceLine" id="cb66-8" title="8"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="at">configureStore</span>(preloadedState) <span class="op">{</span></a>
<a class="sourceLine" id="cb66-9" title="9">  <span class="kw">const</span> middlewares <span class="op">=</span> [loggerMiddleware<span class="op">,</span> thunkMiddleware]<span class="op">;</span></a>
<a class="sourceLine" id="cb66-10" title="10">  <span class="kw">const</span> middlewareEnhancer <span class="op">=</span> <span class="at">applyMiddleware</span>(...<span class="at">middlewares</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb66-11" title="11"></a>
<a class="sourceLine" id="cb66-12" title="12">  <span class="kw">const</span> enhancers <span class="op">=</span> [middlewareEnhancer<span class="op">,</span> monitorReducersEnhancer]<span class="op">;</span></a>
<a class="sourceLine" id="cb66-13" title="13">  <span class="kw">const</span> composedEnhancers <span class="op">=</span> <span class="at">compose</span>(...<span class="at">enhancers</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb66-14" title="14"></a>
<a class="sourceLine" id="cb66-15" title="15">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> preloadedState<span class="op">,</span> composedEnhancers)<span class="op">;</span></a>
<a class="sourceLine" id="cb66-16" title="16"></a>
<a class="sourceLine" id="cb66-17" title="17">  <span class="cf">return</span> store<span class="op">;</span></a>
<a class="sourceLine" id="cb66-18" title="18"><span class="op">}</span></a></code></pre></div>
<p>This function follows the same steps outlined above, with some of the logic split out to prepare for extension, which will make it easier to add more in future:</p>
<ul>
<li><p>Both <code>middlewares</code> and <code>enhancers</code> are defined as arrays, separate from the functions which consume them.</p>
<p>This allows us to easily add more middleware or enhancers based on different conditions.</p>
<p>For example, it is common to add some middleware only when in development mode, which is easily achieved by pushing to the middlewares array inside an if statement:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb67-1" title="1"><span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">===</span> <span class="st">&quot;development&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb67-2" title="2">  <span class="va">middlewares</span>.<span class="at">push</span>(secretMiddleware)<span class="op">;</span></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="op">}</span></a></code></pre></div></li>
<li><p>A <code>preloadedState</code> variable is passed through to <code>createStore</code> in case we want to add this later.</p></li>
</ul>
<p>This also makes our <code>createStore</code> function easier to reason about - each step is clearly separated, which makes it more obvious what exactly is happening.</p>
<h2 id="integrating-the-devtools-extension">Integrating the devtools extension</h2>
<p>Another common feature which you may wish to add to your app is the <code>redux-devtools-extension</code> integration.</p>
<p>The extension is a suite of tools which give you absolute control over your Redux store - it allows you to inspect and replay actions, explore your state at different times, dispatch actions directly to the store, and much more. <a href="https://github.com/zalmoxisus/redux-devtools-extension">Click here to read more about the available features.</a></p>
<p>There are several ways to integrate the extension, but we will use the most convenient option.</p>
<p>First, we install the package via npm:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb68-1" title="1"><span class="ex">npm</span> install --save-dev redux-devtools-extension</a></code></pre></div>
<p>Next, we remove the <code>compose</code> function which we imported from <code>redux</code>, and replace it with a new <code>composeWithDevTools</code> function imported from <code>redux-devtools-extension</code>.</p>
<p>The final code looks like this:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb69-1" title="1"><span class="im">import</span> <span class="op">{</span> applyMiddleware<span class="op">,</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-2" title="2"><span class="im">import</span> thunkMiddleware <span class="im">from</span> <span class="st">&quot;redux-thunk&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-3" title="3"><span class="im">import</span> <span class="op">{</span> composeWithDevTools <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux-devtools-extension&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-4" title="4"></a>
<a class="sourceLine" id="cb69-5" title="5"><span class="im">import</span> monitorReducersEnhancer <span class="im">from</span> <span class="st">&quot;./enhancers/monitorReducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-6" title="6"><span class="im">import</span> loggerMiddleware <span class="im">from</span> <span class="st">&quot;./middleware/logger&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-7" title="7"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-8" title="8"></a>
<a class="sourceLine" id="cb69-9" title="9"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="at">configureStore</span>(preloadedState) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-10" title="10">  <span class="kw">const</span> middlewares <span class="op">=</span> [loggerMiddleware<span class="op">,</span> thunkMiddleware]<span class="op">;</span></a>
<a class="sourceLine" id="cb69-11" title="11">  <span class="kw">const</span> middlewareEnhancer <span class="op">=</span> <span class="at">applyMiddleware</span>(...<span class="at">middlewares</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-12" title="12"></a>
<a class="sourceLine" id="cb69-13" title="13">  <span class="kw">const</span> enhancers <span class="op">=</span> [middlewareEnhancer<span class="op">,</span> monitorReducersEnhancer]<span class="op">;</span></a>
<a class="sourceLine" id="cb69-14" title="14">  <span class="kw">const</span> composedEnhancers <span class="op">=</span> <span class="at">composeWithDevTools</span>(...<span class="at">enhancers</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-15" title="15"></a>
<a class="sourceLine" id="cb69-16" title="16">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> preloadedState<span class="op">,</span> composedEnhancers)<span class="op">;</span></a>
<a class="sourceLine" id="cb69-17" title="17"></a>
<a class="sourceLine" id="cb69-18" title="18">  <span class="cf">return</span> store<span class="op">;</span></a>
<a class="sourceLine" id="cb69-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>And that’s it!</p>
<p>If we now visit our app via a browser with the devtools extension installed, we can explore and debug using a powerful new tool.</p>
<h2 id="hot-reloading">Hot reloading</h2>
<p>Another powerful tool which can make the development process a lot more intuitive is hot reloading, which means replacing pieces of code without restarting your whole app.</p>
<p>For example, consider what happens when you run your app, interact with it for a while, and then decide to make changes to one of your reducers. Normally, when you make those changes your app will restart, reverting your Redux state to its initial value.</p>
<p>With hot module reloading enabled, only the reducer you changed would be reloaded, allowing you to change your code <em>without</em> resetting the state every time. This makes for a much faster development process.</p>
<p>We’ll add hot reloading both to our Redux reducers and to our React components.</p>
<p>First, let’s add it to our <code>configureStore</code> function:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb70-1" title="1"><span class="im">import</span> <span class="op">{</span> applyMiddleware<span class="op">,</span> compose<span class="op">,</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb70-2" title="2"><span class="im">import</span> thunkMiddleware <span class="im">from</span> <span class="st">&quot;redux-thunk&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb70-3" title="3"></a>
<a class="sourceLine" id="cb70-4" title="4"><span class="im">import</span> monitorReducersEnhancer <span class="im">from</span> <span class="st">&quot;./enhancers/monitorReducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb70-5" title="5"><span class="im">import</span> loggerMiddleware <span class="im">from</span> <span class="st">&quot;./middleware/logger&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb70-6" title="6"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb70-7" title="7"></a>
<a class="sourceLine" id="cb70-8" title="8"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="at">configureStore</span>(preloadedState) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-9" title="9">  <span class="kw">const</span> middlewares <span class="op">=</span> [loggerMiddleware<span class="op">,</span> thunkMiddleware]<span class="op">;</span></a>
<a class="sourceLine" id="cb70-10" title="10">  <span class="kw">const</span> middlewareEnhancer <span class="op">=</span> <span class="at">applyMiddleware</span>(...<span class="at">middlewares</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-11" title="11"></a>
<a class="sourceLine" id="cb70-12" title="12">  <span class="kw">const</span> enhancers <span class="op">=</span> [middlewareEnhancer<span class="op">,</span> monitorReducersEnhancer]<span class="op">;</span></a>
<a class="sourceLine" id="cb70-13" title="13">  <span class="kw">const</span> composedEnhancers <span class="op">=</span> <span class="at">compose</span>(...<span class="at">enhancers</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-14" title="14"></a>
<a class="sourceLine" id="cb70-15" title="15">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> preloadedState<span class="op">,</span> composedEnhancers)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-16" title="16"></a>
<a class="sourceLine" id="cb70-17" title="17">  <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&quot;production&quot;</span> <span class="op">&amp;&amp;</span> <span class="va">module</span>.<span class="at">hot</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-18" title="18">    <span class="va">module</span>.<span class="va">hot</span>.<span class="at">accept</span>(<span class="st">&quot;./reducers&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="va">store</span>.<span class="at">replaceReducer</span>(rootReducer))<span class="op">;</span></a>
<a class="sourceLine" id="cb70-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb70-20" title="20"></a>
<a class="sourceLine" id="cb70-21" title="21">  <span class="cf">return</span> store<span class="op">;</span></a>
<a class="sourceLine" id="cb70-22" title="22"><span class="op">}</span></a></code></pre></div>
<p>The new code is wrapped in an <code>if</code> statement, so it only runs when our app is not in production mode, and only if the <code>module.hot</code> feature is available.</p>
<p>Bundlers like Webpack and Parcel support a <code>module.hot.accept</code> method to specify which module should be hot reloaded, and what should happen when the module changes. In this case, we’re watching the <code>./reducers</code> module, and passing the updated <code>rootReducer</code> to the <code>store.replaceReducer</code> method when it changes.</p>
<p>We’ll also use the same pattern in our <code>index.js</code> to hot reload any changes to our React components:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb71-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb71-2" title="2"><span class="im">import</span> <span class="op">{</span> render <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb71-3" title="3"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb71-4" title="4"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./components/App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb71-5" title="5"><span class="im">import</span> configureStore <span class="im">from</span> <span class="st">&quot;./configureStore&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb71-6" title="6"></a>
<a class="sourceLine" id="cb71-7" title="7"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb71-8" title="8"></a>
<a class="sourceLine" id="cb71-9" title="9"><span class="kw">const</span> renderApp <span class="op">=</span> () <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb71-10" title="10">  <span class="at">render</span>(</a>
<a class="sourceLine" id="cb71-11" title="11">    <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb71-12" title="12">      <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb71-13" title="13">    &lt;/Provider<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb71-14" title="14">    <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;root&quot;</span>)</a>
<a class="sourceLine" id="cb71-15" title="15">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb71-16" title="16"></a>
<a class="sourceLine" id="cb71-17" title="17"><span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&quot;production&quot;</span> <span class="op">&amp;&amp;</span> <span class="va">module</span>.<span class="at">hot</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb71-18" title="18">  <span class="va">module</span>.<span class="va">hot</span>.<span class="at">accept</span>(<span class="st">&quot;./components/App&quot;</span><span class="op">,</span> renderApp)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-19" title="19"><span class="op">}</span></a>
<a class="sourceLine" id="cb71-20" title="20"></a>
<a class="sourceLine" id="cb71-21" title="21"><span class="at">renderApp</span>()<span class="op">;</span></a></code></pre></div>
<p>The only extra change here is that we have encapsulated our app’s rendering into a new <code>renderApp</code> function, which we now call to re-render the app.</p>
<h2 id="simplifying-setup-with-redux-toolkit">Simplifying Setup with Redux Toolkit</h2>
<p>The Redux core library is deliberately unopinionated. It lets you decide how you want to handle everything, like store setup, what your state contains, and how you want to build your reducers.</p>
<p>This is good in some cases, because it gives you flexibility, but that flexibility isn’t always needed. Sometimes we just want the simplest possible way to get started, with some good default behavior out of the box.</p>
<p>The <a href="https://redux-toolkit.js.org/">Redux Toolkit</a> package is designed to help simplify several common Redux use cases, including store setup. Let’s see how it can help improve the store setup process.</p>
<p>Redux Toolkit includes a prebuilt <a href="https://redux-toolkit.js.org/api/configureStore"><code>configureStore</code> function</a> like the one shown in the earlier examples.</p>
<p>The fastest way to use is it is to just pass the root reducer function:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb72-1" title="1"><span class="im">import</span> <span class="op">{</span> configureStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb72-2" title="2"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb72-3" title="3"></a>
<a class="sourceLine" id="cb72-4" title="4"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb72-5" title="5">  <span class="dt">reducer</span><span class="op">:</span> rootReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb72-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb72-7" title="7"></a>
<a class="sourceLine" id="cb72-8" title="8"><span class="im">export</span> <span class="im">default</span> store<span class="op">;</span></a></code></pre></div>
<p>Note that it accepts an object with named parameters, to make it clearer what you’re passing in.</p>
<p>By default, <code>configureStore</code> from Redux Toolkit will:</p>
<ul>
<li>Call <code>applyMiddleware</code> with <a href="https://redux-toolkit.js.org/api/getDefaultMiddleware">a default list of middleware, including <code>redux-thunk</code></a>, and some development-only middleware that catch common mistakes like mutating state</li>
<li>Call <code>composeWithDevTools</code> to set up the Redux DevTools Extension</li>
</ul>
<p>Here’s what the hot reloading example might look like using Redux Toolkit:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb73-1" title="1"><span class="im">import</span> <span class="op">{</span> configureStore<span class="op">,</span> getDefaultMiddleware <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb73-2" title="2"></a>
<a class="sourceLine" id="cb73-3" title="3"><span class="im">import</span> monitorReducersEnhancer <span class="im">from</span> <span class="st">&quot;./enhancers/monitorReducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb73-4" title="4"><span class="im">import</span> loggerMiddleware <span class="im">from</span> <span class="st">&quot;./middleware/logger&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb73-5" title="5"><span class="im">import</span> rootReducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb73-6" title="6"></a>
<a class="sourceLine" id="cb73-7" title="7"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="at">configureAppStore</span>(preloadedState) <span class="op">{</span></a>
<a class="sourceLine" id="cb73-8" title="8">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb73-9" title="9">    <span class="dt">reducer</span><span class="op">:</span> rootReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb73-10" title="10">    <span class="dt">middleware</span><span class="op">:</span> [loggerMiddleware<span class="op">,</span> ...<span class="at">getDefaultMiddleware</span>()]<span class="op">,</span></a>
<a class="sourceLine" id="cb73-11" title="11">    preloadedState<span class="op">,</span></a>
<a class="sourceLine" id="cb73-12" title="12">    <span class="dt">enhancers</span><span class="op">:</span> [monitorReducersEnhancer]<span class="op">,</span></a>
<a class="sourceLine" id="cb73-13" title="13">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb73-14" title="14"></a>
<a class="sourceLine" id="cb73-15" title="15">  <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&quot;production&quot;</span> <span class="op">&amp;&amp;</span> <span class="va">module</span>.<span class="at">hot</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb73-16" title="16">    <span class="va">module</span>.<span class="va">hot</span>.<span class="at">accept</span>(<span class="st">&quot;./reducers&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="va">store</span>.<span class="at">replaceReducer</span>(rootReducer))<span class="op">;</span></a>
<a class="sourceLine" id="cb73-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb73-18" title="18"></a>
<a class="sourceLine" id="cb73-19" title="19">  <span class="cf">return</span> store<span class="op">;</span></a>
<a class="sourceLine" id="cb73-20" title="20"><span class="op">}</span></a></code></pre></div>
<p>That definitely simplifies some of the setup process.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Now that you know how to encapsulate your store configuration to make it easier to maintain, you can <a href="https://redux-toolkit.js.org/api/configureStore">look at the Redux Toolkit <code>configureStore</code> API</a>, or take a closer look at some of the <a href="../introduction/Ecosystem.md#debuggers-and-viewers">extensions available in the Redux ecosystem</a>.</p>
<hr />
<p>id: implementing-undo-history title: Implementing Undo History</p>
<hr />
<h1 id="implementing-undo-history">Implementing Undo History</h1>
<p>:::important Prerequisites</p>
<ul>
<li>Completion of the <a href="../tutorials/fundamentals/part-1-overview.md">“Redux Fundamentals” tutorial</a></li>
<li>Understanding of <a href="../tutorials/fundamentals/part-3-state-actions-reducers.md#splitting-reducers">“reducer composition”</a></li>
</ul>
<p>:::</p>
<p>Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.</p>
<p>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like <a href="https://en.wikipedia.org/wiki/Command_pattern">Command</a>.</p>
<p>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</p>
<ul>
<li>There are no multiple models—just a state subtree that you want to keep track of.</li>
<li>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</li>
<li>The reducer <code>(state, action) =&gt; state</code> signature makes it natural to implement generic “reducer enhancers” or “higher order reducers”. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</li>
</ul>
<p>In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.</p>
<p>In the second part of this recipe, we will show how to use <a href="https://github.com/omnidan/redux-undo">Redux Undo</a> package that provides this functionality out of the box.</p>
<p><a href="https://twitter.com/dan_abramov/status/647038407286390784"><img src="https://i.imgur.com/lvDFHkH.gif" alt="demo of todos-with-undo" /></a></p>
<h2 id="understanding-undo-history">Understanding Undo History</h2>
<h3 id="designing-the-state-shape">Designing the State Shape</h3>
<p>Undo history is also part of your app’s state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the <em>history</em> of this state at different points in time.</p>
<p>For example, the state shape of a counter app might look like this:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb74-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb74-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb74-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>If we wanted to implement Undo and Redo in such an app, we’d need to store more state so we can answer the following questions:</p>
<ul>
<li>Is there anything left to undo or redo?</li>
<li>What is the current state?</li>
<li>What are the past (and future) states in the undo stack?</li>
</ul>
<p>It is reasonable to suggest that our state shape should change to answer these questions:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb75-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb75-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb75-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb75-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">10</span><span class="op">,</span></a>
<a class="sourceLine" id="cb75-5" title="5">    <span class="dt">future</span><span class="op">:</span> []</a>
<a class="sourceLine" id="cb75-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb75-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>Now, if user presses “Undo”, we want it to change to move into the past:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb76-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb76-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb76-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb76-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">9</span><span class="op">,</span></a>
<a class="sourceLine" id="cb76-5" title="5">    <span class="dt">future</span><span class="op">:</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb76-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb76-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>And further yet:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb77-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb77-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb77-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb77-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">8</span><span class="op">,</span></a>
<a class="sourceLine" id="cb77-5" title="5">    <span class="dt">future</span><span class="op">:</span> [<span class="dv">9</span><span class="op">,</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb77-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb77-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>When the user presses “Redo”, we want to move one step back into the future:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb78-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb78-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb78-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb78-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">9</span><span class="op">,</span></a>
<a class="sourceLine" id="cb78-5" title="5">    <span class="dt">future</span><span class="op">:</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb78-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb78-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>Finally, if the user performs an action (e.g. decrement the counter) while we’re in the middle of the undo stack, we’re going to discard the existing future:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb79-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb79-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb79-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb79-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">8</span><span class="op">,</span></a>
<a class="sourceLine" id="cb79-5" title="5">    <span class="dt">future</span><span class="op">:</span> []</a>
<a class="sourceLine" id="cb79-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb79-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb80-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb80-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb80-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb80-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span></a>
<a class="sourceLine" id="cb80-5" title="5">    <span class="dt">future</span><span class="op">:</span> [<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb80-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb80-7" title="7"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb81"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb81-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb81-2" title="2">  <span class="dt">todos</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb81-3" title="3">    <span class="dt">past</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb81-4" title="4">      []<span class="op">,</span></a>
<a class="sourceLine" id="cb81-5" title="5">      [<span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span> <span class="op">}</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb81-6" title="6">      [<span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>]</a>
<a class="sourceLine" id="cb81-7" title="7">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb81-8" title="8">    <span class="dt">present</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb81-9" title="9">      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb81-10" title="10">      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Implement Undo&#39;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb81-11" title="11">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb81-12" title="12">    <span class="dt">future</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb81-13" title="13">      [</a>
<a class="sourceLine" id="cb81-14" title="14">        <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb81-15" title="15">        <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Implement Undo&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb81-16" title="16">      ]</a>
<a class="sourceLine" id="cb81-17" title="17">    ]</a>
<a class="sourceLine" id="cb81-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb81-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>In general, it looks like this:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb82-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb82-2" title="2">  <span class="dt">past</span><span class="op">:</span> Array<span class="op">&lt;</span>T<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb82-3" title="3">  <span class="dt">present</span><span class="op">:</span> T<span class="op">,</span></a>
<a class="sourceLine" id="cb82-4" title="4">  <span class="dt">future</span><span class="op">:</span> Array<span class="op">&lt;</span>T<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb82-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>It is also up to us whether to keep a single top-level history:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb83-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb83-2" title="2">  <span class="dt">past</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb83-3" title="3">    <span class="op">{</span> <span class="dt">counterA</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">counterB</span><span class="op">:</span> <span class="dv">1</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb83-4" title="4">    <span class="op">{</span> <span class="dt">counterA</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">counterB</span><span class="op">:</span> <span class="dv">0</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb83-5" title="5">    <span class="op">{</span> <span class="dt">counterA</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">counterB</span><span class="op">:</span> <span class="dv">0</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb83-6" title="6">  ]<span class="op">,</span></a>
<a class="sourceLine" id="cb83-7" title="7">  <span class="dt">present</span><span class="op">:</span> <span class="op">{</span> <span class="dt">counterA</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="dt">counterB</span><span class="op">:</span> <span class="dv">1</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb83-8" title="8">  <span class="dt">future</span><span class="op">:</span> []</a>
<a class="sourceLine" id="cb83-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>Or many granular histories so user can undo and redo actions in them independently:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb84-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb84-2" title="2">  <span class="dt">counterA</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb84-3" title="3">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb84-4" title="4">    <span class="dt">present</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span></a>
<a class="sourceLine" id="cb84-5" title="5">    <span class="dt">future</span><span class="op">:</span> []</a>
<a class="sourceLine" id="cb84-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb84-7" title="7">  <span class="dt">counterB</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb84-8" title="8">    <span class="dt">past</span><span class="op">:</span> [<span class="dv">0</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb84-9" title="9">    <span class="dt">present</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb84-10" title="10">    <span class="dt">future</span><span class="op">:</span> []</a>
<a class="sourceLine" id="cb84-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb84-12" title="12"><span class="op">}</span></a></code></pre></div>
<p>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</p>
<h3 id="designing-the-algorithm">Designing the Algorithm</h3>
<p>Regardless of the specific data type, the shape of the undo history state is the same:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb85-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb85-2" title="2">  <span class="dt">past</span><span class="op">:</span> Array<span class="op">&lt;</span>T<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb85-3" title="3">  <span class="dt">present</span><span class="op">:</span> T<span class="op">,</span></a>
<a class="sourceLine" id="cb85-4" title="4">  <span class="dt">future</span><span class="op">:</span> Array<span class="op">&lt;</span>T<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb85-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>Let’s talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: <code>UNDO</code> and <code>REDO</code>. In our reducer, we will do the following steps to handle these actions:</p>
<h4 id="handling-undo">Handling Undo</h4>
<ul>
<li>Remove the <em>last</em> element from the <code>past</code>.</li>
<li>Set the <code>present</code> to the element we removed in the previous step.</li>
<li>Insert the old <code>present</code> state at the <em>beginning</em> of the <code>future</code>.</li>
</ul>
<h4 id="handling-redo">Handling Redo</h4>
<ul>
<li>Remove the <em>first</em> element from the <code>future</code>.</li>
<li>Set the <code>present</code> to the element we removed in the previous step.</li>
<li>Insert the old <code>present</code> state at the <em>end</em> of the <code>past</code>.</li>
</ul>
<h4 id="handling-other-actions">Handling Other Actions</h4>
<ul>
<li>Insert the <code>present</code> at the end of the <code>past</code>.</li>
<li>Set the <code>present</code> to the new state after handling the action.</li>
<li>Clear the <code>future</code>.</li>
</ul>
<h3 id="first-attempt-writing-a-reducer">First Attempt: Writing a Reducer</h3>
<div class="sourceCode" id="cb86"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb86-1" title="1"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb86-2" title="2">  <span class="dt">past</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb86-3" title="3">  <span class="dt">present</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span> <span class="co">// (?) How do we initialize the present?</span></a>
<a class="sourceLine" id="cb86-4" title="4">  <span class="dt">future</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb86-5" title="5"><span class="op">};</span></a>
<a class="sourceLine" id="cb86-6" title="6"></a>
<a class="sourceLine" id="cb86-7" title="7"><span class="kw">function</span> <span class="at">undoable</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb86-8" title="8">  <span class="kw">const</span> <span class="op">{</span> past<span class="op">,</span> present<span class="op">,</span> future <span class="op">}</span> <span class="op">=</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb86-9" title="9"></a>
<a class="sourceLine" id="cb86-10" title="10">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb86-11" title="11">    <span class="cf">case</span> <span class="st">&quot;UNDO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb86-12" title="12">      <span class="kw">const</span> previous <span class="op">=</span> past[<span class="va">past</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb86-13" title="13">      <span class="kw">const</span> newPast <span class="op">=</span> <span class="va">past</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="va">past</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb86-14" title="14">      <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb86-15" title="15">        <span class="dt">past</span><span class="op">:</span> newPast<span class="op">,</span></a>
<a class="sourceLine" id="cb86-16" title="16">        <span class="dt">present</span><span class="op">:</span> previous<span class="op">,</span></a>
<a class="sourceLine" id="cb86-17" title="17">        <span class="dt">future</span><span class="op">:</span> [present<span class="op">,</span> ...<span class="at">future</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb86-18" title="18">      <span class="op">};</span></a>
<a class="sourceLine" id="cb86-19" title="19">    <span class="cf">case</span> <span class="st">&quot;REDO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb86-20" title="20">      <span class="kw">const</span> next <span class="op">=</span> future[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb86-21" title="21">      <span class="kw">const</span> newFuture <span class="op">=</span> <span class="va">future</span>.<span class="at">slice</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb86-22" title="22">      <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb86-23" title="23">        <span class="dt">past</span><span class="op">:</span> [...<span class="at">past</span><span class="op">,</span> present]<span class="op">,</span></a>
<a class="sourceLine" id="cb86-24" title="24">        <span class="dt">present</span><span class="op">:</span> next<span class="op">,</span></a>
<a class="sourceLine" id="cb86-25" title="25">        <span class="dt">future</span><span class="op">:</span> newFuture<span class="op">,</span></a>
<a class="sourceLine" id="cb86-26" title="26">      <span class="op">};</span></a>
<a class="sourceLine" id="cb86-27" title="27">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb86-28" title="28">      <span class="co">// (?) How do we handle other actions?</span></a>
<a class="sourceLine" id="cb86-29" title="29">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb86-30" title="30">  <span class="op">}</span></a>
<a class="sourceLine" id="cb86-31" title="31"><span class="op">}</span></a></code></pre></div>
<p>This implementation isn’t usable because it leaves out three important questions:</p>
<ul>
<li>Where do we get the initial <code>present</code> state from? We don’t seem to know it beforehand.</li>
<li>Where do we react to the external actions to save the <code>present</code> to the <code>past</code>?</li>
<li>How do we actually delegate the control over the <code>present</code> state to a custom reducer?</li>
</ul>
<p>It seems that reducer isn’t the right abstraction, but we’re very close.</p>
<h3 id="meet-reducer-enhancers">Meet Reducer Enhancers</h3>
<p>You might be familiar with <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher order functions</a>. If you use React, you might be familiar with <a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750">higher order components</a>. Here is a variation on the same pattern, applied to reducers.</p>
<p>A <em>reducer enhancer</em> (or a <em>higher order reducer</em>) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn’t understand. This isn’t a new pattern—technically, <a href="../api/combineReducers.md"><code>combineReducers()</code></a> is also a reducer enhancer because it takes reducers and returns a new reducer.</p>
<p>A reducer enhancer that doesn’t do anything looks like this:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb87-1" title="1"><span class="kw">function</span> <span class="at">doNothingWith</span>(reducer) <span class="op">{</span></a>
<a class="sourceLine" id="cb87-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> (state<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb87-3" title="3">    <span class="co">// Just call the passed reducer</span></a>
<a class="sourceLine" id="cb87-4" title="4">    <span class="cf">return</span> <span class="at">reducer</span>(state<span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb87-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb87-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>A reducer enhancer that combines other reducers might look like this:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb88-1" title="1"><span class="kw">function</span> <span class="at">combineReducers</span>(reducers) <span class="op">{</span></a>
<a class="sourceLine" id="cb88-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> (state <span class="op">=</span> <span class="op">{},</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb88-3" title="3">    <span class="cf">return</span> <span class="va">Object</span>.<span class="at">keys</span>(reducers).<span class="at">reduce</span>((nextState<span class="op">,</span> key) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb88-4" title="4">      <span class="co">// Call every reducer with the part of the state it manages</span></a>
<a class="sourceLine" id="cb88-5" title="5">      nextState[key] <span class="op">=</span> reducers[key](state[key]<span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb88-6" title="6">      <span class="cf">return</span> nextState<span class="op">;</span></a>
<a class="sourceLine" id="cb88-7" title="7">    <span class="op">},</span> <span class="op">{}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb88-8" title="8">  <span class="op">};</span></a>
<a class="sourceLine" id="cb88-9" title="9"><span class="op">}</span></a></code></pre></div>
<h3 id="second-attempt-writing-a-reducer-enhancer">Second Attempt: Writing a Reducer Enhancer</h3>
<p>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what <code>undoable</code> should have been:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb89-1" title="1"><span class="kw">function</span> <span class="at">undoable</span>(reducer) <span class="op">{</span></a>
<a class="sourceLine" id="cb89-2" title="2">  <span class="co">// Call the reducer with empty action to populate the initial state</span></a>
<a class="sourceLine" id="cb89-3" title="3">  <span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb89-4" title="4">    <span class="dt">past</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb89-5" title="5">    <span class="dt">present</span><span class="op">:</span> <span class="at">reducer</span>(<span class="kw">undefined</span><span class="op">,</span> <span class="op">{}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb89-6" title="6">    <span class="dt">future</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb89-7" title="7">  <span class="op">};</span></a>
<a class="sourceLine" id="cb89-8" title="8"></a>
<a class="sourceLine" id="cb89-9" title="9">  <span class="co">// Return a reducer that handles undo and redo</span></a>
<a class="sourceLine" id="cb89-10" title="10">  <span class="cf">return</span> <span class="kw">function</span> (state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb89-11" title="11">    <span class="kw">const</span> <span class="op">{</span> past<span class="op">,</span> present<span class="op">,</span> future <span class="op">}</span> <span class="op">=</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb89-12" title="12"></a>
<a class="sourceLine" id="cb89-13" title="13">    <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb89-14" title="14">      <span class="cf">case</span> <span class="st">&quot;UNDO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb89-15" title="15">        <span class="kw">const</span> previous <span class="op">=</span> past[<span class="va">past</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb89-16" title="16">        <span class="kw">const</span> newPast <span class="op">=</span> <span class="va">past</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="va">past</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb89-17" title="17">        <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb89-18" title="18">          <span class="dt">past</span><span class="op">:</span> newPast<span class="op">,</span></a>
<a class="sourceLine" id="cb89-19" title="19">          <span class="dt">present</span><span class="op">:</span> previous<span class="op">,</span></a>
<a class="sourceLine" id="cb89-20" title="20">          <span class="dt">future</span><span class="op">:</span> [present<span class="op">,</span> ...<span class="at">future</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb89-21" title="21">        <span class="op">};</span></a>
<a class="sourceLine" id="cb89-22" title="22">      <span class="cf">case</span> <span class="st">&quot;REDO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb89-23" title="23">        <span class="kw">const</span> next <span class="op">=</span> future[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb89-24" title="24">        <span class="kw">const</span> newFuture <span class="op">=</span> <span class="va">future</span>.<span class="at">slice</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb89-25" title="25">        <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb89-26" title="26">          <span class="dt">past</span><span class="op">:</span> [...<span class="at">past</span><span class="op">,</span> present]<span class="op">,</span></a>
<a class="sourceLine" id="cb89-27" title="27">          <span class="dt">present</span><span class="op">:</span> next<span class="op">,</span></a>
<a class="sourceLine" id="cb89-28" title="28">          <span class="dt">future</span><span class="op">:</span> newFuture<span class="op">,</span></a>
<a class="sourceLine" id="cb89-29" title="29">        <span class="op">};</span></a>
<a class="sourceLine" id="cb89-30" title="30">      <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb89-31" title="31">        <span class="co">// Delegate handling the action to the passed reducer</span></a>
<a class="sourceLine" id="cb89-32" title="32">        <span class="kw">const</span> newPresent <span class="op">=</span> <span class="at">reducer</span>(present<span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb89-33" title="33">        <span class="cf">if</span> (present <span class="op">===</span> newPresent) <span class="op">{</span></a>
<a class="sourceLine" id="cb89-34" title="34">          <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb89-35" title="35">        <span class="op">}</span></a>
<a class="sourceLine" id="cb89-36" title="36">        <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb89-37" title="37">          <span class="dt">past</span><span class="op">:</span> [...<span class="at">past</span><span class="op">,</span> present]<span class="op">,</span></a>
<a class="sourceLine" id="cb89-38" title="38">          <span class="dt">present</span><span class="op">:</span> newPresent<span class="op">,</span></a>
<a class="sourceLine" id="cb89-39" title="39">          <span class="dt">future</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb89-40" title="40">        <span class="op">};</span></a>
<a class="sourceLine" id="cb89-41" title="41">    <span class="op">}</span></a>
<a class="sourceLine" id="cb89-42" title="42">  <span class="op">};</span></a>
<a class="sourceLine" id="cb89-43" title="43"><span class="op">}</span></a></code></pre></div>
<p>We can now wrap any reducer into <code>undoable</code> reducer enhancer to teach it to react to <code>UNDO</code> and <code>REDO</code> actions.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb90-1" title="1"><span class="co">// This is a reducer</span></a>
<a class="sourceLine" id="cb90-2" title="2"><span class="kw">function</span> <span class="at">todos</span>(state <span class="op">=</span> []<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb90-3" title="3">  <span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb90-4" title="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb90-5" title="5"></a>
<a class="sourceLine" id="cb90-6" title="6"><span class="co">// This is also a reducer!</span></a>
<a class="sourceLine" id="cb90-7" title="7"><span class="kw">const</span> undoableTodos <span class="op">=</span> <span class="at">undoable</span>(todos)<span class="op">;</span></a>
<a class="sourceLine" id="cb90-8" title="8"></a>
<a class="sourceLine" id="cb90-9" title="9"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb90-10" title="10"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(undoableTodos)<span class="op">;</span></a>
<a class="sourceLine" id="cb90-11" title="11"></a>
<a class="sourceLine" id="cb90-12" title="12"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb90-13" title="13">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb90-14" title="14">  <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Use Redux&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb90-15" title="15"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb90-16" title="16"></a>
<a class="sourceLine" id="cb90-17" title="17"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb90-18" title="18">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb90-19" title="19">  <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Implement Undo&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb90-20" title="20"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb90-21" title="21"></a>
<a class="sourceLine" id="cb90-22" title="22"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb90-23" title="23">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;UNDO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb90-24" title="24"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>There is an important gotcha: you need to remember to append <code>.present</code> to the current state when you retrieve it. You may also check <code>.past.length</code> and <code>.future.length</code> to determine whether to enable or to disable the Undo and Redo buttons, respectively.</p>
<p>You might have heard that Redux was influenced by <a href="https://github.com/evancz/elm-architecture-tutorial/">Elm Architecture</a>. It shouldn’t come as a surprise that this example is very similar to <a href="https://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0">elm-undo-redo package</a>.</p>
<h2 id="using-redux-undo">Using Redux Undo</h2>
<p>This was all very informative, but can’t we just drop a library and use it instead of implementing <code>undoable</code> ourselves? Sure, we can! Meet <a href="https://github.com/omnidan/redux-undo">Redux Undo</a>, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</p>
<p>In this part of the recipe, you will learn how to make a small “todo list” app logic undoable. You can find the full source of this recipe in the <a href="https://github.com/reduxjs/redux/tree/master/examples/todos-with-undo"><code>todos-with-undo</code> example that comes with Redux</a>.</p>
<h3 id="installation-2">Installation</h3>
<p>First of all, you need to run</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb91-1" title="1"><span class="ex">npm</span> install redux-undo</a></code></pre></div>
<p>This installs the package that provides the <code>undoable</code> reducer enhancer.</p>
<h3 id="wrapping-the-reducer">Wrapping the Reducer</h3>
<p>You will need to wrap the reducer you wish to enhance with <code>undoable</code> function. For example, if you exported a <code>todos</code> reducer from a dedicated file, you will want to change it to export the result of calling <code>undoable()</code> with the reducer you wrote:</p>
<h4 id="reducerstodos.js"><code>reducers/todos.js</code></h4>
<div class="sourceCode" id="cb92"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb92-1" title="1"><span class="im">import</span> undoable <span class="im">from</span> <span class="st">&quot;redux-undo&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb92-2" title="2"></a>
<a class="sourceLine" id="cb92-3" title="3"><span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb92-4" title="4"></a>
<a class="sourceLine" id="cb92-5" title="5"><span class="kw">const</span> todos <span class="op">=</span> (state <span class="op">=</span> []<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb92-6" title="6">  <span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb92-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb92-8" title="8"></a>
<a class="sourceLine" id="cb92-9" title="9"><span class="kw">const</span> undoableTodos <span class="op">=</span> <span class="at">undoable</span>(todos)<span class="op">;</span></a>
<a class="sourceLine" id="cb92-10" title="10"></a>
<a class="sourceLine" id="cb92-11" title="11"><span class="im">export</span> <span class="im">default</span> undoableTodos<span class="op">;</span></a></code></pre></div>
<p>There are <a href="https://github.com/omnidan/redux-undo#configuration">many other options</a> to configure your undoable reducer, like setting the action type for Undo and Redo actions.</p>
<p>Note that your <code>combineReducers()</code> call will stay exactly as it was, but the <code>todos</code> reducer will now refer to the reducer enhanced with Redux Undo:</p>
<h4 id="reducersindex.js"><code>reducers/index.js</code></h4>
<div class="sourceCode" id="cb93"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb93-1" title="1"><span class="im">import</span> <span class="op">{</span> combineReducers <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb93-2" title="2"><span class="im">import</span> todos <span class="im">from</span> <span class="st">&quot;./todos&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb93-3" title="3"><span class="im">import</span> visibilityFilter <span class="im">from</span> <span class="st">&quot;./visibilityFilter&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb93-4" title="4"></a>
<a class="sourceLine" id="cb93-5" title="5"><span class="kw">const</span> todoApp <span class="op">=</span> <span class="at">combineReducers</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb93-6" title="6">  todos<span class="op">,</span></a>
<a class="sourceLine" id="cb93-7" title="7">  visibilityFilter<span class="op">,</span></a>
<a class="sourceLine" id="cb93-8" title="8"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb93-9" title="9"></a>
<a class="sourceLine" id="cb93-10" title="10"><span class="im">export</span> <span class="im">default</span> todoApp<span class="op">;</span></a></code></pre></div>
<p>You may wrap one or more reducers in <code>undoable</code> at any level of the reducer composition hierarchy. We choose to wrap <code>todos</code> instead of the top-level combined reducer so that changes to <code>visibilityFilter</code> are not reflected in the undo history.</p>
<h3 id="updating-the-selectors">Updating the Selectors</h3>
<p>Now the <code>todos</code> part of the state looks like this:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb94-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb94-2" title="2">  <span class="dt">visibilityFilter</span><span class="op">:</span> <span class="st">&#39;SHOW_ALL&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb94-3" title="3">  <span class="dt">todos</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb94-4" title="4">    <span class="dt">past</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb94-5" title="5">      []<span class="op">,</span></a>
<a class="sourceLine" id="cb94-6" title="6">      [<span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span> <span class="op">}</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb94-7" title="7">      [<span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>]</a>
<a class="sourceLine" id="cb94-8" title="8">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb94-9" title="9">    <span class="dt">present</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb94-10" title="10">      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb94-11" title="11">      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Implement Undo&#39;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb94-12" title="12">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb94-13" title="13">    <span class="dt">future</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb94-14" title="14">      [</a>
<a class="sourceLine" id="cb94-15" title="15">        <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb94-16" title="16">        <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Implement Undo&#39;</span><span class="op">,</span> <span class="dt">complete</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb94-17" title="17">      ]</a>
<a class="sourceLine" id="cb94-18" title="18">    ]</a>
<a class="sourceLine" id="cb94-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb94-20" title="20"><span class="op">}</span></a></code></pre></div>
<p>This means you need to access your state with <code>state.todos.present</code> instead of just <code>state.todos</code>:</p>
<h4 id="containersvisibletodolist.js"><code>containers/VisibleTodoList.js</code></h4>
<div class="sourceCode" id="cb95"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb95-1" title="1"><span class="kw">const</span> mapStateToProps <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb95-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb95-3" title="3">    <span class="dt">todos</span><span class="op">:</span> <span class="at">getVisibleTodos</span>(<span class="va">state</span>.<span class="va">todos</span>.<span class="at">present</span><span class="op">,</span> <span class="va">state</span>.<span class="at">visibilityFilter</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb95-4" title="4">  <span class="op">};</span></a>
<a class="sourceLine" id="cb95-5" title="5"><span class="op">};</span></a></code></pre></div>
<h3 id="adding-the-buttons">Adding the Buttons</h3>
<p>Now all you need to do is add the buttons for the Undo and Redo actions.</p>
<p>First, create a new container component called <code>UndoRedo</code> for these buttons. We won’t bother to split the presentational part into a separate file because it is very small:</p>
<h4 id="containersundoredo.js"><code>containers/UndoRedo.js</code></h4>
<div class="sourceCode" id="cb96"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb96-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb96-2" title="2"></a>
<a class="sourceLine" id="cb96-3" title="3"><span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb96-4" title="4"></a>
<a class="sourceLine" id="cb96-5" title="5"><span class="kw">let</span> UndoRedo <span class="op">=</span> (<span class="op">{</span> canUndo<span class="op">,</span> canRedo<span class="op">,</span> onUndo<span class="op">,</span> onRedo <span class="op">}</span>) <span class="kw">=&gt;</span> (</a>
<a class="sourceLine" id="cb96-6" title="6">  <span class="op">&lt;</span>p<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb96-7" title="7">    <span class="op">&lt;</span>button onClick<span class="op">={</span>onUndo<span class="op">}</span> disabled<span class="op">={!</span>canUndo<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb96-8" title="8">      Undo</a>
<a class="sourceLine" id="cb96-9" title="9">    &lt;/button<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb96-10" title="10">    <span class="op">&lt;</span>button onClick<span class="op">={</span>onRedo<span class="op">}</span> disabled<span class="op">={!</span>canRedo<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb96-11" title="11">      Redo</a>
<a class="sourceLine" id="cb96-12" title="12">    &lt;/button<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb96-13" title="13">  &lt;/p<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb96-14" title="14">)<span class="op">;</span></a></code></pre></div>
<p>You will use <code>connect()</code> from <a href="https://github.com/reduxjs/react-redux">React Redux</a> to generate a container component. To determine whether to enable Undo and Redo buttons, you can check <code>state.todos.past.length</code> and <code>state.todos.future.length</code>. You won’t need to write action creators for performing undo and redo because Redux Undo already provides them:</p>
<h4 id="containersundoredo.js-1"><code>containers/UndoRedo.js</code></h4>
<div class="sourceCode" id="cb97"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb97-1" title="1"><span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb97-2" title="2"></a>
<a class="sourceLine" id="cb97-3" title="3"><span class="im">import</span> <span class="op">{</span> ActionCreators <span class="im">as</span> UndoActionCreators <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux-undo&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb97-4" title="4"><span class="im">import</span> <span class="op">{</span> connect <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb97-5" title="5"></a>
<a class="sourceLine" id="cb97-6" title="6"><span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb97-7" title="7"></a>
<a class="sourceLine" id="cb97-8" title="8"><span class="kw">const</span> mapStateToProps <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb97-9" title="9">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb97-10" title="10">    <span class="dt">canUndo</span><span class="op">:</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="va">past</span>.<span class="at">length</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb97-11" title="11">    <span class="dt">canRedo</span><span class="op">:</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="va">future</span>.<span class="at">length</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb97-12" title="12">  <span class="op">};</span></a>
<a class="sourceLine" id="cb97-13" title="13"><span class="op">};</span></a>
<a class="sourceLine" id="cb97-14" title="14"></a>
<a class="sourceLine" id="cb97-15" title="15"><span class="kw">const</span> mapDispatchToProps <span class="op">=</span> (dispatch) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb97-16" title="16">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb97-17" title="17">    <span class="dt">onUndo</span><span class="op">:</span> () <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="va">UndoActionCreators</span>.<span class="at">undo</span>())<span class="op">,</span></a>
<a class="sourceLine" id="cb97-18" title="18">    <span class="dt">onRedo</span><span class="op">:</span> () <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="va">UndoActionCreators</span>.<span class="at">redo</span>())<span class="op">,</span></a>
<a class="sourceLine" id="cb97-19" title="19">  <span class="op">};</span></a>
<a class="sourceLine" id="cb97-20" title="20"><span class="op">};</span></a>
<a class="sourceLine" id="cb97-21" title="21"></a>
<a class="sourceLine" id="cb97-22" title="22">UndoRedo <span class="op">=</span> <span class="at">connect</span>(mapStateToProps<span class="op">,</span> mapDispatchToProps)(UndoRedo)<span class="op">;</span></a>
<a class="sourceLine" id="cb97-23" title="23"></a>
<a class="sourceLine" id="cb97-24" title="24"><span class="im">export</span> <span class="im">default</span> UndoRedo<span class="op">;</span></a></code></pre></div>
<p>Now you can add <code>UndoRedo</code> component to the <code>App</code> component:</p>
<h4 id="componentsapp.js"><code>components/App.js</code></h4>
<div class="sourceCode" id="cb98"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb98-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb98-2" title="2"><span class="im">import</span> Footer <span class="im">from</span> <span class="st">&quot;./Footer&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb98-3" title="3"><span class="im">import</span> AddTodo <span class="im">from</span> <span class="st">&quot;../containers/AddTodo&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb98-4" title="4"><span class="im">import</span> VisibleTodoList <span class="im">from</span> <span class="st">&quot;../containers/VisibleTodoList&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb98-5" title="5"><span class="im">import</span> UndoRedo <span class="im">from</span> <span class="st">&quot;../containers/UndoRedo&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb98-6" title="6"></a>
<a class="sourceLine" id="cb98-7" title="7"><span class="kw">const</span> App <span class="op">=</span> () <span class="kw">=&gt;</span> (</a>
<a class="sourceLine" id="cb98-8" title="8">  <span class="op">&lt;</span>div<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-9" title="9">    <span class="op">&lt;</span>AddTodo /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-10" title="10">    <span class="op">&lt;</span>VisibleTodoList /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-11" title="11">    <span class="op">&lt;</span>Footer /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-12" title="12">    <span class="op">&lt;</span>UndoRedo /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-13" title="13">  &lt;/div<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-14" title="14">)<span class="op">;</span></a>
<a class="sourceLine" id="cb98-15" title="15"></a>
<a class="sourceLine" id="cb98-16" title="16"><span class="im">export</span> <span class="im">default</span> App<span class="op">;</span></a></code></pre></div>
<p>This is it! Run <code>npm install</code> and <code>npm start</code> in the <a href="https://github.com/reduxjs/redux/tree/master/examples/todos-with-undo">example folder</a> and try it out!</p>
<hr />
<p>id: isolating-redux-sub-apps title: Isolating Redux Sub-Apps</p>
<hr />
<h1 id="isolating-redux-sub-apps">Isolating Redux Sub-Apps</h1>
<p>Consider the case of a “big” app (contained in a <code>&lt;BigApp&gt;</code> component) that embeds smaller “sub-apps” (contained in <code>&lt;SubApp&gt;</code> components):</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb99-1" title="1"><span class="im">import</span> React<span class="op">,</span> <span class="op">{</span> Component <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb99-2" title="2"><span class="im">import</span> SubApp <span class="im">from</span> <span class="st">&quot;./subapp&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb99-3" title="3"></a>
<a class="sourceLine" id="cb99-4" title="4"><span class="kw">class</span> BigApp <span class="kw">extends</span> Component <span class="op">{</span></a>
<a class="sourceLine" id="cb99-5" title="5">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb99-6" title="6">    <span class="cf">return</span> (</a>
<a class="sourceLine" id="cb99-7" title="7">      <span class="op">&lt;</span>div<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb99-8" title="8">        <span class="op">&lt;</span>SubApp /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb99-9" title="9">        <span class="op">&lt;</span>SubApp /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb99-10" title="10">        <span class="op">&lt;</span>SubApp /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb99-11" title="11">      &lt;/div<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb99-12" title="12">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb99-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb99-14" title="14"><span class="op">}</span></a></code></pre></div>
<p>These <code>&lt;SubApp&gt;</code>s will be completely independent. They won’t share data or actions, and won’t see or communicate with each other.</p>
<p>It’s best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For “product hubs”, “dashboards”, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.</p>
<p>The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing “app shell”.</p>
<p>Below is a sub-app’s root connected component. As usual, it can render more components, connected or not, as children. Usually we’d render it in <code>&lt;Provider&gt;</code> and be done with it.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb100-1" title="1"><span class="kw">class</span> App <span class="kw">extends</span> Component <span class="op">{</span> ... <span class="op">}</span></a>
<a class="sourceLine" id="cb100-2" title="2"><span class="im">export</span> <span class="im">default</span> <span class="at">connect</span>(mapStateToProps)(App)</a></code></pre></div>
<p>However, we don’t have to call <code>ReactDOM.render(&lt;Provider&gt;&lt;App /&gt;&lt;/Provider&gt;)</code> if we’re interested in hiding the fact that the sub-app component is a Redux app.</p>
<p>Maybe we want to be able to run multiple instances of it in the same “bigger” app and keep it as a complete black box, with Redux being an implementation detail.</p>
<p>To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb101-1" title="1"><span class="im">import</span> React<span class="op">,</span> <span class="op">{</span> Component <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb101-2" title="2"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb101-3" title="3"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb101-4" title="4"><span class="im">import</span> reducer <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb101-5" title="5"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb101-6" title="6"></a>
<a class="sourceLine" id="cb101-7" title="7"><span class="kw">class</span> SubApp <span class="kw">extends</span> Component <span class="op">{</span></a>
<a class="sourceLine" id="cb101-8" title="8">  <span class="at">constructor</span>(props) <span class="op">{</span></a>
<a class="sourceLine" id="cb101-9" title="9">    <span class="kw">super</span>(props)<span class="op">;</span></a>
<a class="sourceLine" id="cb101-10" title="10">    <span class="kw">this</span>.<span class="at">store</span> <span class="op">=</span> <span class="at">createStore</span>(reducer)<span class="op">;</span></a>
<a class="sourceLine" id="cb101-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb101-12" title="12"></a>
<a class="sourceLine" id="cb101-13" title="13">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb101-14" title="14">    <span class="cf">return</span> (</a>
<a class="sourceLine" id="cb101-15" title="15">      <span class="op">&lt;</span>Provider store<span class="op">={</span><span class="kw">this</span>.<span class="at">store</span><span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb101-16" title="16">        <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb101-17" title="17">      &lt;/Provider<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb101-18" title="18">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb101-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb101-20" title="20"><span class="op">}</span></a></code></pre></div>
<p>This way every instance will be independent.</p>
<p>This pattern is <em>not</em> recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps’ internals, and we’d like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won’t “know” about each other.</p>
<hr />
<p>id: migrating-to-redux title: Migrating to Redux</p>
<hr />
<h1 id="migrating-to-redux">Migrating to Redux</h1>
<p>Redux is not a monolithic framework, but a set of contracts and a <a href="../api/README.md">few functions that make them work together</a>. The majority of your “Redux code” will not even use Redux APIs, as most of the time you’ll be writing functions.</p>
<p>This makes it easy to migrate both to and from Redux. We don’t want to lock you in!</p>
<h2 id="from-flux">From Flux</h2>
<p><a href="../understanding/thinking-in-redux/Glossary.md#reducer">Reducers</a> capture “the essence” of Flux Stores, so it’s possible to gradually migrate an existing Flux project towards Redux, whether you are using <a href="https://github.com/acdlite/flummox">Flummox</a>, <a href="http://github.com/goatslacker/alt">Alt</a>, <a href="https://github.com/facebook/flux">traditional Flux</a>, or any other Flux library.</p>
<p>Your process will look like this:</p>
<ul>
<li><p>Create a function called <code>createFluxStore(reducer)</code> that creates a Flux store compatible with your existing app from a reducer function. Internally it might look similar to <a href="../api/createStore.md"><code>createStore</code></a> (<a href="https://github.com/reduxjs/redux/blob/v4.0.5/src/createStore.js">source</a>) implementation from Redux. Its dispatch handler should just call the <code>reducer</code> for any action, store the next state, and emit change.</p></li>
<li><p>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export <code>createFluxStore(reducer)</code> so the rest of your app is not aware that this is happening and sees the Flux stores.</p></li>
<li><p>As you rewrite your Stores, you will find that you need to avoid certain Flux anti-patterns such as fetching API inside the Store, or triggering actions inside the Stores. Your Flux code will be easier to follow once you port it to be based on reducers!</p></li>
<li><p>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using <a href="../api/combineReducers.md"><code>combineReducers(reducers)</code></a>.</p></li>
<li><p>Now all that’s left to do is to port the UI to <a href="../tutorials/fundamentals/part-5-ui-and-react.md">use React-Redux</a> or equivalent.</p></li>
<li><p>Finally, you might want to begin using some Redux idioms like middleware to further simplify your asynchronous code.</p></li>
</ul>
<h2 id="from-backbone">From Backbone</h2>
<p>Backbone’s model layer is quite different from Redux, so we don’t suggest mixing them. If possible, it is best that you rewrite your app’s model layer from scratch instead of connecting Backbone to Redux. However, if a rewrite is not feasible, you may use <a href="https://github.com/redbooth/backbone-redux">backbone-redux</a> to migrate gradually, and keep the Redux store in sync with Backbone models and collections.</p>
<p>If your Backbone codebase is too big for a quick rewrite or you don’t want to manage interactions between store and models, use <a href="https://github.com/naugtur/backbone-redux-migrator">backbone-redux-migrator</a> to help your two codebases coexist while keeping healthy separation. Once your rewrite finishes, Backbone code can be discarded and your Redux application can work on its own once you configure router.</p>
<hr />
<p>id: reducing-boilerplate title: Reducing Boilerplate</p>
<hr />
<h1 id="reducing-boilerplate">Reducing Boilerplate</h1>
<p>Redux is in part <a href="../understanding/history-and-design/PriorArt.md">inspired by Flux</a>, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we’d like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</p>
<h2 id="actions-1">Actions</h2>
<p>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It’s important that <strong>actions being objects you have to dispatch is not boilerplate, but one of the <a href="../understanding/thinking-in-redux/ThreePrinciples.md">fundamental design choices</a> of Redux</strong>.</p>
<p>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">hot reloading with time travel</a>. If you’d rather modify data directly, you don’t need Redux.</p>
<p>Actions look like this:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb102-1" title="1"><span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;ADD_TODO&#39;</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Use Redux&#39;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb102-2" title="2"><span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;REMOVE_TODO&#39;</span><span class="op">,</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">42</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb102-3" title="3"><span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;LOAD_ARTICLE&#39;</span><span class="op">,</span> <span class="dt">response</span><span class="op">:</span> <span class="op">{</span> ... <span class="op">}</span> <span class="op">}</span></a></code></pre></div>
<p>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbols</a> for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</p>
<p>In Flux, it is traditionally thought that you would define every action type as a string constant:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb103-1" title="1"><span class="kw">const</span> ADD_TODO <span class="op">=</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb103-2" title="2"><span class="kw">const</span> REMOVE_TODO <span class="op">=</span> <span class="st">&quot;REMOVE_TODO&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb103-3" title="3"><span class="kw">const</span> LOAD_ARTICLE <span class="op">=</span> <span class="st">&quot;LOAD_ARTICLE&quot;</span><span class="op">;</span></a></code></pre></div>
<p>Why is this beneficial? <strong>It is often claimed that constants are unnecessary, and for small projects, this might be correct.</strong> For larger projects, there are some benefits to defining action types as constants:</p>
<ul>
<li>It helps keep the naming consistent because all action types are gathered in a single place.</li>
<li>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn’t know.</li>
<li>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</li>
<li>If you make a typo when importing an action constant, you will get <code>undefined</code>. Redux will immediately throw when dispatching such an action, and you’ll find the mistake sooner.</li>
</ul>
<p>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</p>
<h2 id="action-creators">Action Creators</h2>
<p>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</p>
<p>For example, instead of calling <code>dispatch</code> with an object literal:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb104-1" title="1"><span class="co">// somewhere in an event handler</span></a>
<a class="sourceLine" id="cb104-2" title="2"><span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb104-3" title="3">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb104-4" title="4">  <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Use Redux&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb104-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>You might write an action creator in a separate file, and import it into your component:</p>
<h4 id="actioncreators.js"><code>actionCreators.js</code></h4>
<div class="sourceCode" id="cb105"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb105-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">addTodo</span>(text) <span class="op">{</span></a>
<a class="sourceLine" id="cb105-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb105-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb105-4" title="4">    text<span class="op">,</span></a>
<a class="sourceLine" id="cb105-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb105-6" title="6"><span class="op">}</span></a></code></pre></div>
<h4 id="addtodo.js"><code>AddTodo.js</code></h4>
<div class="sourceCode" id="cb106"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb106-1" title="1"><span class="im">import</span> <span class="op">{</span> addTodo <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./actionCreators&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb106-2" title="2"></a>
<a class="sourceLine" id="cb106-3" title="3"><span class="co">// somewhere in an event handler</span></a>
<a class="sourceLine" id="cb106-4" title="4"><span class="at">dispatch</span>(<span class="at">addTodo</span>(<span class="st">&quot;Use Redux&quot;</span>))<span class="op">;</span></a></code></pre></div>
<p>Action creators have often been criticized as boilerplate. Well, you don’t have to write them! <strong>You can use object literals if you feel this better suits your project.</strong> There are, however, some benefits for writing action creators you should know about.</p>
<p>Let’s say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with <a href="https://github.com/gaearon/redux-thunk">redux-thunk</a> middleware and adding an early exit:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb107-1" title="1"><span class="kw">function</span> <span class="at">addTodoWithoutCheck</span>(text) <span class="op">{</span></a>
<a class="sourceLine" id="cb107-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb107-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb107-4" title="4">    text<span class="op">,</span></a>
<a class="sourceLine" id="cb107-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb107-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb107-7" title="7"></a>
<a class="sourceLine" id="cb107-8" title="8"><span class="im">export</span> <span class="kw">function</span> <span class="at">addTodo</span>(text) <span class="op">{</span></a>
<a class="sourceLine" id="cb107-9" title="9">  <span class="co">// This form is allowed by Redux Thunk middleware</span></a>
<a class="sourceLine" id="cb107-10" title="10">  <span class="co">// described below in “Async Action Creators” section.</span></a>
<a class="sourceLine" id="cb107-11" title="11">  <span class="cf">return</span> <span class="kw">function</span> (dispatch<span class="op">,</span> getState) <span class="op">{</span></a>
<a class="sourceLine" id="cb107-12" title="12">    <span class="cf">if</span> (<span class="at">getState</span>().<span class="va">todos</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">3</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb107-13" title="13">      <span class="co">// Exit early</span></a>
<a class="sourceLine" id="cb107-14" title="14">      <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb107-15" title="15">    <span class="op">}</span></a>
<a class="sourceLine" id="cb107-16" title="16">    <span class="at">dispatch</span>(<span class="at">addTodoWithoutCheck</span>(text))<span class="op">;</span></a>
<a class="sourceLine" id="cb107-17" title="17">  <span class="op">};</span></a>
<a class="sourceLine" id="cb107-18" title="18"><span class="op">}</span></a></code></pre></div>
<p>We just modified how the <code>addTodo</code> action creator behaves, completely invisible to the calling code. <strong>We don’t have to worry about looking at each place where todos are being added, to make sure they have this check.</strong> Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It’s very handy when the application is under heavy development, and the requirements change often.</p>
<h3 id="generating-action-creators">Generating Action Creators</h3>
<p>Some frameworks like <a href="https://github.com/acdlite/flummox">Flummox</a> generate action type constants automatically from the action creator function definitions. The idea is that you don’t need to both define <code>ADD_TODO</code> constant and <code>addTodo()</code> action creator. Under the hood, such solutions still generate action type constants, but they’re created implicitly so it’s a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</p>
<p>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb108-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">addTodo</span>(text) <span class="op">{</span></a>
<a class="sourceLine" id="cb108-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb108-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb108-4" title="4">    text<span class="op">,</span></a>
<a class="sourceLine" id="cb108-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb108-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb108-7" title="7"></a>
<a class="sourceLine" id="cb108-8" title="8"><span class="im">export</span> <span class="kw">function</span> <span class="at">editTodo</span>(id<span class="op">,</span> text) <span class="op">{</span></a>
<a class="sourceLine" id="cb108-9" title="9">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb108-10" title="10">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;EDIT_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb108-11" title="11">    id<span class="op">,</span></a>
<a class="sourceLine" id="cb108-12" title="12">    text<span class="op">,</span></a>
<a class="sourceLine" id="cb108-13" title="13">  <span class="op">};</span></a>
<a class="sourceLine" id="cb108-14" title="14"><span class="op">}</span></a>
<a class="sourceLine" id="cb108-15" title="15"></a>
<a class="sourceLine" id="cb108-16" title="16"><span class="im">export</span> <span class="kw">function</span> <span class="at">removeTodo</span>(id) <span class="op">{</span></a>
<a class="sourceLine" id="cb108-17" title="17">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb108-18" title="18">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;REMOVE_TODO&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb108-19" title="19">    id<span class="op">,</span></a>
<a class="sourceLine" id="cb108-20" title="20">  <span class="op">};</span></a>
<a class="sourceLine" id="cb108-21" title="21"><span class="op">}</span></a></code></pre></div>
<p>You can always write a function that generates an action creator:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb109-1" title="1"><span class="kw">function</span> <span class="at">makeActionCreator</span>(type<span class="op">,</span> ...<span class="at">argNames</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb109-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> (...<span class="at">args</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb109-3" title="3">    <span class="kw">const</span> action <span class="op">=</span> <span class="op">{</span> type <span class="op">};</span></a>
<a class="sourceLine" id="cb109-4" title="4">    <span class="va">argNames</span>.<span class="at">forEach</span>((arg<span class="op">,</span> index) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb109-5" title="5">      action[argNames[index]] <span class="op">=</span> args[index]<span class="op">;</span></a>
<a class="sourceLine" id="cb109-6" title="6">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb109-7" title="7">    <span class="cf">return</span> action<span class="op">;</span></a>
<a class="sourceLine" id="cb109-8" title="8">  <span class="op">};</span></a>
<a class="sourceLine" id="cb109-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb109-10" title="10"></a>
<a class="sourceLine" id="cb109-11" title="11"><span class="kw">const</span> ADD_TODO <span class="op">=</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb109-12" title="12"><span class="kw">const</span> EDIT_TODO <span class="op">=</span> <span class="st">&quot;EDIT_TODO&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb109-13" title="13"><span class="kw">const</span> REMOVE_TODO <span class="op">=</span> <span class="st">&quot;REMOVE_TODO&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb109-14" title="14"></a>
<a class="sourceLine" id="cb109-15" title="15"><span class="im">export</span> <span class="kw">const</span> addTodo <span class="op">=</span> <span class="at">makeActionCreator</span>(ADD_TODO<span class="op">,</span> <span class="st">&quot;text&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb109-16" title="16"><span class="im">export</span> <span class="kw">const</span> editTodo <span class="op">=</span> <span class="at">makeActionCreator</span>(EDIT_TODO<span class="op">,</span> <span class="st">&quot;id&quot;</span><span class="op">,</span> <span class="st">&quot;text&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb109-17" title="17"><span class="im">export</span> <span class="kw">const</span> removeTodo <span class="op">=</span> <span class="at">makeActionCreator</span>(REMOVE_TODO<span class="op">,</span> <span class="st">&quot;id&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>There are also utility libraries to aid in generating action creators, such as <a href="https://github.com/pauldijou/redux-act">redux-act</a> and <a href="https://github.com/acdlite/redux-actions">redux-actions</a>. These can help reduce boilerplate code and enforce adherence to standards such as <a href="https://github.com/acdlite/flux-standard-action">Flux Standard Action (FSA)</a>.</p>
<h2 id="async-action-creators">Async Action Creators</h2>
<p><a href="../understanding/thinking-in-redux/Glossary.md#middleware">Middleware</a> lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</p>
<p>Without any middleware, <a href="../api/Store.md#dispatchaction"><code>dispatch</code></a> only accepts a plain object, so we have to perform AJAX calls inside our components:</p>
<h4 id="actioncreators.js-1"><code>actionCreators.js</code></h4>
<div class="sourceCode" id="cb110"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb110-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadPostsSuccess</span>(userId<span class="op">,</span> response) <span class="op">{</span></a>
<a class="sourceLine" id="cb110-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb110-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;LOAD_POSTS_SUCCESS&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb110-4" title="4">    userId<span class="op">,</span></a>
<a class="sourceLine" id="cb110-5" title="5">    response<span class="op">,</span></a>
<a class="sourceLine" id="cb110-6" title="6">  <span class="op">};</span></a>
<a class="sourceLine" id="cb110-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb110-8" title="8"></a>
<a class="sourceLine" id="cb110-9" title="9"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadPostsFailure</span>(userId<span class="op">,</span> error) <span class="op">{</span></a>
<a class="sourceLine" id="cb110-10" title="10">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb110-11" title="11">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;LOAD_POSTS_FAILURE&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb110-12" title="12">    userId<span class="op">,</span></a>
<a class="sourceLine" id="cb110-13" title="13">    error<span class="op">,</span></a>
<a class="sourceLine" id="cb110-14" title="14">  <span class="op">};</span></a>
<a class="sourceLine" id="cb110-15" title="15"><span class="op">}</span></a>
<a class="sourceLine" id="cb110-16" title="16"></a>
<a class="sourceLine" id="cb110-17" title="17"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadPostsRequest</span>(userId) <span class="op">{</span></a>
<a class="sourceLine" id="cb110-18" title="18">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb110-19" title="19">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;LOAD_POSTS_REQUEST&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb110-20" title="20">    userId<span class="op">,</span></a>
<a class="sourceLine" id="cb110-21" title="21">  <span class="op">};</span></a>
<a class="sourceLine" id="cb110-22" title="22"><span class="op">}</span></a></code></pre></div>
<h4 id="userinfo.js"><code>UserInfo.js</code></h4>
<div class="sourceCode" id="cb111"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb111-1" title="1"><span class="im">import</span> <span class="op">{</span> Component <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-2" title="2"><span class="im">import</span> <span class="op">{</span> connect <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-3" title="3"><span class="im">import</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb111-4" title="4">  loadPostsRequest<span class="op">,</span></a>
<a class="sourceLine" id="cb111-5" title="5">  loadPostsSuccess<span class="op">,</span></a>
<a class="sourceLine" id="cb111-6" title="6">  loadPostsFailure<span class="op">,</span></a>
<a class="sourceLine" id="cb111-7" title="7"><span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./actionCreators&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-8" title="8"></a>
<a class="sourceLine" id="cb111-9" title="9"><span class="kw">class</span> Posts <span class="kw">extends</span> Component <span class="op">{</span></a>
<a class="sourceLine" id="cb111-10" title="10">  <span class="at">loadData</span>(userId) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-11" title="11">    <span class="co">// Injected into props by React Redux `connect()` call:</span></a>
<a class="sourceLine" id="cb111-12" title="12">    <span class="kw">const</span> <span class="op">{</span> dispatch<span class="op">,</span> posts <span class="op">}</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">props</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-13" title="13"></a>
<a class="sourceLine" id="cb111-14" title="14">    <span class="cf">if</span> (posts[userId]) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-15" title="15">      <span class="co">// There is cached data! Don&#39;t do anything.</span></a>
<a class="sourceLine" id="cb111-16" title="16">      <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb111-18" title="18"></a>
<a class="sourceLine" id="cb111-19" title="19">    <span class="co">// Reducer can react to this action by setting</span></a>
<a class="sourceLine" id="cb111-20" title="20">    <span class="co">// `isFetching` and thus letting us show a spinner.</span></a>
<a class="sourceLine" id="cb111-21" title="21">    <span class="at">dispatch</span>(<span class="at">loadPostsRequest</span>(userId))<span class="op">;</span></a>
<a class="sourceLine" id="cb111-22" title="22"></a>
<a class="sourceLine" id="cb111-23" title="23">    <span class="co">// Reducer can react to these actions by filling the `users`.</span></a>
<a class="sourceLine" id="cb111-24" title="24">    <span class="at">fetch</span>(<span class="vs">`http://myapi.com/users/</span><span class="sc">${</span>userId<span class="sc">}</span><span class="vs">/posts`</span>).<span class="at">then</span>(</a>
<a class="sourceLine" id="cb111-25" title="25">      (response) <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="at">loadPostsSuccess</span>(userId<span class="op">,</span> response))<span class="op">,</span></a>
<a class="sourceLine" id="cb111-26" title="26">      (error) <span class="kw">=&gt;</span> <span class="at">dispatch</span>(<span class="at">loadPostsFailure</span>(userId<span class="op">,</span> error))</a>
<a class="sourceLine" id="cb111-27" title="27">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb111-28" title="28">  <span class="op">}</span></a>
<a class="sourceLine" id="cb111-29" title="29"></a>
<a class="sourceLine" id="cb111-30" title="30">  <span class="at">componentDidMount</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb111-31" title="31">    <span class="kw">this</span>.<span class="at">loadData</span>(<span class="kw">this</span>.<span class="va">props</span>.<span class="at">userId</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb111-32" title="32">  <span class="op">}</span></a>
<a class="sourceLine" id="cb111-33" title="33"></a>
<a class="sourceLine" id="cb111-34" title="34">  <span class="at">componentDidUpdate</span>(prevProps) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-35" title="35">    <span class="cf">if</span> (<span class="va">prevProps</span>.<span class="at">userId</span> <span class="op">!==</span> <span class="kw">this</span>.<span class="va">props</span>.<span class="at">userId</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-36" title="36">      <span class="kw">this</span>.<span class="at">loadData</span>(<span class="kw">this</span>.<span class="va">props</span>.<span class="at">userId</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb111-37" title="37">    <span class="op">}</span></a>
<a class="sourceLine" id="cb111-38" title="38">  <span class="op">}</span></a>
<a class="sourceLine" id="cb111-39" title="39"></a>
<a class="sourceLine" id="cb111-40" title="40">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb111-41" title="41">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="va">props</span>.<span class="at">isFetching</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-42" title="42">      <span class="cf">return</span> <span class="op">&lt;</span>p<span class="op">&gt;</span><span class="va">Loading</span>...&lt;/p<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb111-43" title="43">    <span class="op">}</span></a>
<a class="sourceLine" id="cb111-44" title="44"></a>
<a class="sourceLine" id="cb111-45" title="45">    <span class="kw">const</span> posts <span class="op">=</span> <span class="kw">this</span>.<span class="va">props</span>.<span class="va">posts</span>.<span class="at">map</span>((post) <span class="kw">=&gt;</span> (</a>
<a class="sourceLine" id="cb111-46" title="46">      <span class="op">&lt;</span>Post post<span class="op">={</span>post<span class="op">}</span> key<span class="op">={</span><span class="va">post</span>.<span class="at">id</span><span class="op">}</span> /&gt;</a>
<a class="sourceLine" id="cb111-47" title="47">    ))<span class="op">;</span></a>
<a class="sourceLine" id="cb111-48" title="48"></a>
<a class="sourceLine" id="cb111-49" title="49">    <span class="cf">return</span> <span class="op">&lt;</span>div<span class="op">&gt;{</span>posts<span class="op">}</span>&lt;/div<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb111-50" title="50">  <span class="op">}</span></a>
<a class="sourceLine" id="cb111-51" title="51"><span class="op">}</span></a>
<a class="sourceLine" id="cb111-52" title="52"></a>
<a class="sourceLine" id="cb111-53" title="53"><span class="im">export</span> <span class="im">default</span> <span class="at">connect</span>((state) <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb111-54" title="54">  <span class="dt">posts</span><span class="op">:</span> <span class="va">state</span>.<span class="at">posts</span><span class="op">,</span></a>
<a class="sourceLine" id="cb111-55" title="55">  <span class="dt">isFetching</span><span class="op">:</span> <span class="va">state</span>.<span class="at">isFetching</span><span class="op">,</span></a>
<a class="sourceLine" id="cb111-56" title="56"><span class="op">}</span>))(Posts)<span class="op">;</span></a></code></pre></div>
<p>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</p>
<p><strong>Middleware lets us write more expressive, potentially async action creators.</strong> It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.</p>
<p>The simplest example of middleware is <a href="https://github.com/gaearon/redux-thunk">redux-thunk</a>. <strong>“Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions.</strong> This inverts the control: you will get <code>dispatch</code> as an argument, so you can write an action creator that dispatches many times.</p>
<blockquote>
<h5 id="note">Note</h5>
<p>Thunk middleware is just one example of middleware. Middleware is not about “letting you dispatch functions”. It’s about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</p>
</blockquote>
<p>Consider the code above rewritten with <a href="https://github.com/gaearon/redux-thunk">redux-thunk</a>:</p>
<h4 id="actioncreators.js-2"><code>actionCreators.js</code></h4>
<div class="sourceCode" id="cb112"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb112-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadPosts</span>(userId) <span class="op">{</span></a>
<a class="sourceLine" id="cb112-2" title="2">  <span class="co">// Interpreted by the thunk middleware:</span></a>
<a class="sourceLine" id="cb112-3" title="3">  <span class="cf">return</span> <span class="kw">function</span> (dispatch<span class="op">,</span> getState) <span class="op">{</span></a>
<a class="sourceLine" id="cb112-4" title="4">    <span class="kw">const</span> <span class="op">{</span> posts <span class="op">}</span> <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb112-5" title="5">    <span class="cf">if</span> (posts[userId]) <span class="op">{</span></a>
<a class="sourceLine" id="cb112-6" title="6">      <span class="co">// There is cached data! Don&#39;t do anything.</span></a>
<a class="sourceLine" id="cb112-7" title="7">      <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb112-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb112-9" title="9"></a>
<a class="sourceLine" id="cb112-10" title="10">    <span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb112-11" title="11">      <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;LOAD_POSTS_REQUEST&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb112-12" title="12">      userId<span class="op">,</span></a>
<a class="sourceLine" id="cb112-13" title="13">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb112-14" title="14"></a>
<a class="sourceLine" id="cb112-15" title="15">    <span class="co">// Dispatch vanilla actions asynchronously</span></a>
<a class="sourceLine" id="cb112-16" title="16">    <span class="at">fetch</span>(<span class="vs">`http://myapi.com/users/</span><span class="sc">${</span>userId<span class="sc">}</span><span class="vs">/posts`</span>).<span class="at">then</span>(</a>
<a class="sourceLine" id="cb112-17" title="17">      (response) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb112-18" title="18">        <span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb112-19" title="19">          <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;LOAD_POSTS_SUCCESS&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb112-20" title="20">          userId<span class="op">,</span></a>
<a class="sourceLine" id="cb112-21" title="21">          response<span class="op">,</span></a>
<a class="sourceLine" id="cb112-22" title="22">        <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb112-23" title="23">      (error) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb112-24" title="24">        <span class="at">dispatch</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb112-25" title="25">          <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;LOAD_POSTS_FAILURE&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb112-26" title="26">          userId<span class="op">,</span></a>
<a class="sourceLine" id="cb112-27" title="27">          error<span class="op">,</span></a>
<a class="sourceLine" id="cb112-28" title="28">        <span class="op">}</span>)</a>
<a class="sourceLine" id="cb112-29" title="29">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb112-30" title="30">  <span class="op">};</span></a>
<a class="sourceLine" id="cb112-31" title="31"><span class="op">}</span></a></code></pre></div>
<h4 id="userinfo.js-1"><code>UserInfo.js</code></h4>
<div class="sourceCode" id="cb113"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb113-1" title="1"><span class="im">import</span> <span class="op">{</span> Component <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb113-2" title="2"><span class="im">import</span> <span class="op">{</span> connect <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb113-3" title="3"><span class="im">import</span> <span class="op">{</span> loadPosts <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./actionCreators&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb113-4" title="4"></a>
<a class="sourceLine" id="cb113-5" title="5"><span class="kw">class</span> Posts <span class="kw">extends</span> Component <span class="op">{</span></a>
<a class="sourceLine" id="cb113-6" title="6">  <span class="at">componentDidMount</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb113-7" title="7">    <span class="kw">this</span>.<span class="va">props</span>.<span class="at">dispatch</span>(<span class="at">loadPosts</span>(<span class="kw">this</span>.<span class="va">props</span>.<span class="at">userId</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb113-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb113-9" title="9"></a>
<a class="sourceLine" id="cb113-10" title="10">  <span class="at">componentDidUpdate</span>(prevProps) <span class="op">{</span></a>
<a class="sourceLine" id="cb113-11" title="11">    <span class="cf">if</span> (<span class="va">prevProps</span>.<span class="at">userId</span> <span class="op">!==</span> <span class="kw">this</span>.<span class="va">props</span>.<span class="at">userId</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb113-12" title="12">      <span class="kw">this</span>.<span class="va">props</span>.<span class="at">dispatch</span>(<span class="at">loadPosts</span>(<span class="kw">this</span>.<span class="va">props</span>.<span class="at">userId</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb113-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb113-14" title="14">  <span class="op">}</span></a>
<a class="sourceLine" id="cb113-15" title="15"></a>
<a class="sourceLine" id="cb113-16" title="16">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb113-17" title="17">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="va">props</span>.<span class="at">isFetching</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb113-18" title="18">      <span class="cf">return</span> <span class="op">&lt;</span>p<span class="op">&gt;</span><span class="va">Loading</span>...&lt;/p<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb113-19" title="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb113-20" title="20"></a>
<a class="sourceLine" id="cb113-21" title="21">    <span class="kw">const</span> posts <span class="op">=</span> <span class="kw">this</span>.<span class="va">props</span>.<span class="va">posts</span>.<span class="at">map</span>((post) <span class="kw">=&gt;</span> (</a>
<a class="sourceLine" id="cb113-22" title="22">      <span class="op">&lt;</span>Post post<span class="op">={</span>post<span class="op">}</span> key<span class="op">={</span><span class="va">post</span>.<span class="at">id</span><span class="op">}</span> /&gt;</a>
<a class="sourceLine" id="cb113-23" title="23">    ))<span class="op">;</span></a>
<a class="sourceLine" id="cb113-24" title="24"></a>
<a class="sourceLine" id="cb113-25" title="25">    <span class="cf">return</span> <span class="op">&lt;</span>div<span class="op">&gt;{</span>posts<span class="op">}</span>&lt;/div<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb113-26" title="26">  <span class="op">}</span></a>
<a class="sourceLine" id="cb113-27" title="27"><span class="op">}</span></a>
<a class="sourceLine" id="cb113-28" title="28"></a>
<a class="sourceLine" id="cb113-29" title="29"><span class="im">export</span> <span class="im">default</span> <span class="at">connect</span>((state) <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb113-30" title="30">  <span class="dt">posts</span><span class="op">:</span> <span class="va">state</span>.<span class="at">posts</span><span class="op">,</span></a>
<a class="sourceLine" id="cb113-31" title="31">  <span class="dt">isFetching</span><span class="op">:</span> <span class="va">state</span>.<span class="at">isFetching</span><span class="op">,</span></a>
<a class="sourceLine" id="cb113-32" title="32"><span class="op">}</span>))(Posts)<span class="op">;</span></a></code></pre></div>
<p>This is much less typing! If you’d like, you can still have “vanilla” action creators like <code>loadPostsSuccess</code> which you’d use from a container <code>loadPosts</code> action creator.</p>
<p><strong>Finally, you can write your own middleware.</strong> Let’s say you want to generalize the pattern above and describe your async action creators like this instead:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb114-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadPosts</span>(userId) <span class="op">{</span></a>
<a class="sourceLine" id="cb114-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb114-3" title="3">    <span class="co">// Types of actions to emit before and after</span></a>
<a class="sourceLine" id="cb114-4" title="4">    <span class="dt">types</span><span class="op">:</span> [<span class="st">&quot;LOAD_POSTS_REQUEST&quot;</span><span class="op">,</span> <span class="st">&quot;LOAD_POSTS_SUCCESS&quot;</span><span class="op">,</span> <span class="st">&quot;LOAD_POSTS_FAILURE&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb114-5" title="5">    <span class="co">// Check the cache (optional):</span></a>
<a class="sourceLine" id="cb114-6" title="6">    <span class="dt">shouldCallAPI</span><span class="op">:</span> (state) <span class="kw">=&gt;</span> <span class="op">!</span><span class="va">state</span>.<span class="at">posts</span>[userId]<span class="op">,</span></a>
<a class="sourceLine" id="cb114-7" title="7">    <span class="co">// Perform the fetching:</span></a>
<a class="sourceLine" id="cb114-8" title="8">    <span class="dt">callAPI</span><span class="op">:</span> () <span class="kw">=&gt;</span> <span class="at">fetch</span>(<span class="vs">`http://myapi.com/users/</span><span class="sc">${</span>userId<span class="sc">}</span><span class="vs">/posts`</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb114-9" title="9">    <span class="co">// Arguments to inject in begin/end actions</span></a>
<a class="sourceLine" id="cb114-10" title="10">    <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> userId <span class="op">},</span></a>
<a class="sourceLine" id="cb114-11" title="11">  <span class="op">};</span></a>
<a class="sourceLine" id="cb114-12" title="12"><span class="op">}</span></a></code></pre></div>
<p>The middleware that interprets such actions could look like this:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb115-1" title="1"><span class="kw">function</span> <span class="at">callAPIMiddleware</span>(<span class="op">{</span> dispatch<span class="op">,</span> getState <span class="op">}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb115-2" title="2">  <span class="cf">return</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb115-3" title="3">    <span class="kw">const</span> <span class="op">{</span> types<span class="op">,</span> callAPI<span class="op">,</span> shouldCallAPI <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="kw">true</span><span class="op">,</span> payload <span class="op">=</span> <span class="op">{}</span> <span class="op">}</span> <span class="op">=</span> action<span class="op">;</span></a>
<a class="sourceLine" id="cb115-4" title="4"></a>
<a class="sourceLine" id="cb115-5" title="5">    <span class="cf">if</span> (<span class="op">!</span>types) <span class="op">{</span></a>
<a class="sourceLine" id="cb115-6" title="6">      <span class="co">// Normal action: pass it on</span></a>
<a class="sourceLine" id="cb115-7" title="7">      <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb115-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb115-9" title="9"></a>
<a class="sourceLine" id="cb115-10" title="10">    <span class="cf">if</span> (</a>
<a class="sourceLine" id="cb115-11" title="11">      <span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(types) <span class="op">||</span></a>
<a class="sourceLine" id="cb115-12" title="12">      <span class="va">types</span>.<span class="at">length</span> <span class="op">!==</span> <span class="dv">3</span> <span class="op">||</span></a>
<a class="sourceLine" id="cb115-13" title="13">      <span class="op">!</span><span class="va">types</span>.<span class="at">every</span>((type) <span class="kw">=&gt;</span> <span class="kw">typeof</span> type <span class="op">===</span> <span class="st">&quot;string&quot;</span>)</a>
<a class="sourceLine" id="cb115-14" title="14">    ) <span class="op">{</span></a>
<a class="sourceLine" id="cb115-15" title="15">      <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;Expected an array of three string types.&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb115-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb115-17" title="17"></a>
<a class="sourceLine" id="cb115-18" title="18">    <span class="cf">if</span> (<span class="kw">typeof</span> callAPI <span class="op">!==</span> <span class="st">&quot;function&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb115-19" title="19">      <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;Expected callAPI to be a function.&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb115-20" title="20">    <span class="op">}</span></a>
<a class="sourceLine" id="cb115-21" title="21"></a>
<a class="sourceLine" id="cb115-22" title="22">    <span class="cf">if</span> (<span class="op">!</span><span class="at">shouldCallAPI</span>(<span class="at">getState</span>())) <span class="op">{</span></a>
<a class="sourceLine" id="cb115-23" title="23">      <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb115-24" title="24">    <span class="op">}</span></a>
<a class="sourceLine" id="cb115-25" title="25"></a>
<a class="sourceLine" id="cb115-26" title="26">    <span class="kw">const</span> [requestType<span class="op">,</span> successType<span class="op">,</span> failureType] <span class="op">=</span> types<span class="op">;</span></a>
<a class="sourceLine" id="cb115-27" title="27"></a>
<a class="sourceLine" id="cb115-28" title="28">    <span class="at">dispatch</span>(</a>
<a class="sourceLine" id="cb115-29" title="29">      <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> payload<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb115-30" title="30">        <span class="dt">type</span><span class="op">:</span> requestType<span class="op">,</span></a>
<a class="sourceLine" id="cb115-31" title="31">      <span class="op">}</span>)</a>
<a class="sourceLine" id="cb115-32" title="32">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb115-33" title="33"></a>
<a class="sourceLine" id="cb115-34" title="34">    <span class="cf">return</span> <span class="at">callAPI</span>().<span class="at">then</span>(</a>
<a class="sourceLine" id="cb115-35" title="35">      (response) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb115-36" title="36">        <span class="at">dispatch</span>(</a>
<a class="sourceLine" id="cb115-37" title="37">          <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> payload<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb115-38" title="38">            response<span class="op">,</span></a>
<a class="sourceLine" id="cb115-39" title="39">            <span class="dt">type</span><span class="op">:</span> successType<span class="op">,</span></a>
<a class="sourceLine" id="cb115-40" title="40">          <span class="op">}</span>)</a>
<a class="sourceLine" id="cb115-41" title="41">        )<span class="op">,</span></a>
<a class="sourceLine" id="cb115-42" title="42">      (error) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb115-43" title="43">        <span class="at">dispatch</span>(</a>
<a class="sourceLine" id="cb115-44" title="44">          <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> payload<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb115-45" title="45">            error<span class="op">,</span></a>
<a class="sourceLine" id="cb115-46" title="46">            <span class="dt">type</span><span class="op">:</span> failureType<span class="op">,</span></a>
<a class="sourceLine" id="cb115-47" title="47">          <span class="op">}</span>)</a>
<a class="sourceLine" id="cb115-48" title="48">        )</a>
<a class="sourceLine" id="cb115-49" title="49">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb115-50" title="50">  <span class="op">};</span></a>
<a class="sourceLine" id="cb115-51" title="51"><span class="op">}</span></a></code></pre></div>
<p>After passing it once to <a href="../api/applyMiddleware.md"><code>applyMiddleware(...middlewares)</code></a>, you can write all your API-calling action creators the same way:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb116-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadPosts</span>(userId) <span class="op">{</span></a>
<a class="sourceLine" id="cb116-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb116-3" title="3">    <span class="dt">types</span><span class="op">:</span> [<span class="st">&quot;LOAD_POSTS_REQUEST&quot;</span><span class="op">,</span> <span class="st">&quot;LOAD_POSTS_SUCCESS&quot;</span><span class="op">,</span> <span class="st">&quot;LOAD_POSTS_FAILURE&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb116-4" title="4">    <span class="dt">shouldCallAPI</span><span class="op">:</span> (state) <span class="kw">=&gt;</span> <span class="op">!</span><span class="va">state</span>.<span class="at">posts</span>[userId]<span class="op">,</span></a>
<a class="sourceLine" id="cb116-5" title="5">    <span class="dt">callAPI</span><span class="op">:</span> () <span class="kw">=&gt;</span> <span class="at">fetch</span>(<span class="vs">`http://myapi.com/users/</span><span class="sc">${</span>userId<span class="sc">}</span><span class="vs">/posts`</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb116-6" title="6">    <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> userId <span class="op">},</span></a>
<a class="sourceLine" id="cb116-7" title="7">  <span class="op">};</span></a>
<a class="sourceLine" id="cb116-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb116-9" title="9"></a>
<a class="sourceLine" id="cb116-10" title="10"><span class="im">export</span> <span class="kw">function</span> <span class="at">loadComments</span>(postId) <span class="op">{</span></a>
<a class="sourceLine" id="cb116-11" title="11">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb116-12" title="12">    <span class="dt">types</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb116-13" title="13">      <span class="st">&quot;LOAD_COMMENTS_REQUEST&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-14" title="14">      <span class="st">&quot;LOAD_COMMENTS_SUCCESS&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-15" title="15">      <span class="st">&quot;LOAD_COMMENTS_FAILURE&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-16" title="16">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb116-17" title="17">    <span class="dt">shouldCallAPI</span><span class="op">:</span> (state) <span class="kw">=&gt;</span> <span class="op">!</span><span class="va">state</span>.<span class="at">comments</span>[postId]<span class="op">,</span></a>
<a class="sourceLine" id="cb116-18" title="18">    <span class="dt">callAPI</span><span class="op">:</span> () <span class="kw">=&gt;</span> <span class="at">fetch</span>(<span class="vs">`http://myapi.com/posts/</span><span class="sc">${</span>postId<span class="sc">}</span><span class="vs">/comments`</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb116-19" title="19">    <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> postId <span class="op">},</span></a>
<a class="sourceLine" id="cb116-20" title="20">  <span class="op">};</span></a>
<a class="sourceLine" id="cb116-21" title="21"><span class="op">}</span></a>
<a class="sourceLine" id="cb116-22" title="22"></a>
<a class="sourceLine" id="cb116-23" title="23"><span class="im">export</span> <span class="kw">function</span> <span class="at">addComment</span>(postId<span class="op">,</span> message) <span class="op">{</span></a>
<a class="sourceLine" id="cb116-24" title="24">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb116-25" title="25">    <span class="dt">types</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb116-26" title="26">      <span class="st">&quot;ADD_COMMENT_REQUEST&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-27" title="27">      <span class="st">&quot;ADD_COMMENT_SUCCESS&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-28" title="28">      <span class="st">&quot;ADD_COMMENT_FAILURE&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-29" title="29">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb116-30" title="30">    <span class="dt">callAPI</span><span class="op">:</span> () <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb116-31" title="31">      <span class="at">fetch</span>(<span class="vs">`http://myapi.com/posts/</span><span class="sc">${</span>postId<span class="sc">}</span><span class="vs">/comments`</span><span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb116-32" title="32">        <span class="dt">method</span><span class="op">:</span> <span class="st">&quot;post&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-33" title="33">        <span class="dt">headers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb116-34" title="34">          <span class="dt">Accept</span><span class="op">:</span> <span class="st">&quot;application/json&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-35" title="35">          <span class="st">&quot;Content-Type&quot;</span><span class="op">:</span> <span class="st">&quot;application/json&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb116-36" title="36">        <span class="op">},</span></a>
<a class="sourceLine" id="cb116-37" title="37">        <span class="dt">body</span><span class="op">:</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="op">{</span> message <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb116-38" title="38">      <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb116-39" title="39">    <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> postId<span class="op">,</span> message <span class="op">},</span></a>
<a class="sourceLine" id="cb116-40" title="40">  <span class="op">};</span></a>
<a class="sourceLine" id="cb116-41" title="41"><span class="op">}</span></a></code></pre></div>
<h2 id="reducers-2">Reducers</h2>
<p>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</p>
<p>Consider this Flux store:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb117-1" title="1"><span class="kw">const</span> _todos <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb117-2" title="2"></a>
<a class="sourceLine" id="cb117-3" title="3"><span class="kw">const</span> TodoStore <span class="op">=</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> <span class="va">EventEmitter</span>.<span class="at">prototype</span><span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb117-4" title="4">  <span class="at">getAll</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb117-5" title="5">    <span class="cf">return</span> _todos<span class="op">;</span></a>
<a class="sourceLine" id="cb117-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb117-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb117-8" title="8"></a>
<a class="sourceLine" id="cb117-9" title="9"><span class="va">AppDispatcher</span>.<span class="at">register</span>(<span class="kw">function</span> (action) <span class="op">{</span></a>
<a class="sourceLine" id="cb117-10" title="10">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb117-11" title="11">    <span class="cf">case</span> <span class="va">ActionTypes</span>.<span class="at">ADD_TODO</span><span class="op">:</span></a>
<a class="sourceLine" id="cb117-12" title="12">      <span class="kw">const</span> text <span class="op">=</span> <span class="va">action</span>.<span class="va">text</span>.<span class="at">trim</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb117-13" title="13">      <span class="va">_todos</span>.<span class="at">push</span>(text)<span class="op">;</span></a>
<a class="sourceLine" id="cb117-14" title="14">      <span class="va">TodoStore</span>.<span class="at">emitChange</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb117-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb117-16" title="16"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb117-17" title="17"></a>
<a class="sourceLine" id="cb117-18" title="18"><span class="im">export</span> <span class="im">default</span> TodoStore<span class="op">;</span></a></code></pre></div>
<p>With Redux, the same update logic can be described as a reducing function:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb118-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">todos</span>(state <span class="op">=</span> []<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb118-2" title="2">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb118-3" title="3">    <span class="cf">case</span> <span class="va">ActionTypes</span>.<span class="at">ADD_TODO</span><span class="op">:</span></a>
<a class="sourceLine" id="cb118-4" title="4">      <span class="kw">const</span> text <span class="op">=</span> <span class="va">action</span>.<span class="va">text</span>.<span class="at">trim</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb118-5" title="5">      <span class="cf">return</span> [...<span class="at">state</span><span class="op">,</span> text]<span class="op">;</span></a>
<a class="sourceLine" id="cb118-6" title="6">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb118-7" title="7">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb118-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb118-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>The <code>switch</code> statement is <em>not</em> the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</p>
<p>It’s unfortunate that many still choose Flux framework based on whether it uses <code>switch</code> statements in the documentation. If you don’t like <code>switch</code>, you can solve this with a single function, as we show below.</p>
<h3 id="generating-reducers">Generating Reducers</h3>
<p>Let’s write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our <code>todos</code> reducers to be defined like this:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb119-1" title="1"><span class="im">export</span> <span class="kw">const</span> todos <span class="op">=</span> <span class="at">createReducer</span>([]<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb119-2" title="2">  [<span class="va">ActionTypes</span>.<span class="at">ADD_TODO</span>]<span class="op">:</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb119-3" title="3">    <span class="kw">const</span> text <span class="op">=</span> <span class="va">action</span>.<span class="va">text</span>.<span class="at">trim</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb119-4" title="4">    <span class="cf">return</span> [...<span class="at">state</span><span class="op">,</span> text]<span class="op">;</span></a>
<a class="sourceLine" id="cb119-5" title="5">  <span class="op">},</span></a>
<a class="sourceLine" id="cb119-6" title="6"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>We can write the following helper to accomplish this:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb120-1" title="1"><span class="kw">function</span> <span class="at">createReducer</span>(initialState<span class="op">,</span> handlers) <span class="op">{</span></a>
<a class="sourceLine" id="cb120-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> <span class="at">reducer</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb120-3" title="3">    <span class="cf">if</span> (<span class="va">handlers</span>.<span class="at">hasOwnProperty</span>(<span class="va">action</span>.<span class="at">type</span>)) <span class="op">{</span></a>
<a class="sourceLine" id="cb120-4" title="4">      <span class="cf">return</span> handlers[<span class="va">action</span>.<span class="at">type</span>](state<span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb120-5" title="5">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb120-6" title="6">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb120-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb120-8" title="8">  <span class="op">};</span></a>
<a class="sourceLine" id="cb120-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>This wasn’t difficult, was it? Redux doesn’t provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.</p>
<p>The Redux reducer API is <code>(state, action) =&gt; newState</code>, but how you create those reducers is up to you.</p>
<hr />
<p>id: server-rendering title: Server Rendering</p>
<hr />
<h1 id="server-rendering">Server Rendering</h1>
<p>The most common use case for server-side rendering is to handle the <em>initial render</em> when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</p>
<p>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</p>
<h3 id="redux-on-the-server">Redux on the Server</h3>
<p>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won’t match the server markup, and the client would have to load the data again.</p>
<p>To send the data down to the client, we need to:</p>
<ul>
<li>create a fresh, new Redux store instance on every request;</li>
<li>optionally dispatch some actions;</li>
<li>pull the state out of store;</li>
<li>and then pass the state along to the client.</li>
</ul>
<p>On the client side, a new Redux store will be created and initialized with the state provided from the server. Redux’s <strong><em>only</em></strong> job on the server side is to provide the <strong>initial state</strong> of our app.</p>
<h2 id="setting-up">Setting Up</h2>
<p>In the following recipe, we are going to look at how to set up server-side rendering. We’ll use the simplistic <a href="https://github.com/reduxjs/redux/tree/master/examples/counter">Counter app</a> as a guide and show how the server can render state ahead of time based on the request.</p>
<h3 id="install-packages">Install Packages</h3>
<p>For this example, we’ll be using <a href="https://expressjs.com/">Express</a> as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb121-1" title="1"><span class="ex">npm</span> install express react-redux</a></code></pre></div>
<h2 id="the-server-side">The Server Side</h2>
<p>The following is the outline for what our server side is going to look like. We are going to set up an <a href="https://expressjs.com/guide/using-middleware.html">Express middleware</a> using <a href="http://expressjs.com/api.html#app.use">app.use</a> to handle all requests that come in to our server. If you’re unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</p>
<p>Additionally, as we are using ES6 and JSX syntax, we will need to compile with <a href="https://babeljs.io/">Babel</a> (see <a href="https://github.com/babel/example-node-server">this example of a Node Server with Babel</a>) and the <a href="https://babeljs.io/docs/plugins/preset-react/">React preset</a>.</p>
<h5 id="server.js"><code>server.js</code></h5>
<div class="sourceCode" id="cb122"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb122-1" title="1"><span class="im">import</span> path <span class="im">from</span> <span class="st">&quot;path&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-2" title="2"><span class="im">import</span> Express <span class="im">from</span> <span class="st">&quot;express&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-3" title="3"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-4" title="4"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-5" title="5"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-6" title="6"><span class="im">import</span> counterApp <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-7" title="7"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./containers/App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-8" title="8"></a>
<a class="sourceLine" id="cb122-9" title="9"><span class="kw">const</span> app <span class="op">=</span> <span class="at">Express</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb122-10" title="10"><span class="kw">const</span> port <span class="op">=</span> <span class="dv">3000</span><span class="op">;</span></a>
<a class="sourceLine" id="cb122-11" title="11"></a>
<a class="sourceLine" id="cb122-12" title="12"><span class="co">//Serve static files</span></a>
<a class="sourceLine" id="cb122-13" title="13"><span class="va">app</span>.<span class="at">use</span>(<span class="st">&quot;/static&quot;</span><span class="op">,</span> <span class="va">Express</span>.<span class="at">static</span>(<span class="st">&quot;static&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb122-14" title="14"></a>
<a class="sourceLine" id="cb122-15" title="15"><span class="co">// This is fired every time the server side receives a request</span></a>
<a class="sourceLine" id="cb122-16" title="16"><span class="va">app</span>.<span class="at">use</span>(handleRender)<span class="op">;</span></a>
<a class="sourceLine" id="cb122-17" title="17"></a>
<a class="sourceLine" id="cb122-18" title="18"><span class="co">// We are going to fill these out in the sections to follow</span></a>
<a class="sourceLine" id="cb122-19" title="19"><span class="kw">function</span> <span class="at">handleRender</span>(req<span class="op">,</span> res) <span class="op">{</span></a>
<a class="sourceLine" id="cb122-20" title="20">  <span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb122-21" title="21"><span class="op">}</span></a>
<a class="sourceLine" id="cb122-22" title="22"><span class="kw">function</span> <span class="at">renderFullPage</span>(html<span class="op">,</span> preloadedState) <span class="op">{</span></a>
<a class="sourceLine" id="cb122-23" title="23">  <span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb122-24" title="24"><span class="op">}</span></a>
<a class="sourceLine" id="cb122-25" title="25"></a>
<a class="sourceLine" id="cb122-26" title="26"><span class="va">app</span>.<span class="at">listen</span>(port)<span class="op">;</span></a></code></pre></div>
<h3 id="handling-the-request">Handling the Request</h3>
<p>The first thing that we need to do on every request is to create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</p>
<p>When rendering, we will wrap <code>&lt;App /&gt;</code>, our root component, inside a <code>&lt;Provider&gt;</code> to make the store available to all components in the component tree, as we saw in <a href="../tutorials/fundamentals/part-5-ui-and-react.md">“Redux Fundamentals” Part 5: UI and React</a>.</p>
<p>The key step in server side rendering is to render the initial HTML of our component <em><strong>before</strong></em> we send it to the client side. To do this, we use <a href="https://facebook.github.io/react/docs/react-dom-server.html#rendertostring">ReactDOMServer.renderToString()</a>.</p>
<p>We then get the initial state from our Redux store using <a href="../api/Store.md#getState"><code>store.getState()</code></a>. We will see how this is passed along in our <code>renderFullPage</code> function.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb123-1" title="1"><span class="im">import</span> <span class="op">{</span> renderToString <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom/server&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb123-2" title="2"></a>
<a class="sourceLine" id="cb123-3" title="3"><span class="kw">function</span> <span class="at">handleRender</span>(req<span class="op">,</span> res) <span class="op">{</span></a>
<a class="sourceLine" id="cb123-4" title="4">  <span class="co">// Create a new Redux store instance</span></a>
<a class="sourceLine" id="cb123-5" title="5">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(counterApp)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-6" title="6"></a>
<a class="sourceLine" id="cb123-7" title="7">  <span class="co">// Render the component to a string</span></a>
<a class="sourceLine" id="cb123-8" title="8">  <span class="kw">const</span> html <span class="op">=</span> <span class="at">renderToString</span>(</a>
<a class="sourceLine" id="cb123-9" title="9">    <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb123-10" title="10">      <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb123-11" title="11">    &lt;/Provider<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb123-12" title="12">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb123-13" title="13"></a>
<a class="sourceLine" id="cb123-14" title="14">  <span class="co">// Grab the initial state from our Redux store</span></a>
<a class="sourceLine" id="cb123-15" title="15">  <span class="kw">const</span> preloadedState <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb123-16" title="16"></a>
<a class="sourceLine" id="cb123-17" title="17">  <span class="co">// Send the rendered page back to the client</span></a>
<a class="sourceLine" id="cb123-18" title="18">  <span class="va">res</span>.<span class="at">send</span>(<span class="at">renderFullPage</span>(html<span class="op">,</span> preloadedState))<span class="op">;</span></a>
<a class="sourceLine" id="cb123-19" title="19"><span class="op">}</span></a></code></pre></div>
<h3 id="inject-initial-component-html-and-state">Inject Initial Component HTML and State</h3>
<p>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a <code>&lt;script&gt;</code> tag that will attach <code>preloadedState</code> to <code>window.__PRELOADED_STATE__</code>.</p>
<p>The <code>preloadedState</code> will then be available on the client side by accessing <code>window.__PRELOADED_STATE__</code>.</p>
<p>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb124-1" title="1"><span class="kw">function</span> <span class="at">renderFullPage</span>(html<span class="op">,</span> preloadedState) <span class="op">{</span></a>
<a class="sourceLine" id="cb124-2" title="2">  <span class="cf">return</span> <span class="vs">`</span></a>
<a class="sourceLine" id="cb124-3" title="3"><span class="vs">    &lt;!doctype html&gt;</span></a>
<a class="sourceLine" id="cb124-4" title="4"><span class="vs">    &lt;html&gt;</span></a>
<a class="sourceLine" id="cb124-5" title="5"><span class="vs">      &lt;head&gt;</span></a>
<a class="sourceLine" id="cb124-6" title="6"><span class="vs">        &lt;title&gt;Redux Universal Example&lt;/title&gt;</span></a>
<a class="sourceLine" id="cb124-7" title="7"><span class="vs">      &lt;/head&gt;</span></a>
<a class="sourceLine" id="cb124-8" title="8"><span class="vs">      &lt;body&gt;</span></a>
<a class="sourceLine" id="cb124-9" title="9"><span class="vs">        &lt;div id=&quot;root&quot;&gt;</span><span class="sc">${</span>html<span class="sc">}</span><span class="vs">&lt;/div&gt;</span></a>
<a class="sourceLine" id="cb124-10" title="10"><span class="vs">        &lt;script&gt;</span></a>
<a class="sourceLine" id="cb124-11" title="11"><span class="vs">          // WARNING: See the following for security issues around embedding JSON in HTML:</span></a>
<a class="sourceLine" id="cb124-12" title="12"><span class="vs">          // https://redux.js.org/usage/server-rendering#security-considerations</span></a>
<a class="sourceLine" id="cb124-13" title="13"><span class="vs">          window.__PRELOADED_STATE__ = </span><span class="sc">${</span><span class="va">JSON</span>.<span class="at">stringify</span>(preloadedState).<span class="at">replace</span>(</a>
<a class="sourceLine" id="cb124-14" title="14">            <span class="ss">/&lt;/g</span><span class="op">,</span></a>
<a class="sourceLine" id="cb124-15" title="15">            <span class="st">&quot;</span><span class="sc">\\</span><span class="st">u003c&quot;</span></a>
<a class="sourceLine" id="cb124-16" title="16">          )<span class="sc">}</span></a>
<a class="sourceLine" id="cb124-17" title="17"><span class="vs">        &lt;/script&gt;</span></a>
<a class="sourceLine" id="cb124-18" title="18"><span class="vs">        &lt;script src=&quot;/static/bundle.js&quot;&gt;&lt;/script&gt;</span></a>
<a class="sourceLine" id="cb124-19" title="19"><span class="vs">      &lt;/body&gt;</span></a>
<a class="sourceLine" id="cb124-20" title="20"><span class="vs">    &lt;/html&gt;</span></a>
<a class="sourceLine" id="cb124-21" title="21"><span class="vs">    `</span><span class="op">;</span></a>
<a class="sourceLine" id="cb124-22" title="22"><span class="op">}</span></a></code></pre></div>
<h2 id="the-client-side">The Client Side</h2>
<p>The client side is very straightforward. All we need to do is grab the initial state from <code>window.__PRELOADED_STATE__</code>, and pass it to our <a href="../api/createStore.md"><code>createStore()</code></a> function as the initial state.</p>
<p>Let’s take a look at our new client file:</p>
<h4 id="client.js"><code>client.js</code></h4>
<div class="sourceCode" id="cb125"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb125-1" title="1"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-2" title="2"><span class="im">import</span> <span class="op">{</span> hydrate <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-3" title="3"><span class="im">import</span> <span class="op">{</span> createStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-4" title="4"><span class="im">import</span> <span class="op">{</span> Provider <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-5" title="5"><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./containers/App&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-6" title="6"><span class="im">import</span> counterApp <span class="im">from</span> <span class="st">&quot;./reducers&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-7" title="7"></a>
<a class="sourceLine" id="cb125-8" title="8"><span class="co">// Grab the state from a global variable injected into the server-generated HTML</span></a>
<a class="sourceLine" id="cb125-9" title="9"><span class="kw">const</span> preloadedState <span class="op">=</span> <span class="va">window</span>.<span class="at">__PRELOADED_STATE__</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-10" title="10"></a>
<a class="sourceLine" id="cb125-11" title="11"><span class="co">// Allow the passed state to be garbage-collected</span></a>
<a class="sourceLine" id="cb125-12" title="12"><span class="kw">delete</span> <span class="va">window</span>.<span class="at">__PRELOADED_STATE__</span><span class="op">;</span></a>
<a class="sourceLine" id="cb125-13" title="13"></a>
<a class="sourceLine" id="cb125-14" title="14"><span class="co">// Create Redux store with initial state</span></a>
<a class="sourceLine" id="cb125-15" title="15"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(counterApp<span class="op">,</span> preloadedState)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-16" title="16"></a>
<a class="sourceLine" id="cb125-17" title="17"><span class="at">hydrate</span>(</a>
<a class="sourceLine" id="cb125-18" title="18">  <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb125-19" title="19">    <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb125-20" title="20">  &lt;/Provider<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb125-21" title="21">  <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;root&quot;</span>)</a>
<a class="sourceLine" id="cb125-22" title="22">)<span class="op">;</span></a></code></pre></div>
<p>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into <code>static/bundle.js</code>.</p>
<p>When the page loads, the bundle file will be started up and <a href="https://reactjs.org/docs/react-dom.html#hydrate"><code>ReactDOM.hydrate()</code></a> will reuse the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</p>
<p>And that’s it! That is all we need to do to implement server side rendering.</p>
<p>But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.</p>
<h2 id="preparing-the-initial-state">Preparing the Initial State</h2>
<p>Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).</p>
<h3 id="processing-request-parameters">Processing Request Parameters</h3>
<p>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</p>
<p>The request contains information about the URL requested, including any query parameters, which will be useful when using something like <a href="https://github.com/ReactTraining/react-router">React Router</a>. It can also contain headers with inputs like cookies or authorization, or POST body data. Let’s see how we can set the initial counter state based on a query parameter.</p>
<h4 id="server.js-1"><code>server.js</code></h4>
<div class="sourceCode" id="cb126"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb126-1" title="1"><span class="im">import</span> qs <span class="im">from</span> <span class="st">&quot;qs&quot;</span><span class="op">;</span> <span class="co">// Add this at the top of the file</span></a>
<a class="sourceLine" id="cb126-2" title="2"><span class="im">import</span> <span class="op">{</span> renderToString <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom/server&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb126-3" title="3"></a>
<a class="sourceLine" id="cb126-4" title="4"><span class="kw">function</span> <span class="at">handleRender</span>(req<span class="op">,</span> res) <span class="op">{</span></a>
<a class="sourceLine" id="cb126-5" title="5">  <span class="co">// Read the counter from the request, if provided</span></a>
<a class="sourceLine" id="cb126-6" title="6">  <span class="kw">const</span> params <span class="op">=</span> <span class="va">qs</span>.<span class="at">parse</span>(<span class="va">req</span>.<span class="at">query</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-7" title="7">  <span class="kw">const</span> counter <span class="op">=</span> <span class="at">parseInt</span>(<span class="va">params</span>.<span class="at">counter</span><span class="op">,</span> <span class="dv">10</span>) <span class="op">||</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb126-8" title="8"></a>
<a class="sourceLine" id="cb126-9" title="9">  <span class="co">// Compile an initial state</span></a>
<a class="sourceLine" id="cb126-10" title="10">  <span class="kw">let</span> preloadedState <span class="op">=</span> <span class="op">{</span> counter <span class="op">};</span></a>
<a class="sourceLine" id="cb126-11" title="11"></a>
<a class="sourceLine" id="cb126-12" title="12">  <span class="co">// Create a new Redux store instance</span></a>
<a class="sourceLine" id="cb126-13" title="13">  <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(counterApp<span class="op">,</span> preloadedState)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-14" title="14"></a>
<a class="sourceLine" id="cb126-15" title="15">  <span class="co">// Render the component to a string</span></a>
<a class="sourceLine" id="cb126-16" title="16">  <span class="kw">const</span> html <span class="op">=</span> <span class="at">renderToString</span>(</a>
<a class="sourceLine" id="cb126-17" title="17">    <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb126-18" title="18">      <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb126-19" title="19">    &lt;/Provider<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb126-20" title="20">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb126-21" title="21"></a>
<a class="sourceLine" id="cb126-22" title="22">  <span class="co">// Grab the initial state from our Redux store</span></a>
<a class="sourceLine" id="cb126-23" title="23">  <span class="kw">const</span> finalState <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb126-24" title="24"></a>
<a class="sourceLine" id="cb126-25" title="25">  <span class="co">// Send the rendered page back to the client</span></a>
<a class="sourceLine" id="cb126-26" title="26">  <span class="va">res</span>.<span class="at">send</span>(<span class="at">renderFullPage</span>(html<span class="op">,</span> finalState))<span class="op">;</span></a>
<a class="sourceLine" id="cb126-27" title="27"><span class="op">}</span></a></code></pre></div>
<p>The code reads from the Express <code>Request</code> object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit <a href="http://localhost:3000/?counter=100">http://localhost:3000/?counter=100</a> in your browser, you’ll see the counter starts at 100. In the rendered HTML, you’ll see the counter output as 100 and the <code>__PRELOADED_STATE__</code> variable has the counter set in it.</p>
<h3 id="async-state-fetching">Async State Fetching</h3>
<p>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it’s necessary to map any asynchronous fetches into a synchronous operation.</p>
<p>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don’t worry, it’s not as hard as it may sound.</p>
<p>For our example, we’ll imagine there is an external datastore that contains the counter’s initial value (Counter As A Service, or CaaS). We’ll make a mock call over to them and build our initial state from the result. We’ll start by building out our API call:</p>
<h4 id="apicounter.js"><code>api/counter.js</code></h4>
<div class="sourceCode" id="cb127"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb127-1" title="1"><span class="kw">function</span> <span class="at">getRandomInt</span>(min<span class="op">,</span> max) <span class="op">{</span></a>
<a class="sourceLine" id="cb127-2" title="2">  <span class="cf">return</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">Math</span>.<span class="at">random</span>() <span class="op">*</span> (max <span class="op">-</span> min)) <span class="op">+</span> min<span class="op">;</span></a>
<a class="sourceLine" id="cb127-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb127-4" title="4"></a>
<a class="sourceLine" id="cb127-5" title="5"><span class="im">export</span> <span class="kw">function</span> <span class="at">fetchCounter</span>(callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb127-6" title="6">  <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb127-7" title="7">    <span class="at">callback</span>(<span class="at">getRandomInt</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">100</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb127-8" title="8">  <span class="op">},</span> <span class="dv">500</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>Again, this is just a mock API, so we use <code>setTimeout</code> to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you’re using a Promise-based API client, then you would issue this callback in your <code>then</code> handler.</p>
<p>On the server side, we simply wrap our existing code in the <code>fetchCounter</code> and receive the result in the callback:</p>
<h4 id="server.js-2"><code>server.js</code></h4>
<div class="sourceCode" id="cb128"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb128-1" title="1"><span class="co">// Add this to our imports</span></a>
<a class="sourceLine" id="cb128-2" title="2"><span class="im">import</span> <span class="op">{</span> fetchCounter <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./api/counter&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb128-3" title="3"><span class="im">import</span> <span class="op">{</span> renderToString <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-dom/server&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb128-4" title="4"></a>
<a class="sourceLine" id="cb128-5" title="5"><span class="kw">function</span> <span class="at">handleRender</span>(req<span class="op">,</span> res) <span class="op">{</span></a>
<a class="sourceLine" id="cb128-6" title="6">  <span class="co">// Query our mock API asynchronously</span></a>
<a class="sourceLine" id="cb128-7" title="7">  <span class="at">fetchCounter</span>((apiResult) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb128-8" title="8">    <span class="co">// Read the counter from the request, if provided</span></a>
<a class="sourceLine" id="cb128-9" title="9">    <span class="kw">const</span> params <span class="op">=</span> <span class="va">qs</span>.<span class="at">parse</span>(<span class="va">req</span>.<span class="at">query</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-10" title="10">    <span class="kw">const</span> counter <span class="op">=</span> <span class="at">parseInt</span>(<span class="va">params</span>.<span class="at">counter</span><span class="op">,</span> <span class="dv">10</span>) <span class="op">||</span> apiResult <span class="op">||</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb128-11" title="11"></a>
<a class="sourceLine" id="cb128-12" title="12">    <span class="co">// Compile an initial state</span></a>
<a class="sourceLine" id="cb128-13" title="13">    <span class="kw">let</span> preloadedState <span class="op">=</span> <span class="op">{</span> counter <span class="op">};</span></a>
<a class="sourceLine" id="cb128-14" title="14"></a>
<a class="sourceLine" id="cb128-15" title="15">    <span class="co">// Create a new Redux store instance</span></a>
<a class="sourceLine" id="cb128-16" title="16">    <span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(counterApp<span class="op">,</span> preloadedState)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-17" title="17"></a>
<a class="sourceLine" id="cb128-18" title="18">    <span class="co">// Render the component to a string</span></a>
<a class="sourceLine" id="cb128-19" title="19">    <span class="kw">const</span> html <span class="op">=</span> <span class="at">renderToString</span>(</a>
<a class="sourceLine" id="cb128-20" title="20">      <span class="op">&lt;</span>Provider store<span class="op">={</span>store<span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb128-21" title="21">        <span class="op">&lt;</span>App /<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb128-22" title="22">      &lt;/Provider<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb128-23" title="23">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb128-24" title="24"></a>
<a class="sourceLine" id="cb128-25" title="25">    <span class="co">// Grab the initial state from our Redux store</span></a>
<a class="sourceLine" id="cb128-26" title="26">    <span class="kw">const</span> finalState <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb128-27" title="27"></a>
<a class="sourceLine" id="cb128-28" title="28">    <span class="co">// Send the rendered page back to the client</span></a>
<a class="sourceLine" id="cb128-29" title="29">    <span class="va">res</span>.<span class="at">send</span>(<span class="at">renderFullPage</span>(html<span class="op">,</span> finalState))<span class="op">;</span></a>
<a class="sourceLine" id="cb128-30" title="30">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-31" title="31"><span class="op">}</span></a></code></pre></div>
<p>Because we call <code>res.send()</code> inside of the callback, the server will hold open the connection and won’t send any data until that callback executes. You’ll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.</p>
<h3 id="security-considerations">Security Considerations</h3>
<p>Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.</p>
<p>In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use <code>parseInt</code> on the <code>counter</code> parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: <code>?counter=&lt;/script&gt;&lt;script&gt;doSomethingBad();&lt;/script&gt;</code></p>
<p>For our simplistic example, coercing our input into a number is sufficiently secure. If you’re handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as <a href="https://github.com/yahoo/xss-filters">xss-filters</a>.</p>
<p>Furthermore, you can add additional layers of security by sanitizing your state output. <code>JSON.stringify</code> can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string, e.g. <code>JSON.stringify(state).replace(/&lt;/g, '\\u003c')</code>, or via more sophisticated libraries such as <a href="https://github.com/yahoo/serialize-javascript">serialize-javascript</a>.</p>
<h2 id="next-steps-1">Next Steps</h2>
<p>You may want to read <a href="../tutorials/fundamentals/part-6-async-logic.md">Redux Fundamentals Part 6: Async Logic and Data Fetching</a> to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</p>
<p>If you use something like <a href="https://github.com/ReactTraining/react-router">React Router</a>, you might also want to express your data fetching dependencies as static <code>fetchData()</code> methods on your route handler components. They may return <a href="../tutorials/fundamentals/part-6-async-logic.md">thunks</a>, so that your <code>handleRender</code> function can match the route to the route handler component classes, dispatch <code>fetchData()</code> result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.</p>
<hr />
<p>id: troubleshooting title: Troubleshooting</p>
<hr />
<h1 id="troubleshooting">Troubleshooting</h1>
<p>This is a place to share common problems and solutions to them. The examples use React, but you should still find them useful if you use something else.</p>
<h3 id="nothing-happens-when-i-dispatch-an-action">Nothing happens when I dispatch an action</h3>
<p>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</p>
<h4 id="never-mutate-reducer-arguments">Never mutate reducer arguments</h4>
<p>It is tempting to modify the <code>state</code> or <code>action</code> passed to you by Redux. Don’t do this!</p>
<p>Redux assumes that you never mutate the objects it gives to you in the reducer. <strong>Every single time, you must return the new state object.</strong> Even if you don’t use a library like <a href="https://github.com/immerjs/immer">Immer</a>, you need to completely avoid mutation.</p>
<p>Immutability is what lets <a href="https://github.com/gaearon/react-redux">react-redux</a> efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with <a href="https://github.com/reduxjs/redux-devtools">redux-devtools</a>.</p>
<p>For example, a reducer like this is wrong because it mutates the state:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb129-1" title="1"><span class="kw">function</span> <span class="at">todos</span>(state <span class="op">=</span> []<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb129-2" title="2">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb129-3" title="3">    <span class="cf">case</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb129-4" title="4">      <span class="co">// Wrong! This mutates state</span></a>
<a class="sourceLine" id="cb129-5" title="5">      <span class="va">state</span>.<span class="at">push</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb129-6" title="6">        <span class="dt">text</span><span class="op">:</span> <span class="va">action</span>.<span class="at">text</span><span class="op">,</span></a>
<a class="sourceLine" id="cb129-7" title="7">        <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb129-8" title="8">      <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb129-9" title="9">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb129-10" title="10">    <span class="cf">case</span> <span class="st">&quot;COMPLETE_TODO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb129-11" title="11">      <span class="co">// Wrong! This mutates state[action.index].</span></a>
<a class="sourceLine" id="cb129-12" title="12">      state[<span class="va">action</span>.<span class="at">index</span>].<span class="at">completed</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb129-13" title="13">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb129-14" title="14">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb129-15" title="15">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb129-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb129-17" title="17"><span class="op">}</span></a></code></pre></div>
<p>It needs to be rewritten like this:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb130-1" title="1"><span class="kw">function</span> <span class="at">todos</span>(state <span class="op">=</span> []<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb130-2" title="2">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb130-3" title="3">    <span class="cf">case</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb130-4" title="4">      <span class="co">// Return a new array</span></a>
<a class="sourceLine" id="cb130-5" title="5">      <span class="cf">return</span> [</a>
<a class="sourceLine" id="cb130-6" title="6">        ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb130-7" title="7">        <span class="op">{</span></a>
<a class="sourceLine" id="cb130-8" title="8">          <span class="dt">text</span><span class="op">:</span> <span class="va">action</span>.<span class="at">text</span><span class="op">,</span></a>
<a class="sourceLine" id="cb130-9" title="9">          <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb130-10" title="10">        <span class="op">},</span></a>
<a class="sourceLine" id="cb130-11" title="11">      ]<span class="op">;</span></a>
<a class="sourceLine" id="cb130-12" title="12">    <span class="cf">case</span> <span class="st">&quot;COMPLETE_TODO&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb130-13" title="13">      <span class="co">// Return a new array</span></a>
<a class="sourceLine" id="cb130-14" title="14">      <span class="cf">return</span> <span class="va">state</span>.<span class="at">map</span>((todo<span class="op">,</span> index) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb130-15" title="15">        <span class="cf">if</span> (index <span class="op">===</span> <span class="va">action</span>.<span class="at">index</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb130-16" title="16">          <span class="co">// Copy the object before mutating</span></a>
<a class="sourceLine" id="cb130-17" title="17">          <span class="cf">return</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> todo<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb130-18" title="18">            <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb130-19" title="19">          <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb130-20" title="20">        <span class="op">}</span></a>
<a class="sourceLine" id="cb130-21" title="21">        <span class="cf">return</span> todo<span class="op">;</span></a>
<a class="sourceLine" id="cb130-22" title="22">      <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb130-23" title="23">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb130-24" title="24">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb130-25" title="25">  <span class="op">}</span></a>
<a class="sourceLine" id="cb130-26" title="26"><span class="op">}</span></a></code></pre></div>
<p>It’s more code, but it’s exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like <a href="https://facebook.github.io/react/docs/update.html"><code>React.addons.update</code></a> to write immutable transformations with a terse syntax:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb131-1" title="1"><span class="co">// Before:</span></a>
<a class="sourceLine" id="cb131-2" title="2"><span class="cf">return</span> <span class="va">state</span>.<span class="at">map</span>((todo<span class="op">,</span> index) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb131-3" title="3">  <span class="cf">if</span> (index <span class="op">===</span> <span class="va">action</span>.<span class="at">index</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb131-4" title="4">    <span class="cf">return</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> todo<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb131-5" title="5">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb131-6" title="6">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb131-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb131-8" title="8">  <span class="cf">return</span> todo<span class="op">;</span></a>
<a class="sourceLine" id="cb131-9" title="9"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb131-10" title="10"></a>
<a class="sourceLine" id="cb131-11" title="11"><span class="co">// After</span></a>
<a class="sourceLine" id="cb131-12" title="12"><span class="cf">return</span> <span class="at">update</span>(state<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb131-13" title="13">  [<span class="va">action</span>.<span class="at">index</span>]<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb131-14" title="14">    <span class="dt">completed</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb131-15" title="15">      <span class="dt">$set</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb131-16" title="16">    <span class="op">},</span></a>
<a class="sourceLine" id="cb131-17" title="17">  <span class="op">},</span></a>
<a class="sourceLine" id="cb131-18" title="18"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Finally, to update objects, you’ll need something like <code>_.extend</code> from Underscore, or better, an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign</code></a> polyfill.</p>
<p>Make sure that you use <code>Object.assign</code> correctly. For example, instead of returning something like <code>Object.assign(state, newData)</code> from your reducers, return <code>Object.assign({}, state, newData)</code>. This way you don’t override the previous <code>state</code>.</p>
<p>You can also use the object spread operator proposal for a more succinct syntax:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb132-1" title="1"><span class="co">// Before:</span></a>
<a class="sourceLine" id="cb132-2" title="2"><span class="cf">return</span> <span class="va">state</span>.<span class="at">map</span>((todo<span class="op">,</span> index) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb132-3" title="3">  <span class="cf">if</span> (index <span class="op">===</span> <span class="va">action</span>.<span class="at">index</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb132-4" title="4">    <span class="cf">return</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> todo<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb132-5" title="5">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb132-6" title="6">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb132-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb132-8" title="8">  <span class="cf">return</span> todo<span class="op">;</span></a>
<a class="sourceLine" id="cb132-9" title="9"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb132-10" title="10"></a>
<a class="sourceLine" id="cb132-11" title="11"><span class="co">// After:</span></a>
<a class="sourceLine" id="cb132-12" title="12"><span class="cf">return</span> <span class="va">state</span>.<span class="at">map</span>((todo<span class="op">,</span> index) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb132-13" title="13">  <span class="cf">if</span> (index <span class="op">===</span> <span class="va">action</span>.<span class="at">index</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb132-14" title="14">    <span class="cf">return</span> <span class="op">{</span> ...<span class="at">todo</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb132-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb132-16" title="16">  <span class="cf">return</span> todo<span class="op">;</span></a>
<a class="sourceLine" id="cb132-17" title="17"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Note that experimental language features are subject to change.</p>
<p>Also keep an eye out for nested state objects that need to be deeply copied. Both <code>_.extend</code> and <code>Object.assign</code> make a shallow copy of the state. See <a href="./usage/structuring-reducers/ImmutableUpdatePatterns.md#updating-nested-objects">Updating Nested Objects</a> for suggestions on how to deal with nested state objects.</p>
<h4 id="dont-forget-to-call-dispatchaction">Don’t forget to call <a href="api/Store.md#dispatchaction"><code>dispatch(action)</code></a></h4>
<p>If you define an action creator, calling it will <em>not</em> automatically dispatch the action. For example, this code will do nothing:</p>
<h4 id="todoactions.js"><code>TodoActions.js</code></h4>
<div class="sourceCode" id="cb133"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb133-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">addTodo</span>(text) <span class="op">{</span></a>
<a class="sourceLine" id="cb133-2" title="2">  <span class="cf">return</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;ADD_TODO&quot;</span><span class="op">,</span> text <span class="op">};</span></a>
<a class="sourceLine" id="cb133-3" title="3"><span class="op">}</span></a></code></pre></div>
<h4 id="addtodo.js-1"><code>AddTodo.js</code></h4>
<div class="sourceCode" id="cb134"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb134-1" title="1"><span class="im">import</span> React<span class="op">,</span> <span class="op">{</span> Component <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb134-2" title="2"><span class="im">import</span> <span class="op">{</span> addTodo <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./TodoActions&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb134-3" title="3"></a>
<a class="sourceLine" id="cb134-4" title="4"><span class="kw">class</span> AddTodo <span class="kw">extends</span> Component <span class="op">{</span></a>
<a class="sourceLine" id="cb134-5" title="5">  <span class="at">handleClick</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb134-6" title="6">    <span class="co">// Won&#39;t work!</span></a>
<a class="sourceLine" id="cb134-7" title="7">    <span class="at">addTodo</span>(<span class="st">&quot;Fix the issue&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb134-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb134-9" title="9"></a>
<a class="sourceLine" id="cb134-10" title="10">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb134-11" title="11">    <span class="cf">return</span> <span class="op">&lt;</span>button onClick<span class="op">={</span>() <span class="kw">=&gt;</span> <span class="kw">this</span>.<span class="at">handleClick</span>()<span class="op">}&gt;</span>Add&lt;/button<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb134-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb134-13" title="13"><span class="op">}</span></a></code></pre></div>
<p>It doesn’t work because your action creator is just a function that <em>returns</em> an action. It is up to you to actually dispatch it. We can’t bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</p>
<p>The fix is to call <a href="api/Store.md#dispatchaction"><code>dispatch()</code></a> method on the <a href="api/Store.md">store</a> instance:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb135-1" title="1"><span class="at">handleClick</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb135-2" title="2">  <span class="co">// Works! (but you need to grab store somehow)</span></a>
<a class="sourceLine" id="cb135-3" title="3">  <span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">addTodo</span>(<span class="st">&#39;Fix the issue&#39;</span>))</a>
<a class="sourceLine" id="cb135-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>If you’re somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why <a href="https://github.com/gaearon/react-redux">react-redux</a> lets you use a <code>connect</code> <a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750">higher-order component</a> that will, apart from subscribing you to a Redux store, inject <code>dispatch</code> into your component’s props.</p>
<p>The fixed code looks like this:</p>
<h4 id="addtodo.js-2"><code>AddTodo.js</code></h4>
<div class="sourceCode" id="cb136"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb136-1" title="1"><span class="im">import</span> React<span class="op">,</span> <span class="op">{</span> Component <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb136-2" title="2"><span class="im">import</span> <span class="op">{</span> connect <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;react-redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb136-3" title="3"><span class="im">import</span> <span class="op">{</span> addTodo <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./TodoActions&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb136-4" title="4"></a>
<a class="sourceLine" id="cb136-5" title="5"><span class="kw">class</span> AddTodo <span class="kw">extends</span> Component <span class="op">{</span></a>
<a class="sourceLine" id="cb136-6" title="6">  <span class="at">handleClick</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb136-7" title="7">    <span class="co">// Works!</span></a>
<a class="sourceLine" id="cb136-8" title="8">    <span class="kw">this</span>.<span class="va">props</span>.<span class="at">dispatch</span>(<span class="at">addTodo</span>(<span class="st">&quot;Fix the issue&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb136-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb136-10" title="10"></a>
<a class="sourceLine" id="cb136-11" title="11">  <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb136-12" title="12">    <span class="cf">return</span> <span class="op">&lt;</span>button onClick<span class="op">={</span>() <span class="kw">=&gt;</span> <span class="kw">this</span>.<span class="at">handleClick</span>()<span class="op">}&gt;</span>Add&lt;/button<span class="op">&gt;;</span></a>
<a class="sourceLine" id="cb136-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb136-14" title="14"><span class="op">}</span></a>
<a class="sourceLine" id="cb136-15" title="15"></a>
<a class="sourceLine" id="cb136-16" title="16"><span class="co">// In addition to the state, `connect` puts `dispatch` in our props.</span></a>
<a class="sourceLine" id="cb136-17" title="17"><span class="im">export</span> <span class="im">default</span> <span class="at">connect</span>()(AddTodo)<span class="op">;</span></a></code></pre></div>
<p>You can then pass <code>dispatch</code> down to other components manually, if you want to.</p>
<h4 id="make-sure-mapstatetoprops-is-correct">Make sure mapStateToProps is correct</h4>
<p>It’s possible you’re correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</p>
<h2 id="something-else-doesnt-work">Something else doesn’t work</h2>
<p>Ask around on the <strong>#redux</strong> <a href="https://www.reactiflux.com/">Reactiflux</a> Discord channel, or <a href="https://github.com/reduxjs/redux/issues">create an issue</a>.</p>
<p>If you figure it out, <a href="https://github.com/reduxjs/redux/edit/master/docs/usage/Troubleshooting.md">edit this document</a> as a courtesy to the next person having the same problem.</p>
<hr />
<p>id: usage-with-typescript title: Usage With TypeScript</p>
<hr />
<h1 id="usage-with-typescript">Usage with TypeScript</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>Standard patterns for setting up a Redux app with TypeScript</li>
<li>Techniques for correctly typing portions of Redux logic</li>
</ul>
<p>:::</p>
<p>:::important Prerequisites</p>
<ul>
<li>Understanding of <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html">TypeScript syntax and terms</a></li>
<li>Familiarity with TypeScript concepts like <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">generics</a> and <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">utility types</a></li>
<li>Knowledge of <a href="https://reactjs.org/docs/hooks-intro.html">React Hooks</a></li>
</ul>
<p>:::</p>
<h2 id="overview">Overview</h2>
<p><strong>TypeScript</strong> is a typed superset of JavaScript that provides compile-time checking of source code. When used with Redux, TypeScript can help provide:</p>
<ol type="1">
<li>Type safety for reducers, state and action creators, and UI components</li>
<li>Easy refactoring of typed code</li>
<li>A superior developer experience in a team environment</li>
</ol>
<p><a href="../style-guide/style-guide.md#use-static-typing"><strong>We strongly recommend using TypeScript in Redux applications</strong></a>. However, like all tools, TypeScript has tradeoffs. It adds complexity in terms of writing additional code, understanding TS syntax, and building the application. At the same time, it provides value by catching errors earlier in development, enabling safer and more efficient refactoring, and acting as documentation for existing source code.</p>
<p>We believe that <strong><a href="https://blog.isquaredsoftware.com/2019/11/blogged-answers-learning-and-using-typescript/#pragmatism-is-vital">pragmatic use of TypeScript</a> provides more than enough value and benefit to justify the added overhead</strong>, especially in larger codebases, but you should take time to <strong>evaluate the tradeoffs and decide whether it’s worth using TS in your own application</strong>.</p>
<p>There are multiple possible approaches to type checking Redux code. <strong>This page shows our standard recommended patterns for using Redux and TypeScript together</strong>, and is not an exhaustive guide. Following these patterns should result in a good TS usage experience, with <strong>the best tradeoffs between type safety and amount of type declarations you have to add to your codebase</strong>.</p>
<h2 id="standard-redux-toolkit-project-setup-with-typescript">Standard Redux Toolkit Project Setup with TypeScript</h2>
<p>We assume that a typical Redux project is using Redux Toolkit and React Redux together.</p>
<p><a href="https://redux-toolkit.js.org">Redux Toolkit</a> (RTK) is the standard approach for writing modern Redux logic. RTK is already written in TypeScript, and its API is designed to provide a good experience for TypeScript usage.</p>
<p><a href="https://react-redux.js.org">React Redux</a> has its type definitions in a separate <a href="https://npm.im/@types/react-redux"><code>@types/react-redux</code> typedefs package</a> on NPM. In addition to typing the library functions, the types also export some helpers to make it easier to write typesafe interfaces between your Redux store and your React components.</p>
<p>As of React Redux v7.2.3, the <code>react-redux</code> package has a dependency on <code>@types/react-redux</code>, so the type definitions will be automatically installed with the library. Otherwise, you’ll need to manually install them yourself (typically <code>npm install @types/react-redux</code> ).</p>
<p>The <a href="https://github.com/reduxjs/cra-template-redux-typescript">Redux+TS template for Create-React-App</a> comes with a working example of these patterns already configured.</p>
<h3 id="define-root-state-and-dispatch-types">Define Root State and Dispatch Types</h3>
<p>Using <a href="https://redux-toolkit.js.org/api/configureStore">configureStore</a> should not need any additional typings. You will, however, want to extract the <code>RootState</code> type and the <code>Dispatch</code> type so that they can be referenced as needed. Inferring these types from the store itself means that they correctly update as you add more state slices or modify middleware settings.</p>
<p>Since those are types, it’s safe to export them directly from your store setup file such as <code>app/store.ts</code> and import them directly into other files.</p>
<p>```ts title=“app/store.ts” import { configureStore } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; // …</p>
<p>export const store = configureStore({ reducer: { posts: postsReducer, comments: commentsReducer, users: usersReducer, }, });</p>
<p>// highlight-start // Infer the <code>RootState</code> and <code>AppDispatch</code> types from the store itself export type RootState = ReturnType&lt;typeof store.getState&gt;; // Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState} export type AppDispatch = typeof store.dispatch; // highlight-end ```</p>
<h3 id="define-typed-hooks">Define Typed Hooks</h3>
<p>While it’s possible to import the <code>RootState</code> and <code>AppDispatch</code> types into each component, it’s better to <strong>create pre-typed versions of the <code>useDispatch</code> and <code>useSelector</code> hooks for usage in your application</strong>. This is important for a couple reasons:</p>
<ul>
<li>For <code>useSelector</code>, it saves you the need to type <code>(state: RootState)</code> every time</li>
<li>For <code>useDispatch</code>, the default <code>Dispatch</code> type does not know about thunks or other middleware. In order to correctly dispatch thunks, you need to use the specific customized <code>AppDispatch</code> type from the store that includes the thunk middleware types, and use that with <code>useDispatch</code>. Adding a pre-typed <code>useDispatch</code> hook keeps you from forgetting to import <code>AppDispatch</code> where it’s needed.</li>
</ul>
<p>Since these are actual variables, not types, it’s important to define them in a separate file such as <code>app/hooks.ts</code>, not the store setup file. This allows you to import them into any component file that needs to use the hooks, and avoids potential circular import dependency issues.</p>
<p>```ts title=“app/hooks.ts” import { TypedUseSelectorHook, useDispatch, useSelector } from “react-redux”; import type { RootState, AppDispatch } from “./store”;</p>
<p>// highlight-start // Use throughout your app instead of plain <code>useDispatch</code> and <code>useSelector</code> export const useAppDispatch = () =&gt; useDispatch<AppDispatch>(); export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector; // highlight-end ```</p>
<h2 id="application-usage">Application Usage</h2>
<h3 id="define-slice-state-and-action-types">Define Slice State and Action Types</h3>
<p>Each slice file should define a type for its initial state value, so that <code>createSlice</code> can correctly infer the type of <code>state</code> in each case reducer.</p>
<p>All generated actions should be defined using the <code>PayloadAction&lt;T&gt;</code> type from Redux Toolkit, which takes the type of the <code>action.payload</code> field as its generic argument.</p>
<p>You can safely import the <code>RootState</code> type from the store file here. It’s a circular import, but the TypeScript compiler can correctly handle that for types. This may be needed for use cases like writing selector functions.</p>
<p>```ts title=“features/counter/counterSlice.ts” import { createSlice, PayloadAction } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; import type { RootState } from “../../app/store”;</p>
<p>// highlight-start // Define a type for the slice state interface CounterState { value: number; }</p>
<p>// Define the initial state using that type const initialState: CounterState = { value: 0, }; // highlight-end</p>
<p>export const counterSlice = createSlice({ name: “counter”, // <code>createSlice</code> will infer the state type from the <code>initialState</code> argument initialState, reducers: { increment: (state) =&gt; { state.value += 1; }, decrement: (state) =&gt; { state.value -= 1; }, // highlight-start // Use the PayloadAction type to declare the contents of <code>action.payload</code> incrementByAmount: (state, action: PayloadAction<number>) =&gt; { // highlight-end state.value += action.payload; }, }, });</p>
<p>export const { increment, decrement, incrementByAmount } = counterSlice.actions;</p>
<p>// Other code such as selectors can use the imported <code>RootState</code> type export const selectCount = (state: RootState) =&gt; state.counter.value;</p>
<p>export default counterSlice.reducer; ```</p>
<p>The generated action creators will be correctly typed to accept a <code>payload</code> argument based on the <code>PayloadAction&lt;T&gt;</code> type you provided for the reducer. For example, <code>incrementByAmount</code> requires a <code>number</code> as its argument.</p>
<p>In some cases, <a href="https://github.com/reduxjs/redux-toolkit/pull/827">TypeScript may unnecessarily tighten the type of the initial state</a>. If that happens, you can work around it by casting the initial state using <code>as</code>, instead of declaring the type of the variable:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb137-1" title="1"><span class="co">// Workaround: cast state instead of declaring variable type</span></a>
<a class="sourceLine" id="cb137-2" title="2"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb137-3" title="3">  value<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb137-4" title="4"><span class="op">}</span> <span class="im">as</span> CounterState<span class="op">;</span></a></code></pre></div>
<h3 id="use-typed-hooks-in-components">Use Typed Hooks in Components</h3>
<p>In component files, import the pre-typed hooks instead of the standard hooks from React Redux.</p>
<p>```tsx title=“features/counter/Counter.tsx” import React, { useState } from “react”;</p>
<p>// highlight-next-line import { useAppSelector, useAppDispatch } from “app/hooks”;</p>
<p>import { decrement, increment } from “./counterSlice”;</p>
<p>export function Counter() { // highlight-start // The <code>state</code> arg is correctly typed as <code>RootState</code> already const count = useAppSelector((state) =&gt; state.counter.value); const dispatch = useAppDispatch(); // highlight-end</p>
<p>// omit rendering logic } ```</p>
<h2 id="typing-additional-redux-logic">Typing Additional Redux Logic</h2>
<h3 id="type-checking-reducers">Type Checking Reducers</h3>
<p><a href="../tutorials/fundamentals/part-3-state-actions-reducers.md">Reducers</a> are pure functions that receive the current <code>state</code> and incoming <code>action</code> as arguments, and return a new state.</p>
<p>If you are using Redux Toolkit’s <code>createSlice</code>, you should rarely need to specifically type a reducer separately. If you do actually write a standalone reducer, it’s typically sufficient to declare the type of the <code>initialState</code> value, and type the <code>action</code> as <code>AnyAction</code>:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb138-1" title="1"><span class="im">import</span> <span class="op">{</span> AnyAction <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb138-2" title="2"></a>
<a class="sourceLine" id="cb138-3" title="3"><span class="kw">interface</span> CounterState <span class="op">{</span></a>
<a class="sourceLine" id="cb138-4" title="4">  value<span class="op">:</span> <span class="dt">number</span><span class="op">;</span></a>
<a class="sourceLine" id="cb138-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb138-6" title="6"></a>
<a class="sourceLine" id="cb138-7" title="7"><span class="kw">const</span> initialState<span class="op">:</span> CounterState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb138-8" title="8">  value<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb138-9" title="9"><span class="op">};</span></a>
<a class="sourceLine" id="cb138-10" title="10"></a>
<a class="sourceLine" id="cb138-11" title="11"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="fu">counterReducer</span>(</a>
<a class="sourceLine" id="cb138-12" title="12">  state <span class="op">=</span> initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb138-13" title="13">  action<span class="op">:</span> AnyAction</a>
<a class="sourceLine" id="cb138-14" title="14">) <span class="op">{</span></a>
<a class="sourceLine" id="cb138-15" title="15">  <span class="co">// logic here</span></a>
<a class="sourceLine" id="cb138-16" title="16"><span class="op">}</span></a></code></pre></div>
<p>However, the Redux core does export a <code>Reducer&lt;State, Action&gt;</code> type you can use as well.</p>
<h3 id="type-checking-middleware">Type Checking Middleware</h3>
<p><a href="../tutorials/fundamentals/part-4-store.md#middleware">Middleware</a> are an extension mechanism for the Redux store. Middleware are composed into a pipeline that wrap the store’s <code>dispatch</code> method, and have access to the store’s <code>dispatch</code> and <code>getState</code> methods.</p>
<p>The Redux core exports a <code>Middleware</code> type that can be used to correctly type a middleware function:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb139-1" title="1"><span class="im">export</span> <span class="kw">interface</span> Middleware<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb139-2" title="2">  DispatchExt <span class="op">=</span> <span class="op">{},</span> <span class="co">// optional override return behavior of `dispatch`</span></a>
<a class="sourceLine" id="cb139-3" title="3">  S <span class="op">=</span> any<span class="op">,</span> <span class="co">// type of the Redux store state</span></a>
<a class="sourceLine" id="cb139-4" title="4">  D <span class="kw">extends</span> Dispatch <span class="op">=</span> Dispatch <span class="co">// type of the dispatch method</span></a>
<a class="sourceLine" id="cb139-5" title="5"><span class="op">&gt;</span></a></code></pre></div>
<p>A custom middleware should use the <code>Middleware</code> type, and pass the generic args for <code>S</code> (state) and <code>D</code> (dispatch) if needed:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb140-1" title="1"><span class="im">import</span> <span class="op">{</span> Middleware <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb140-2" title="2"></a>
<a class="sourceLine" id="cb140-3" title="3"><span class="im">import</span> <span class="op">{</span> RootState <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../store&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb140-4" title="4"></a>
<a class="sourceLine" id="cb140-5" title="5"><span class="im">export</span> <span class="kw">const</span> exampleMiddleware<span class="op">:</span> Middleware<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb140-6" title="6">  <span class="op">{},</span> <span class="co">// Most middleware do not modify the dispatch return value</span></a>
<a class="sourceLine" id="cb140-7" title="7">  RootState</a>
<a class="sourceLine" id="cb140-8" title="8"><span class="op">&gt;</span> <span class="op">=</span> (storeApi) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb140-9" title="9">  <span class="kw">const</span> state <span class="op">=</span> <span class="va">storeApi</span><span class="op">.</span><span class="fu">getState</span>()<span class="op">;</span> <span class="co">// correctly typed as RootState</span></a>
<a class="sourceLine" id="cb140-10" title="10"><span class="op">};</span></a></code></pre></div>
<p>The dispatch generic should likely only be needed if you are dispatching additional thunks within the middleware.</p>
<h3 id="type-checking-redux-thunks">Type Checking Redux Thunks</h3>
<p><a href="https://github.com/reduxjs/redux-thunk">Redux Thunk</a> is the standard middleware for writing sync and async logic that interacts with the Redux store. A thunk function receives <code>dispatch</code> and <code>getState</code> as its parameters. Redux Thunk has a built in <code>ThunkAction</code> type which we can use to define types for those arguments:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb141-1" title="1"><span class="im">export</span> <span class="kw">type</span> ThunkAction<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb141-2" title="2">  R<span class="op">,</span> <span class="co">// Return type of the thunk function</span></a>
<a class="sourceLine" id="cb141-3" title="3">  S<span class="op">,</span> <span class="co">// state type used by getState</span></a>
<a class="sourceLine" id="cb141-4" title="4">  E<span class="op">,</span> <span class="co">// any &quot;extra argument&quot; injected into the thunk</span></a>
<a class="sourceLine" id="cb141-5" title="5">  A <span class="kw">extends</span> Action <span class="co">// known types of actions that can be dispatched</span></a>
<a class="sourceLine" id="cb141-6" title="6"><span class="op">&gt;</span> <span class="op">=</span> (</a>
<a class="sourceLine" id="cb141-7" title="7">  dispatch<span class="op">:</span> ThunkDispatch<span class="op">&lt;</span>S<span class="op">,</span> E<span class="op">,</span> A<span class="op">&gt;,</span></a>
<a class="sourceLine" id="cb141-8" title="8">  getState<span class="op">:</span> () <span class="kw">=&gt;</span> S<span class="op">,</span></a>
<a class="sourceLine" id="cb141-9" title="9">  extraArgument<span class="op">:</span> E</a>
<a class="sourceLine" id="cb141-10" title="10">) <span class="kw">=&gt;</span> R<span class="op">;</span></a></code></pre></div>
<p>You will typically want to provide the <code>R</code> (return type) and <code>S</code> (state) generic arguments. Unfortunately, TS does not allow only providing <em>some</em> generic arguments, so the usual values for the other arguments are <code>unknown</code> for <code>E</code> and <code>AnyAction</code> for <code>A</code>:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb142-1" title="1"><span class="im">import</span> <span class="op">{</span> AnyAction <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb142-2" title="2"><span class="im">import</span> <span class="op">{</span> sendMessage <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./store/chat/actions&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb142-3" title="3"><span class="im">import</span> <span class="op">{</span> RootState <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./store&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb142-4" title="4"><span class="im">import</span> <span class="op">{</span> ThunkAction <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;redux-thunk&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb142-5" title="5"></a>
<a class="sourceLine" id="cb142-6" title="6"><span class="im">export</span> <span class="kw">const</span> thunkSendMessage <span class="op">=</span></a>
<a class="sourceLine" id="cb142-7" title="7">  (message<span class="op">:</span> <span class="dt">string</span>)<span class="op">:</span> ThunkAction<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> RootState<span class="op">,</span> <span class="dt">unknown</span><span class="op">,</span> AnyAction<span class="op">&gt;</span> <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb142-8" title="8">  <span class="fu">async</span> (dispatch) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb142-9" title="9">    <span class="kw">const</span> asyncResp <span class="op">=</span> <span class="cf">await</span> <span class="fu">exampleAPI</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb142-10" title="10">    <span class="fu">dispatch</span>(</a>
<a class="sourceLine" id="cb142-11" title="11">      <span class="fu">sendMessage</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb142-12" title="12">        message<span class="op">,</span></a>
<a class="sourceLine" id="cb142-13" title="13">        user<span class="op">:</span> asyncResp<span class="op">,</span></a>
<a class="sourceLine" id="cb142-14" title="14">        timestamp<span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>().<span class="fu">getTime</span>()<span class="op">,</span></a>
<a class="sourceLine" id="cb142-15" title="15">      <span class="op">}</span>)</a>
<a class="sourceLine" id="cb142-16" title="16">    )<span class="op">;</span></a>
<a class="sourceLine" id="cb142-17" title="17">  <span class="op">};</span></a>
<a class="sourceLine" id="cb142-18" title="18"></a>
<a class="sourceLine" id="cb142-19" title="19"><span class="kw">function</span> <span class="fu">exampleAPI</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb142-20" title="20">  <span class="cf">return</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="st">&quot;Async Chat Bot&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb142-21" title="21"><span class="op">}</span></a></code></pre></div>
<p>To reduce repetition, you might want to define a reusable <code>AppThunk</code> type once, in your store file, and then use that type whenever you write a thunk:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb143-1" title="1"><span class="im">export</span> <span class="kw">type</span> AppThunk<span class="op">&lt;</span>ReturnType <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span> <span class="op">=</span> ThunkAction<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb143-2" title="2">  ReturnType<span class="op">,</span></a>
<a class="sourceLine" id="cb143-3" title="3">  RootState<span class="op">,</span></a>
<a class="sourceLine" id="cb143-4" title="4">  unknown<span class="op">,</span></a>
<a class="sourceLine" id="cb143-5" title="5">  AnyAction</a>
<a class="sourceLine" id="cb143-6" title="6"><span class="op">&gt;;</span></a></code></pre></div>
<p>Note that this assumes that there is no meaningful return value from the thunk. If your thunk returns a promise and you want to <a href="../tutorials/essentials/part-5-async-logic.md#checking-thunk-results-in-components">use the returned promise after dispatching the thunk</a>, you’d want to use this as <code>AppThunk&lt;Promise&lt;SomeReturnType&gt;&gt;</code>.</p>
<div class="caution">
<p>Don’t forget that <strong>the default <code>useDispatch</code> hook does not know about thunks</strong>, and so dispatching a thunk will cause a type error. Be sure to <a href="#define-root-state-and-dispatch-types">use an updated form of <code>Dispatch</code> in your components that recognizes thunks as an acceptable type to dispatch</a>.</p>
</div>
<h2 id="usage-with-react-redux">Usage with React Redux</h2>
<p>While <a href="https://react-redux.js.org">React Redux</a> is a separate library from Redux itself, it is commonly used with React.</p>
<p>For a complete guide on how to correctly use React Redux with TypeScript, see <strong><a href="https://react-redux.js.org/using-react-redux/static-typing">the “Static Typing” page in the React Redux docs</a></strong>. This section will highlight the standard patterns.</p>
<p>As mentioned above, React Redux doesn’t ship with its own type definitions. If you are using TypeScript you should install the <a href="https://npm.im/@types/react-redux"><code>@types/react-redux</code> type definitions</a> from npm.</p>
<h3 id="typing-the-useselector-hook">Typing the <code>useSelector</code> hook</h3>
<p>Declare the type of the <code>state</code> parameter in the selector function, and the return type of <code>useSelector</code> will be inferred to match the return type of the selector:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb144-1" title="1"><span class="kw">interface</span> RootState <span class="op">{</span></a>
<a class="sourceLine" id="cb144-2" title="2">  isOn<span class="op">:</span> <span class="dt">boolean</span><span class="op">;</span></a>
<a class="sourceLine" id="cb144-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb144-4" title="4"></a>
<a class="sourceLine" id="cb144-5" title="5"><span class="co">// TS infers type: (state: RootState) =&gt; boolean</span></a>
<a class="sourceLine" id="cb144-6" title="6"><span class="kw">const</span> selectIsOn <span class="op">=</span> (state<span class="op">:</span> RootState) <span class="kw">=&gt;</span> <span class="va">state</span><span class="op">.</span><span class="at">isOn</span><span class="op">;</span></a>
<a class="sourceLine" id="cb144-7" title="7"></a>
<a class="sourceLine" id="cb144-8" title="8"><span class="co">// TS infers `isOn` is boolean</span></a>
<a class="sourceLine" id="cb144-9" title="9"><span class="kw">const</span> isOn <span class="op">=</span> <span class="fu">useSelector</span>(selectIsOn)<span class="op">;</span></a></code></pre></div>
<p>This can also be done inline as well:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb145-1" title="1"><span class="kw">const</span> isOn <span class="op">=</span> <span class="fu">useSelector</span>((state<span class="op">:</span> RootState) <span class="kw">=&gt;</span> <span class="va">state</span><span class="op">.</span><span class="at">isOn</span>)<span class="op">;</span></a></code></pre></div>
<p>However, prefer creating a pre-typed <code>useSelector</code> hook with the correct type of <code>state</code> built-in instead.</p>
<h3 id="typing-the-usedispatch-hook">Typing the <code>useDispatch</code> hook</h3>
<p>By default, the return value of <code>useDispatch</code> is the standard <code>Dispatch</code> type defined by the Redux core types, so no declarations are needed:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb146-1" title="1"><span class="kw">const</span> dispatch <span class="op">=</span> <span class="fu">useDispatch</span>()<span class="op">;</span></a></code></pre></div>
<p>However, prefer creating a pre-typed <code>useAppDispatch</code> hook with the correct type of <code>Dispatch</code> built-in instead.</p>
<h3 id="typing-the-connect-higher-order-component">Typing the <code>connect</code> higher order component</h3>
<p>If you are still using <code>connect</code>, you should use the <code>ConnectedProps&lt;T&gt;</code> type exported by <code>@types/react-redux^7.1.2</code> to infer the types of the props from <code>connect</code> automatically. This requires splitting the <code>connect(mapState, mapDispatch)(MyComponent)</code> call into two parts:</p>
<pre class="tsx"><code>import { connect, ConnectedProps } from &quot;react-redux&quot;;

interface RootState {
  isOn: boolean;
}

const mapState = (state: RootState) =&gt; ({
  isOn: state.isOn,
});

const mapDispatch = {
  toggleOn: () =&gt; ({ type: &quot;TOGGLE_IS_ON&quot; }),
};

const connector = connect(mapState, mapDispatch);

// The inferred type will look like:
// {isOn: boolean, toggleOn: () =&gt; void}
type PropsFromRedux = ConnectedProps&lt;typeof connector&gt;;

type Props = PropsFromRedux &amp; {
  backgroundColor: string;
};

const MyComponent = (props: Props) =&gt; (
  &lt;div style={{ backgroundColor: props.backgroundColor }}&gt;
    &lt;button onClick={props.toggleOn}&gt;
      Toggle is {props.isOn ? &quot;ON&quot; : &quot;OFF&quot;}
    &lt;/button&gt;
  &lt;/div&gt;
);

export default connector(MyComponent);</code></pre>
<h2 id="usage-with-redux-toolkit">Usage with Redux Toolkit</h2>
<p>The <a href="#standard-redux-toolkit-project-setup-with-typescript">Standard Redux Toolkit Project Setup with TypeScript</a> section already covered the normal usage patterns for <code>configureStore</code> and <code>createSlice</code>, and the <a href="https://redux-toolkit.js.org/usage/usage-with-typescript">Redux Toolkit “Usage with TypeScript” page</a> covers all of the RTK APIs in detail.</p>
<p>Here are some additional typing patterns you will commonly see when using RTK.</p>
<h3 id="typing-configurestore">Typing <code>configureStore</code></h3>
<p><code>configureStore</code> infers the type of the state value from the provided root reducer function, so no specific type declarations should be needed.</p>
<p>If you want to add additional middleware to the store, be sure to use the specialized <code>.concat()</code> and <code>.prepend()</code> methods included in the array returned by <code>getDefaultMiddleware()</code>, as those will correctly preserve the types of the middleware you’re adding. (Using plain JS array spreads often loses those types.)</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb148-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="fu">configureStore</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb148-2" title="2">  reducer<span class="op">:</span> rootReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb148-3" title="3">  middleware<span class="op">:</span> (getDefaultMiddleware) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb148-4" title="4">    <span class="fu">getDefaultMiddleware</span>()</a>
<a class="sourceLine" id="cb148-5" title="5">      .<span class="fu">prepend</span>(</a>
<a class="sourceLine" id="cb148-6" title="6">        <span class="co">// correctly typed middlewares can just be used</span></a>
<a class="sourceLine" id="cb148-7" title="7">        additionalMiddleware<span class="op">,</span></a>
<a class="sourceLine" id="cb148-8" title="8">        <span class="co">// you can also type middlewares manually</span></a>
<a class="sourceLine" id="cb148-9" title="9">        untypedMiddleware <span class="im">as</span> Middleware<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb148-10" title="10">          (action<span class="op">:</span> Action<span class="op">&lt;</span><span class="st">&quot;specialAction&quot;</span><span class="op">&gt;</span>) <span class="kw">=&gt;</span> number<span class="op">,</span></a>
<a class="sourceLine" id="cb148-11" title="11">          RootState</a>
<a class="sourceLine" id="cb148-12" title="12">        <span class="op">&gt;</span></a>
<a class="sourceLine" id="cb148-13" title="13">      )</a>
<a class="sourceLine" id="cb148-14" title="14">      <span class="co">// prepend and concat calls can be chained</span></a>
<a class="sourceLine" id="cb148-15" title="15">      .<span class="fu">concat</span>(logger)<span class="op">,</span></a>
<a class="sourceLine" id="cb148-16" title="16"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="matching-actions">Matching Actions</h3>
<p>RTK-generated action creators have a <code>match</code> method that acts as a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type predicate</a>. Calling <code>someActionCreator.match(action)</code> will do a string comparison against the <code>action.type</code> string, and if used as a condition, narrow the type of <code>action</code> down to be the correct TS type:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb149-1" title="1"><span class="kw">const</span> increment <span class="op">=</span> <span class="fu">createAction</span><span class="op">&lt;</span><span class="dt">number</span><span class="op">&gt;</span>(<span class="st">&quot;increment&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb149-2" title="2"><span class="kw">function</span> <span class="fu">test</span>(action<span class="op">:</span> Action) <span class="op">{</span></a>
<a class="sourceLine" id="cb149-3" title="3">  <span class="fu">if</span> (<span class="va">increment</span><span class="op">.</span><span class="fu">match</span>(action)) <span class="op">{</span></a>
<a class="sourceLine" id="cb149-4" title="4">    <span class="co">// action.payload inferred correctly here</span></a>
<a class="sourceLine" id="cb149-5" title="5">    <span class="kw">const</span> num <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="va">action</span><span class="op">.</span><span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb149-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb149-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>This is particularly useful when checking for action types in Redux middleware, such as custom middleware, <code>redux-observable</code>, and RxJS’s <code>filter</code> method.</p>
<h3 id="typing-createslice">Typing <code>createSlice</code></h3>
<h4 id="defining-separate-case-reducers">Defining Separate Case Reducers</h4>
<p>If you have too many case reducers and defining them inline would be messy, or you want to reuse case reducers across slices, you can also define them outside the <code>createSlice</code> call and type them as <code>CaseReducer</code>:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb150-1" title="1"><span class="kw">type</span> State <span class="op">=</span> <span class="dt">number</span><span class="op">;</span></a>
<a class="sourceLine" id="cb150-2" title="2"><span class="kw">const</span> increment<span class="op">:</span> CaseReducer<span class="op">&lt;</span>State<span class="op">,</span> PayloadAction<span class="op">&lt;</span><span class="dt">number</span><span class="op">&gt;&gt;</span> <span class="op">=</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb150-3" title="3">  state <span class="op">+</span> <span class="va">action</span><span class="op">.</span><span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb150-4" title="4"></a>
<a class="sourceLine" id="cb150-5" title="5"><span class="fu">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb150-6" title="6">  name<span class="op">:</span> <span class="st">&quot;test&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb150-7" title="7">  initialState<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb150-8" title="8">  reducers<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb150-9" title="9">    increment<span class="op">,</span></a>
<a class="sourceLine" id="cb150-10" title="10">  <span class="op">},</span></a>
<a class="sourceLine" id="cb150-11" title="11"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="typing-extrareducers">Typing <code>extraReducers</code></h4>
<p>If you are adding an <code>extraReducers</code> field in <code>createSlice</code>, be sure to use the “builder callback” form, as the “plain object” form cannot infer action types correctly. Passing an RTK-generated action creator to <code>builder.addCase()</code> will correctly infer the type of the <code>action</code>:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb151-1" title="1"><span class="kw">const</span> usersSlice <span class="op">=</span> <span class="fu">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb151-2" title="2">  name<span class="op">:</span> <span class="st">&quot;users&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb151-3" title="3">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb151-4" title="4">  reducers<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb151-5" title="5">    <span class="co">// fill in primary logic here</span></a>
<a class="sourceLine" id="cb151-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb151-7" title="7">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb151-8" title="8">  extraReducers<span class="op">:</span> (builder) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb151-9" title="9">    <span class="va">builder</span><span class="op">.</span><span class="fu">addCase</span>(<span class="va">fetchUserById</span><span class="op">.</span><span class="at">pending</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb151-10" title="10">      <span class="co">// both `state` and `action` are now correctly typed</span></a>
<a class="sourceLine" id="cb151-11" title="11">      <span class="co">// based on the slice state and the `pending` action creator</span></a>
<a class="sourceLine" id="cb151-12" title="12">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb151-13" title="13">  <span class="op">},</span></a>
<a class="sourceLine" id="cb151-14" title="14">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb151-15" title="15"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="typing-prepare-callbacks">Typing <code>prepare</code> Callbacks</h4>
<p>If you want to add a <code>meta</code> or <code>error</code> property to your action, or customize the <code>payload</code> of your action, you have to use the <code>prepare</code> notation for defining the case reducer. Using this notation with TypeScript looks like:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb152-1" title="1"><span class="kw">const</span> blogSlice <span class="op">=</span> <span class="fu">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb152-2" title="2">  name<span class="op">:</span> <span class="st">&quot;blogData&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb152-3" title="3">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb152-4" title="4">  reducers<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb152-5" title="5">    <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb152-6" title="6">    receivedAll<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb152-7" title="7">      <span class="fu">reducer</span>(</a>
<a class="sourceLine" id="cb152-8" title="8">        state<span class="op">,</span></a>
<a class="sourceLine" id="cb152-9" title="9">        action<span class="op">:</span> PayloadAction<span class="op">&lt;</span>Page<span class="op">[],</span> <span class="dt">string</span><span class="op">,</span> <span class="op">{</span> currentPage<span class="op">:</span> <span class="dt">number</span> <span class="op">}&gt;</span></a>
<a class="sourceLine" id="cb152-10" title="10">      ) <span class="op">{</span></a>
<a class="sourceLine" id="cb152-11" title="11">        <span class="va">state</span><span class="op">.</span><span class="at">all</span> <span class="op">=</span> <span class="va">action</span><span class="op">.</span><span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb152-12" title="12">        <span class="va">state</span><span class="op">.</span><span class="at">meta</span> <span class="op">=</span> <span class="va">action</span><span class="op">.</span><span class="at">meta</span><span class="op">;</span></a>
<a class="sourceLine" id="cb152-13" title="13">      <span class="op">},</span></a>
<a class="sourceLine" id="cb152-14" title="14">      <span class="fu">prepare</span>(payload<span class="op">:</span> Page<span class="op">[],</span> currentPage<span class="op">:</span> <span class="dt">number</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb152-15" title="15">        <span class="cf">return</span> <span class="op">{</span> payload<span class="op">,</span> meta<span class="op">:</span> <span class="op">{</span> currentPage <span class="op">}</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb152-16" title="16">      <span class="op">},</span></a>
<a class="sourceLine" id="cb152-17" title="17">    <span class="op">},</span></a>
<a class="sourceLine" id="cb152-18" title="18">    <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb152-19" title="19">  <span class="op">},</span></a>
<a class="sourceLine" id="cb152-20" title="20"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h4 id="fixing-circular-types-in-exported-slices">Fixing Circular Types in Exported Slices</h4>
<p>Finally, on rare occasions you might need to export the slice reducer with a specific type in order to break a circular type dependency problem. This might look like:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb153-1" title="1"><span class="im">export</span> <span class="im">default</span> <span class="va">counterSlice</span><span class="op">.</span><span class="at">reducer</span> <span class="im">as</span> Reducer<span class="op">&lt;</span>Counter<span class="op">&gt;;</span></a></code></pre></div>
<h3 id="typing-createasyncthunk">Typing <code>createAsyncThunk</code></h3>
<p>For basic usage, the only type you need to provide for <code>createAsyncThunk</code> is the type of the single argument for your payload creation callback. You should also ensure that the return value of the callback is typed correctly:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb154-1" title="1"><span class="kw">const</span> fetchUserById <span class="op">=</span> <span class="fu">createAsyncThunk</span>(</a>
<a class="sourceLine" id="cb154-2" title="2">  <span class="st">&quot;users/fetchById&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb154-3" title="3">  <span class="co">// Declare the type your function argument here:</span></a>
<a class="sourceLine" id="cb154-4" title="4">  <span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb154-5" title="5">  <span class="fu">async</span> (userId<span class="op">:</span> <span class="dt">number</span>) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb154-6" title="6">    <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="vs">`https://reqres.in/api/users/</span><span class="sc">${</span>userId<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb154-7" title="7">    <span class="co">// Inferred return type: Promise&lt;MyData&gt;</span></a>
<a class="sourceLine" id="cb154-8" title="8">    <span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb154-9" title="9">    <span class="fu">return</span> (<span class="cf">await</span> <span class="va">response</span><span class="op">.</span><span class="fu">json</span>()) <span class="im">as</span> MyData<span class="op">;</span></a>
<a class="sourceLine" id="cb154-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb154-11" title="11">)<span class="op">;</span></a>
<a class="sourceLine" id="cb154-12" title="12"></a>
<a class="sourceLine" id="cb154-13" title="13"><span class="co">// the parameter of `fetchUserById` is automatically inferred to `number` here</span></a>
<a class="sourceLine" id="cb154-14" title="14"><span class="co">// and dispatching the resulting thunkAction will return a Promise of a correctly</span></a>
<a class="sourceLine" id="cb154-15" title="15"><span class="co">// typed &quot;fulfilled&quot; or &quot;rejected&quot; action.</span></a>
<a class="sourceLine" id="cb154-16" title="16"><span class="kw">const</span> lastReturnedAction <span class="op">=</span> <span class="cf">await</span> <span class="va">store</span><span class="op">.</span><span class="fu">dispatch</span>(<span class="fu">fetchUserById</span>(<span class="dv">3</span>))<span class="op">;</span></a></code></pre></div>
<p>If you need to modify the types of the <code>thunkApi</code> parameter, such as supplying the type of the <code>state</code> returned by <code>getState()</code>, you must supply the first two generic arguments for return type and payload argument, plus whicher “thunkApi argument fields” are relevant in an object:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb155-1" title="1"><span class="kw">const</span> fetchUserById <span class="op">=</span> createAsyncThunk<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb155-2" title="2">  <span class="co">//highlight-start</span></a>
<a class="sourceLine" id="cb155-3" title="3">  <span class="co">// Return type of the payload creator</span></a>
<a class="sourceLine" id="cb155-4" title="4">  MyData<span class="op">,</span></a>
<a class="sourceLine" id="cb155-5" title="5">  <span class="co">// First argument to the payload creator</span></a>
<a class="sourceLine" id="cb155-6" title="6">  number<span class="op">,</span></a>
<a class="sourceLine" id="cb155-7" title="7">  <span class="op">{</span></a>
<a class="sourceLine" id="cb155-8" title="8">    <span class="co">// Optional fields for defining thunkApi field types</span></a>
<a class="sourceLine" id="cb155-9" title="9">    dispatch<span class="op">:</span> AppDispatch<span class="op">;</span></a>
<a class="sourceLine" id="cb155-10" title="10">    state<span class="op">:</span> State<span class="op">;</span></a>
<a class="sourceLine" id="cb155-11" title="11">    extra<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb155-12" title="12">      jwt<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></a>
<a class="sourceLine" id="cb155-13" title="13">    <span class="op">};</span></a>
<a class="sourceLine" id="cb155-14" title="14">  <span class="op">}</span></a>
<a class="sourceLine" id="cb155-15" title="15">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb155-16" title="16"><span class="op">&gt;</span>(<span class="st">&quot;users/fetchById&quot;</span><span class="op">,</span> <span class="fu">async</span> (userId<span class="op">,</span> thunkApi) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb155-17" title="17">  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="vs">`https://reqres.in/api/users/</span><span class="sc">${</span>userId<span class="sc">}</span><span class="vs">`</span><span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb155-18" title="18">    headers<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb155-19" title="19">      Authorization<span class="op">:</span> <span class="vs">`Bearer </span><span class="sc">${</span><span class="va">thunkApi</span><span class="op">.</span><span class="va">extra</span><span class="op">.</span><span class="at">jwt</span><span class="sc">}</span><span class="vs">`</span><span class="op">,</span></a>
<a class="sourceLine" id="cb155-20" title="20">    <span class="op">},</span></a>
<a class="sourceLine" id="cb155-21" title="21">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb155-22" title="22">  <span class="fu">return</span> (<span class="cf">await</span> <span class="va">response</span><span class="op">.</span><span class="fu">json</span>()) <span class="im">as</span> MyData<span class="op">;</span></a>
<a class="sourceLine" id="cb155-23" title="23"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="typing-createentityadapter">Typing <code>createEntityAdapter</code></h3>
<p>Typing <code>createEntityAdapter</code> only requires you to specify the entity type as the single generic argument. This typically looks like:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb156-1" title="1"><span class="kw">interface</span> Book <span class="op">{</span></a>
<a class="sourceLine" id="cb156-2" title="2">  bookId<span class="op">:</span> <span class="dt">number</span><span class="op">;</span></a>
<a class="sourceLine" id="cb156-3" title="3">  title<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></a>
<a class="sourceLine" id="cb156-4" title="4">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb156-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb156-6" title="6"></a>
<a class="sourceLine" id="cb156-7" title="7"><span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb156-8" title="8"><span class="kw">const</span> booksAdapter <span class="op">=</span> <span class="fu">createEntityAdapter</span><span class="op">&lt;</span>Book<span class="op">&gt;</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb156-9" title="9">  selectId<span class="op">:</span> (book) <span class="kw">=&gt;</span> <span class="va">book</span><span class="op">.</span><span class="at">bookId</span><span class="op">,</span></a>
<a class="sourceLine" id="cb156-10" title="10">  sortComparer<span class="op">:</span> (a<span class="op">,</span> b) <span class="kw">=&gt;</span> <span class="va">a</span><span class="op">.</span><span class="va">title</span><span class="op">.</span><span class="fu">localeCompare</span>(<span class="va">b</span><span class="op">.</span><span class="at">title</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb156-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb156-12" title="12"></a>
<a class="sourceLine" id="cb156-13" title="13"><span class="kw">const</span> booksSlice <span class="op">=</span> <span class="fu">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb156-14" title="14">  name<span class="op">:</span> <span class="st">&quot;books&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb156-15" title="15">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb156-16" title="16">  <span class="co">// The type of the state is inferred here</span></a>
<a class="sourceLine" id="cb156-17" title="17">  initialState<span class="op">:</span> <span class="va">booksAdapter</span><span class="op">.</span><span class="fu">getInitialState</span>()<span class="op">,</span></a>
<a class="sourceLine" id="cb156-18" title="18">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb156-19" title="19">  reducers<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb156-20" title="20">    bookAdded<span class="op">:</span> <span class="va">booksAdapter</span><span class="op">.</span><span class="at">addOne</span><span class="op">,</span></a>
<a class="sourceLine" id="cb156-21" title="21">    <span class="fu">booksReceived</span>(state<span class="op">,</span> action<span class="op">:</span> PayloadAction<span class="op">&lt;{</span> books<span class="op">:</span> Book<span class="op">[]</span> <span class="op">}&gt;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb156-22" title="22">      <span class="va">booksAdapter</span><span class="op">.</span><span class="fu">setAll</span>(state<span class="op">,</span> <span class="va">action</span><span class="op">.</span><span class="va">payload</span><span class="op">.</span><span class="at">books</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb156-23" title="23">    <span class="op">},</span></a>
<a class="sourceLine" id="cb156-24" title="24">  <span class="op">},</span></a>
<a class="sourceLine" id="cb156-25" title="25"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h2 id="additional-recommendations">Additional Recommendations</h2>
<h3 id="use-the-react-redux-hooks-api">Use the React Redux Hooks API</h3>
<p><strong>We recommend using the React Redux hooks API as the default approach</strong>. The hooks API is much simpler to use with TypeScript, as <code>useSelector</code> is a simple hook that takes a selector function, and the return type is easily inferred from the type of the <code>state</code> argument.</p>
<p>While <code>connect</code> still works fine, and <em>can</em> be typed, it’s much more difficult to type correctly.</p>
<h3 id="avoid-action-type-unions">Avoid Action Type Unions</h3>
<p><strong>We specifically recommend <em>against</em> trying to create unions of action types</strong>, as it provides no real benefit and actually misleads the compiler in some ways. See RTK maintainer Lenz Weber’s post <a href="https://phryneas.de/redux-typescript-no-discriminating-union">Do Not Create Union Types with Redux Action Types</a> for an explanation of why this is a problem.</p>
<p>In addition, if you’re using <code>createSlice</code>, you already know that all actions defined by that slice are being handled correctly.</p>
<h2 id="resources">Resources</h2>
<p>For further information, see these additional resources:</p>
<ul>
<li>Redux library documentation:
<ul>
<li><a href="https://react-redux.js.org/using-react-redux/static-typing">React Redux docs: Static Typing</a>: Examples of how to use the React Redux APIs with TypeScript</li>
<li><a href="https://redux-toolkit.js.org/usage/usage-with-typescript">Redux Toolkit docs: Usage with TypeScript</a>: Examples of how to use the Redux Toolkit APIs with TypeScript</li>
</ul></li>
<li>React + Redux + TypeScript guides:
<ul>
<li><a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet">React+TypeScript Cheatsheet</a>: a comprehensive guide to using React with TypeScript</li>
<li><a href="https://github.com/piotrwitek/react-redux-typescript-guide">React + Redux in TypeScript Guide</a>: extensive information on patterns for using React and Redux with TypeScript
<ul>
<li><em>Note: while this guide has some useful info, many of the patterns it shows go against our recommended practices shown in this page, such as using action type unions. We link this out of completeness</em></li>
</ul></li>
</ul></li>
<li>Other articles:
<ul>
<li><a href="https://phryneas.de/redux-typescript-no-discriminating-union">Do Not Create Union Types with Redux Action Types</a></li>
<li><a href="https://www.matthewgerstman.com/tech/redux-code-split-typecheck/">Redux with Code-Splitting and Type Checking</a></li>
</ul></li>
</ul>
<hr />
<p>id: using-object-spread-operator title: Using Object Spread Operator</p>
<hr />
<h1 id="using-object-spread-operator">Using Object Spread Operator</h1>
<p>Since one of the core tenets of Redux is to never mutate state, you’ll often find yourself using <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> to create copies of objects with new or updated values. For example, in the <code>todoApp</code> below <code>Object.assign()</code> is used to return a new <code>state</code> object with an updated <code>visibilityFilter</code> property:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb157-1" title="1"><span class="kw">function</span> <span class="at">todoApp</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb157-2" title="2">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb157-3" title="3">    <span class="cf">case</span> <span class="dt">SET_VISIBILITY_FILTER</span><span class="op">:</span></a>
<a class="sourceLine" id="cb157-4" title="4">      <span class="cf">return</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> state<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb157-5" title="5">        <span class="dt">visibilityFilter</span><span class="op">:</span> <span class="va">action</span>.<span class="at">filter</span><span class="op">,</span></a>
<a class="sourceLine" id="cb157-6" title="6">      <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb157-7" title="7">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb157-8" title="8">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb157-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb157-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>While effective, using <code>Object.assign()</code> can quickly make simple reducers difficult to read given its rather verbose syntax.</p>
<p>An alternative approach is to use the <a href="https://github.com/tc39/proposal-object-rest-spread">object spread syntax</a> recently added to the JavaScript specification. It lets you use the spread (<code>...</code>) operator to copy enumerable properties from one object to another in a more succinct way. The object spread operator is conceptually similar to the ES6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">array spread operator</a>. We can simplify the <code>todoApp</code> example above by using the object spread syntax:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb158-1" title="1"><span class="kw">function</span> <span class="at">todoApp</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb158-2" title="2">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb158-3" title="3">    <span class="cf">case</span> <span class="dt">SET_VISIBILITY_FILTER</span><span class="op">:</span></a>
<a class="sourceLine" id="cb158-4" title="4">      <span class="cf">return</span> <span class="op">{</span> ...<span class="at">state</span><span class="op">,</span> <span class="dt">visibilityFilter</span><span class="op">:</span> <span class="va">action</span>.<span class="at">filter</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb158-5" title="5">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb158-6" title="6">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb158-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb158-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>The advantage of using the object spread syntax becomes more apparent when you’re composing complex objects. Below <code>getAddedIds</code> maps an array of <code>id</code> values to an array of objects with values returned from <code>getProduct</code> and <code>getQuantity</code>.</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb159-1" title="1"><span class="cf">return</span> <span class="at">getAddedIds</span>(<span class="va">state</span>.<span class="at">cart</span>).<span class="at">map</span>((id) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb159-2" title="2">  <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> <span class="at">getProduct</span>(<span class="va">state</span>.<span class="at">products</span><span class="op">,</span> id)<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb159-3" title="3">    <span class="dt">quantity</span><span class="op">:</span> <span class="at">getQuantity</span>(<span class="va">state</span>.<span class="at">cart</span><span class="op">,</span> id)<span class="op">,</span></a>
<a class="sourceLine" id="cb159-4" title="4">  <span class="op">}</span>)</a>
<a class="sourceLine" id="cb159-5" title="5">)<span class="op">;</span></a></code></pre></div>
<p>Object spread lets us simplify the above <code>map</code> call to:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb160-1" title="1"><span class="cf">return</span> <span class="at">getAddedIds</span>(<span class="va">state</span>.<span class="at">cart</span>).<span class="at">map</span>((id) <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb160-2" title="2">  ...<span class="at">getProduct</span>(<span class="va">state</span>.<span class="at">products</span><span class="op">,</span> id)<span class="op">,</span></a>
<a class="sourceLine" id="cb160-3" title="3">  <span class="dt">quantity</span><span class="op">:</span> <span class="at">getQuantity</span>(<span class="va">state</span>.<span class="at">cart</span><span class="op">,</span> id)<span class="op">,</span></a>
<a class="sourceLine" id="cb160-4" title="4"><span class="op">}</span>))<span class="op">;</span></a></code></pre></div>
<p>While the object spread syntax is a <a href="https://github.com/tc39/proposal-object-rest-spread#status-of-this-proposal">Stage 4</a> proposal for ECMAScript and accepted for the 2018 specification release, you will still need to use a transpiler such as <a href="https://babeljs.io/">Babel</a> to use it in production systems. You should use the <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-env"><code>env</code></a> preset, install <a href="https://babeljs.io/docs/en/babel-plugin-proposal-object-rest-spread"><code>@babel/plugin-proposal-object-rest-spread</code></a> and add it individually to the <code>plugins</code> array in your <code>.babelrc</code>.</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb161-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb161-2" title="2">  <span class="dt">&quot;presets&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;@babel/preset-env&quot;</span><span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb161-3" title="3">  <span class="dt">&quot;plugins&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb161-4" title="4"><span class="fu">}</span></a></code></pre></div>
<blockquote>
<h5 id="note-on-object-spread-operator">Note on Object Spread Operator</h5>
</blockquote>
<blockquote>
<p>Like the Array Spread Operator, the Object Spread Operator creates a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals">shallow clone</a> of the original object. In other words, for multidimensional source objects, elements in the copied object at a depth greater than one are mere references to the source object (with the exception of <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitives</a>, which are copied). Thus, you cannot reliably use the Object Spread Operator (<code>...</code>) for deep cloning objects.</p>
</blockquote>
<hr />
<p>id: writing-tests title: Writing Tests description: ‘Usage &gt; Writing Tests: recommended practices and setup for testing Redux apps’</p>
<hr />
<h1 id="writing-tests">Writing Tests</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>Recommended practices for testing apps using Redux</li>
<li>Examples of test configuration and setup</li>
</ul>
<p>:::</p>
<h2 id="guiding-principles">Guiding Principles</h2>
<p>The guiding principles for testing Redux logic closely follow that of React Testing Library:</p>
<blockquote>
<p><a href="https://twitter.com/kentcdodds/status/977018512689455106">The more your tests resemble the way your software is used, the more confidence they can give you.</a> - Kent C. Dodds</p>
</blockquote>
<p>Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking. However, you should consider whether each piece of your Redux code needs it’s own dedicated tests. In the majority of scenarios, the end-user does not know, and does not care whether Redux is used within the application at all. As such, the Redux code can be treated as an implementation detail of the app, without requiring explicit tests for the Redux code in many circumstances.</p>
<p>The general advice for testing an app using Redux is as follows:</p>
<ul>
<li>Use integration tests for everything working together. I.e. for a React app using Redux, render a <code>&lt;Provider&gt;</code> with a real store instance wrapping the component/s being tested. Interactions with the page being tested should use real Redux logic, with API calls mocked out so app code doesn’t have to change, and assert that the UI is updated appropriately.</li>
<li>If needed, use basic unit tests for pure functions such as particularly complex reducers or selectors. However, in many cases, these are just implementation details that are covered by integration tests instead.</li>
</ul>
<div class="info">
<p>For background on why we recommend integration-style tests, see:</p>
<ul>
<li>Kent C Dodds: <a href="https://kentcdodds.com/blog/testing-implementation-details">Testing Implementation Details</a>: thoughts on why he recommends avoiding testing implementation details.</li>
<li>Mark Erikson: <a href="https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/">Blogged Answers: The Evolution of Redux Testing Approaches</a>: thoughts on how Redux testing has evolved from ‘isolation’ to ‘integration’ over time.</li>
</ul>
</div>
<h2 id="setting-up-1">Setting Up</h2>
<p>Redux can be tested with any test runner, however in the examples below we will be using <a href="https://facebook.github.io/jest/">Jest</a>, a popular testing framework. Note that it runs in a Node environment, so you won’t have access to the real DOM. Jest can instead use <a href="https://github.com/jsdom/jsdom">jsdom</a> to emulate portions of the browser in a test environment.</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb162-1" title="1"><span class="ex">npm</span> install --save-dev jest</a></code></pre></div>
<p>To use it together with <a href="https://babeljs.io">Babel</a>, you will need to install <code>babel-jest</code>:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb163-1" title="1"><span class="ex">npm</span> install --save-dev babel-jest</a></code></pre></div>
<p>and configure it to use <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-env">babel-preset-env</a> features in <code>.babelrc</code>:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb164-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb164-2" title="2">  <span class="st">&quot;presets&quot;</span><span class="op">:</span> [<span class="st">&quot;@babel/preset-env&quot;</span>]</a>
<a class="sourceLine" id="cb164-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>Then, add this to <code>scripts</code> in your <code>package.json</code>:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb165-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb165-2" title="2">  ...</a>
<a class="sourceLine" id="cb165-3" title="3">  <span class="st">&quot;scripts&quot;</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb165-4" title="4">    ...</a>
<a class="sourceLine" id="cb165-5" title="5">    <span class="st">&quot;test&quot;</span><span class="op">:</span> <span class="st">&quot;jest&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb165-6" title="6">    <span class="st">&quot;test:watch&quot;</span><span class="op">:</span> <span class="st">&quot;npm test -- --watch&quot;</span></a>
<a class="sourceLine" id="cb165-7" title="7">  <span class="op">},</span></a>
<a class="sourceLine" id="cb165-8" title="8">  ...</a>
<a class="sourceLine" id="cb165-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>and run <code>npm test</code> to run it once, or <code>npm run test:watch</code> to test on every file change.</p>
<h2 id="action-creators-thunks">Action Creators &amp; Thunks</h2>
<p>In Redux, action creators are functions which return plain objects. Our recommendation is not to write action creators manually, but instead have them generated automatically by <a href="https://redux-toolkit.js.org/api/createSlice#return-value"><code>createSlice</code></a>, or created via <a href="https://redux-toolkit.js.org/api/createAction"><code>createAction</code></a> from <a href="https://redux-toolkit.js.org/introduction/getting-started"><code>@reduxjs/toolkit</code></a>. As such, you should not feel the need to test action creators by themselves (the Redux Toolkit maintainers have already done that for you!).</p>
<p>The return value of action creators is considered an implementation detail within your application, and when following an integration testing style, do not need explicit tests.</p>
<p>Similarly for thunks using <a href="https://github.com/gaearon/redux-thunk">Redux Thunk</a>, our recommendation is not to write them manually, but instead use <a href="https://redux-toolkit.js.org/api/createAsyncThunk"><code>createAsyncThunk</code></a> from <a href="https://redux-toolkit.js.org/introduction/getting-started"><code>@reduxjs/toolkit</code></a>. The thunk handles dispatching the appropriate <code>pending</code>, <code>fulfilled</code> and <code>rejected</code> action types for you based on the lifecycle of the thunk.</p>
<p>We consider thunk behavior to be an implementation detail of the application, and recommend that it be covered by testing the group of components (or whole app) using it, rather than testing the thunk in isolation.</p>
<p>Our recommendation is to mock async requests at the <code>fetch/xhr</code> level using tools like <a href="https://mswjs.io/"><code>msw</code></a>, <a href="https://miragejs.com/"><code>miragejs</code></a>, <a href="https://github.com/jefflau/jest-fetch-mock#readme"><code>jest-fetch-mock</code></a>, <a href="https://www.wheresrhys.co.uk/fetch-mock/"><code>fetch-mock</code></a>, or similar. By mocking requests at this level, none of the thunk logic has to change in a test - the thunk still tries to make a “real” async request, it just gets intercepted. See the <a href="#example-1">components example</a> for an example of testing a component which internally includes the behavior of a thunk.</p>
<div class="info">
<p>If you prefer, or are otherwise required to write unit tests for your action creators or thunks, refer to the tests that Redux Toolkit uses for <a href="https://github.com/reduxjs/redux-toolkit/blob/635d6d5e513e13dd59cd717f600d501b30ca2381/src/tests/createAction.test.ts"><code>createAction</code></a> and <a href="https://github.com/reduxjs/redux-toolkit/blob/635d6d5e513e13dd59cd717f600d501b30ca2381/src/tests/createAsyncThunk.test.ts"><code>createAsyncThunk</code></a>.</p>
</div>
<h2 id="reducers-3">Reducers</h2>
<p>Reducers are pure functions that return the new state after applying the action to the previous state. In the majority of cases, the reducer is an implementation detail that does not need explicit tests. However, if your reducer contains particularly complex logic that you would like the confidence of having unit tests for, reducers can be easily tested.</p>
<p>Because reducers are pure functions, testing them should be straightforward. Call the reducer with a specific input <code>state</code> and <code>action</code>, and assert that the result state matches expectations.</p>
<h4 id="example">Example</h4>
<div class="sourceCode" id="cb166"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb166-1" title="1"><span class="im">import</span> <span class="op">{</span> createSlice <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb166-2" title="2"></a>
<a class="sourceLine" id="cb166-3" title="3"><span class="kw">const</span> initialState <span class="op">=</span> [</a>
<a class="sourceLine" id="cb166-4" title="4">  <span class="op">{</span></a>
<a class="sourceLine" id="cb166-5" title="5">    <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Use Redux&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-6" title="6">    <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-7" title="7">    <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-8" title="8">  <span class="op">},</span></a>
<a class="sourceLine" id="cb166-9" title="9">]<span class="op">;</span></a>
<a class="sourceLine" id="cb166-10" title="10"></a>
<a class="sourceLine" id="cb166-11" title="11"><span class="kw">const</span> todosSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb166-12" title="12">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;todos&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-13" title="13">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb166-14" title="14">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb166-15" title="15">    <span class="at">todoAdded</span>(state<span class="op">,</span> <span class="dt">action</span><span class="op">:</span> PayloadAction<span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb166-16" title="16">      <span class="va">state</span>.<span class="at">push</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb166-17" title="17">        <span class="dt">id</span><span class="op">:</span> <span class="va">state</span>.<span class="at">reduce</span>((maxId<span class="op">,</span> todo) <span class="kw">=&gt;</span> <span class="va">Math</span>.<span class="at">max</span>(<span class="va">todo</span>.<span class="at">id</span><span class="op">,</span> maxId)<span class="op">,</span> <span class="dv">-1</span>) <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-18" title="18">        <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-19" title="19">        <span class="dt">text</span><span class="op">:</span> <span class="va">action</span>.<span class="at">payload</span><span class="op">,</span></a>
<a class="sourceLine" id="cb166-20" title="20">      <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb166-21" title="21">    <span class="op">},</span></a>
<a class="sourceLine" id="cb166-22" title="22">  <span class="op">},</span></a>
<a class="sourceLine" id="cb166-23" title="23"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb166-24" title="24"></a>
<a class="sourceLine" id="cb166-25" title="25"><span class="im">export</span> <span class="kw">const</span> <span class="op">{</span> todoAdded <span class="op">}</span> <span class="op">=</span> <span class="va">todosSlice</span>.<span class="at">actions</span><span class="op">;</span></a>
<a class="sourceLine" id="cb166-26" title="26"></a>
<a class="sourceLine" id="cb166-27" title="27"><span class="im">export</span> <span class="im">default</span> <span class="va">todosSlice</span>.<span class="at">reducer</span><span class="op">;</span></a></code></pre></div>
<p>can be tested like:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb167-1" title="1"><span class="im">import</span> reducer<span class="op">,</span> <span class="op">{</span> todoAdded <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./todosSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb167-2" title="2"></a>
<a class="sourceLine" id="cb167-3" title="3"><span class="at">test</span>(<span class="st">&quot;should return the initial state&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb167-4" title="4">  <span class="at">expect</span>(<span class="at">reducer</span>(<span class="kw">undefined</span><span class="op">,</span> <span class="op">{}</span>)).<span class="at">toEqual</span>([</a>
<a class="sourceLine" id="cb167-5" title="5">    <span class="op">{</span></a>
<a class="sourceLine" id="cb167-6" title="6">      <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Use Redux&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-7" title="7">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-8" title="8">      <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-9" title="9">    <span class="op">},</span></a>
<a class="sourceLine" id="cb167-10" title="10">  ])<span class="op">;</span></a>
<a class="sourceLine" id="cb167-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb167-12" title="12"></a>
<a class="sourceLine" id="cb167-13" title="13"><span class="at">test</span>(<span class="st">&quot;should handle a todo being added to an empty list&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb167-14" title="14">  <span class="kw">const</span> previousState <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb167-15" title="15">  <span class="at">expect</span>(<span class="at">reducer</span>(previousState<span class="op">,</span> <span class="at">todoAdded</span>(<span class="st">&quot;Run the tests&quot;</span>))).<span class="at">toEqual</span>([</a>
<a class="sourceLine" id="cb167-16" title="16">    <span class="op">{</span></a>
<a class="sourceLine" id="cb167-17" title="17">      <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Run the tests&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-18" title="18">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-19" title="19">      <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-20" title="20">    <span class="op">},</span></a>
<a class="sourceLine" id="cb167-21" title="21">  ])<span class="op">;</span></a>
<a class="sourceLine" id="cb167-22" title="22"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb167-23" title="23"></a>
<a class="sourceLine" id="cb167-24" title="24"><span class="at">test</span>(<span class="st">&quot;should handle a todo being added to an existing list&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb167-25" title="25">  <span class="kw">const</span> previousState <span class="op">=</span> [</a>
<a class="sourceLine" id="cb167-26" title="26">    <span class="op">{</span></a>
<a class="sourceLine" id="cb167-27" title="27">      <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Run the tests&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-28" title="28">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-29" title="29">      <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-30" title="30">    <span class="op">},</span></a>
<a class="sourceLine" id="cb167-31" title="31">  ]<span class="op">;</span></a>
<a class="sourceLine" id="cb167-32" title="32">  <span class="at">expect</span>(<span class="at">reducer</span>(previousState<span class="op">,</span> <span class="at">todoAdded</span>(<span class="st">&quot;Use Redux&quot;</span>))).<span class="at">toEqual</span>([</a>
<a class="sourceLine" id="cb167-33" title="33">    <span class="op">{</span></a>
<a class="sourceLine" id="cb167-34" title="34">      <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Run the tests&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-35" title="35">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-36" title="36">      <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-37" title="37">    <span class="op">},</span></a>
<a class="sourceLine" id="cb167-38" title="38">    <span class="op">{</span></a>
<a class="sourceLine" id="cb167-39" title="39">      <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Use Redux&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-40" title="40">      <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-41" title="41">      <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb167-42" title="42">    <span class="op">},</span></a>
<a class="sourceLine" id="cb167-43" title="43">  ])<span class="op">;</span></a>
<a class="sourceLine" id="cb167-44" title="44"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h2 id="components">Components</h2>
<p>Our recommendation for testing components that include Redux code is via integration tests that include everything working together, with assertions aimed at verifying that the app behaves the way you expect when the user interacts with it in a given manner.</p>
<p>First, we will install <a href="https://testing-library.com/docs/react-testing-library/intro">React Testing Library</a>. React Testing Library is a simple and complete React DOM testing utility that encourages good testing practices. It uses react-dom’s <code>render</code> function and <code>act</code> from react-dom/tests-utils.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb168-1" title="1"><span class="ex">npm</span> install --save-dev @testing-library/react</a></code></pre></div>
<p>If you are using jest, we also recommend installing <a href="https://github.com/testing-library/jest-dom">jest-dom</a> as it provides a set of custom jest matchers that you can use to extend jest. These will make your tests more declarative, clear to read and to maintain. jest-dom is being used in the examples below.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb169-1" title="1"><span class="ex">npm</span> install --save-dev @testing-library/jest-dom</a></code></pre></div>
<h4 id="example-1">Example</h4>
<p>Consider the following <code>userSlice</code> slice and <code>App</code> component:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb170-1" title="1"><span class="im">import</span> <span class="op">{</span> createSlice<span class="op">,</span> createAsyncThunk <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-2" title="2"><span class="im">import</span> <span class="op">{</span> userAPI <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./userAPI&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-3" title="3"></a>
<a class="sourceLine" id="cb170-4" title="4"><span class="im">export</span> <span class="kw">const</span> fetchUser <span class="op">=</span> <span class="at">createAsyncThunk</span>(<span class="st">&quot;user/fetchUser&quot;</span><span class="op">,</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb170-5" title="5">  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="va">userAPI</span>.<span class="at">fetchUser</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb170-6" title="6">  <span class="cf">return</span> <span class="va">response</span>.<span class="at">data</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb170-8" title="8"></a>
<a class="sourceLine" id="cb170-9" title="9"><span class="kw">const</span> userSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb170-10" title="10">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;user&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb170-11" title="11">  <span class="dt">initialState</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb170-12" title="12">    <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;No user&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb170-13" title="13">    <span class="dt">status</span><span class="op">:</span> <span class="st">&quot;idle&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb170-14" title="14">  <span class="op">},</span></a>
<a class="sourceLine" id="cb170-15" title="15">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{},</span></a>
<a class="sourceLine" id="cb170-16" title="16">  <span class="dt">extraReducers</span><span class="op">:</span> (builder) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb170-17" title="17">    <span class="va">builder</span>.<span class="at">addCase</span>(<span class="va">fetchUser</span>.<span class="at">pending</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb170-18" title="18">      <span class="va">state</span>.<span class="at">status</span> <span class="op">=</span> <span class="st">&quot;loading&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-19" title="19">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb170-20" title="20">    <span class="va">builder</span>.<span class="at">addCase</span>(<span class="va">fetchUser</span>.<span class="at">fulfilled</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb170-21" title="21">      <span class="va">state</span>.<span class="at">status</span> <span class="op">=</span> <span class="st">&quot;complete&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-22" title="22">      <span class="va">state</span>.<span class="at">name</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-23" title="23">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb170-24" title="24">  <span class="op">},</span></a>
<a class="sourceLine" id="cb170-25" title="25"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb170-26" title="26"></a>
<a class="sourceLine" id="cb170-27" title="27"><span class="im">export</span> <span class="kw">const</span> selectUser <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">user</span>.<span class="at">name</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-28" title="28"><span class="im">export</span> <span class="kw">const</span> selectUserFetchStatus <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">user</span>.<span class="at">status</span><span class="op">;</span></a>
<a class="sourceLine" id="cb170-29" title="29"></a>
<a class="sourceLine" id="cb170-30" title="30"><span class="im">export</span> <span class="im">default</span> <span class="va">userSlice</span>.<span class="at">reducer</span><span class="op">;</span></a></code></pre></div>
<pre class="jsx"><code>import React from &quot;react&quot;;
import { useDispatch, useSelector } from &quot;react-redux&quot;;
import { fetchUser, selectUser, selectUserFetchStatus } from &quot;./userSlice&quot;;

export default function App() {
  const dispatch = useDispatch();
  const user = useSelector(selectUser);
  const userFetchStatus = useSelector(selectUserFetchStatus);

  return (
    &lt;div&gt;
      {/* Display the current user name */}
      &lt;div&gt;{user}&lt;/div&gt;
      {/* On button click, dispatch a thunk action to fetch a user */}
      &lt;button onClick={() =&gt; dispatch(fetchUser())}&gt;Fetch user&lt;/button&gt;
      {/* At any point if we&#39;re fetching a user, display that on the UI */}
      {userFetchStatus === &quot;loading&quot; &amp;&amp; &lt;div&gt;Fetching user...&lt;/div&gt;}
    &lt;/div&gt;
  );
}</code></pre>
<p>This app involves thunks, reducers and selectors. All of these can be tested by writing an integration test with the following in mind:</p>
<ul>
<li>Upon first loading the app, there should be no user yet - we should see ‘No user’ on the screen.</li>
<li>After clicking the button that says ‘Fetch user’, we expect it to start fetching the user. We should see ‘Fetching user…’ displayed on the screen.</li>
<li>After some time, the user should be received. We should no longer see ‘Fetching user…’, but instead should see the expected user’s name based on the response from our API.</li>
</ul>
<p>Writing our tests to focus on the above as a whole, we can avoid mocking as much of the app as possible. We will also have confidence that the critical behavior of our app does what we expect it to when interacted with in the way we expect the user to use the app.</p>
<p>To test the component, we <code>render</code> it into the DOM, and assert that the app responds to interactions in the way we expect the user to use the app. We can use the <code>wrapper</code> option in the <code>render</code> function and export our own <code>render</code> function as explained in React Testing Library’s <a href="https://testing-library.com/docs/react-testing-library/setup">setup docs</a>.</p>
<p>Our <code>render</code> function can look like this:</p>
<pre class="jsx"><code>// test-utils.jsx
import React from &quot;react&quot;;
import { render as rtlRender } from &quot;@testing-library/react&quot;;
import { configureStore } from &quot;@reduxjs/toolkit&quot;;
import { Provider } from &quot;react-redux&quot;;
// Import your own reducer
import userReducer from &quot;../userSlice&quot;;

function render(
  ui,
  {
    preloadedState,
    store = configureStore({ reducer: { user: userReducer }, preloadedState }),
    ...renderOptions
  } = {}
) {
  function Wrapper({ children }) {
    return &lt;Provider store={store}&gt;{children}&lt;/Provider&gt;;
  }
  return rtlRender(ui, { wrapper: Wrapper, ...renderOptions });
}

// re-export everything
export * from &quot;@testing-library/react&quot;;
// override render method
export { render };</code></pre>
<p>And our test can use our exported <code>render</code> function to test the criteria of our integration test:</p>
<pre class="jsx"><code>import React from &quot;react&quot;;
import { rest } from &quot;msw&quot;;
import { setupServer } from &quot;msw/node&quot;;
// We&#39;re using our own custom render function and not RTL&#39;s render.
// Our custom utils also re-export everything from RTL
// so we can import fireEvent and screen here as well
import { render, fireEvent, screen } from &quot;../../test-utils&quot;;
import App from &quot;../../containers/App&quot;;

// We use msw to intercept the network request during the test,
// and return the response &#39;John Smith&#39; after 150ms
// when receiving a get request to the `/api/user` endpoint
export const handlers = [
  rest.get(&quot;/api/user&quot;, (req, res, ctx) =&gt; {
    return res(ctx.json(&quot;John Smith&quot;), ctx.delay(150));
  }),
];

const server = setupServer(...handlers);

// Enable API mocking before tests.
beforeAll(() =&gt; server.listen());

// Reset any runtime request handlers we may add during the tests.
afterEach(() =&gt; server.resetHandlers());

// Disable API mocking after the tests are done.
afterAll(() =&gt; server.close());

test(&quot;fetches &amp; receives a user after clicking the fetch user button&quot;, async () =&gt; {
  render(&lt;App /&gt;);

  // should show no user initially, and not be fetching a user
  expect(screen.getByText(/no user/i)).toBeInTheDocument();
  expect(screen.queryByText(/Fetching user\.\.\./i)).not.toBeInTheDocument();

  // after clicking the &#39;Fetch user&#39; button, it should now show that it is fetching the user
  fireEvent.click(screen.getByRole(&quot;button&quot;, { name: /Fetch user/i }));
  expect(screen.getByText(/no user/i)).toBeInTheDocument();

  // after some time, the user should be received
  expect(await screen.findByText(/John Smith/i)).toBeInTheDocument();
  expect(screen.queryByText(/no user/i)).not.toBeInTheDocument();
  expect(screen.queryByText(/Fetching user\.\.\./i)).not.toBeInTheDocument();
});</code></pre>
<p>In this test, we have completely avoided testing any Redux code directly, treating it as an implementation detail. As a result, we are free to re-factor the <em>implementation</em>, while our tests will continue to pass and avoid false negatives (tests that fail despite the app still behaving how we want it to). We might change our state structure, convert our slice to use <a href="https://redux-toolkit.js.org/rtk-query/overview">RTK-Query</a>, or remove Redux entirely, and our tests will still pass. We have a strong degree of confidence that if we change some code and our tests report a failure, then our app really <em>is</em> broken.</p>
<h2 id="middleware-2">Middleware</h2>
<p>Middleware functions wrap behavior of <code>dispatch</code> calls in Redux, so to test this modified behavior we need to mock the behavior of the <code>dispatch</code> call.</p>
<h4 id="example-2">Example</h4>
<p>First, we’ll need a middleware function. This is similar to the real <a href="https://github.com/gaearon/redux-thunk/blob/master/src/index.js">redux-thunk</a>.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb174-1" title="1"><span class="kw">const</span> thunk <span class="op">=</span></a>
<a class="sourceLine" id="cb174-2" title="2">  (<span class="op">{</span> dispatch<span class="op">,</span> getState <span class="op">}</span>) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb174-3" title="3">  (next) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb174-4" title="4">  (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb174-5" title="5">    <span class="cf">if</span> (<span class="kw">typeof</span> action <span class="op">===</span> <span class="st">&quot;function&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb174-6" title="6">      <span class="cf">return</span> <span class="at">action</span>(dispatch<span class="op">,</span> getState)<span class="op">;</span></a>
<a class="sourceLine" id="cb174-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb174-8" title="8"></a>
<a class="sourceLine" id="cb174-9" title="9">    <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb174-10" title="10">  <span class="op">};</span></a></code></pre></div>
<p>We need to create a fake <code>getState</code>, <code>dispatch</code>, and <code>next</code> functions. We use <code>jest.fn()</code> to create stubs, but with other test frameworks you would likely use <a href="https://sinonjs.org/">Sinon</a>.</p>
<p>The invoke function runs our middleware in the same way Redux does.</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb175-1" title="1"><span class="kw">const</span> create <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb175-2" title="2">  <span class="kw">const</span> store <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb175-3" title="3">    <span class="dt">getState</span><span class="op">:</span> <span class="va">jest</span>.<span class="at">fn</span>(() <span class="kw">=&gt;</span> (<span class="op">{}</span>))<span class="op">,</span></a>
<a class="sourceLine" id="cb175-4" title="4">    <span class="dt">dispatch</span><span class="op">:</span> <span class="va">jest</span>.<span class="at">fn</span>()<span class="op">,</span></a>
<a class="sourceLine" id="cb175-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb175-6" title="6">  <span class="kw">const</span> next <span class="op">=</span> <span class="va">jest</span>.<span class="at">fn</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb175-7" title="7"></a>
<a class="sourceLine" id="cb175-8" title="8">  <span class="kw">const</span> invoke <span class="op">=</span> (action) <span class="kw">=&gt;</span> <span class="at">thunk</span>(store)(next)(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb175-9" title="9"></a>
<a class="sourceLine" id="cb175-10" title="10">  <span class="cf">return</span> <span class="op">{</span> store<span class="op">,</span> next<span class="op">,</span> invoke <span class="op">};</span></a>
<a class="sourceLine" id="cb175-11" title="11"><span class="op">};</span></a></code></pre></div>
<p>We test that our middleware is calling the <code>getState</code>, <code>dispatch</code>, and <code>next</code> functions at the right time.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb176-1" title="1"><span class="at">test</span>(<span class="st">&quot;passes through non-function action&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb176-2" title="2">  <span class="kw">const</span> <span class="op">{</span> next<span class="op">,</span> invoke <span class="op">}</span> <span class="op">=</span> <span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-3" title="3">  <span class="kw">const</span> action <span class="op">=</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;TEST&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb176-4" title="4">  <span class="at">invoke</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-5" title="5">  <span class="at">expect</span>(next).<span class="at">toHaveBeenCalledWith</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-7" title="7"></a>
<a class="sourceLine" id="cb176-8" title="8"><span class="at">test</span>(<span class="st">&quot;calls the function&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb176-9" title="9">  <span class="kw">const</span> <span class="op">{</span> invoke <span class="op">}</span> <span class="op">=</span> <span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-10" title="10">  <span class="kw">const</span> fn <span class="op">=</span> <span class="va">jest</span>.<span class="at">fn</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-11" title="11">  <span class="at">invoke</span>(fn)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-12" title="12">  <span class="at">expect</span>(fn).<span class="at">toHaveBeenCalled</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-13" title="13"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-14" title="14"></a>
<a class="sourceLine" id="cb176-15" title="15"><span class="at">test</span>(<span class="st">&quot;passes dispatch and getState&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb176-16" title="16">  <span class="kw">const</span> <span class="op">{</span> store<span class="op">,</span> invoke <span class="op">}</span> <span class="op">=</span> <span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-17" title="17">  <span class="at">invoke</span>((dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb176-18" title="18">    <span class="at">dispatch</span>(<span class="st">&quot;TEST DISPATCH&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-19" title="19">    <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-20" title="20">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-21" title="21">  <span class="at">expect</span>(<span class="va">store</span>.<span class="at">dispatch</span>).<span class="at">toHaveBeenCalledWith</span>(<span class="st">&quot;TEST DISPATCH&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb176-22" title="22">  <span class="at">expect</span>(<span class="va">store</span>.<span class="at">getState</span>).<span class="at">toHaveBeenCalled</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb176-23" title="23"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>In some cases, you will need to modify the <code>create</code> function to use different mock implementations of <code>getState</code> and <code>next</code>.</p>
<h2 id="further-information">Further Information</h2>
<ul>
<li><p><a href="https://testing-library.com/docs/react-testing-library/intro">React Testing Library</a>: React Testing Library is a very light-weight solution for testing React components. It provides light utility functions on top of react-dom and react-dom/test-utils, in a way that encourages better testing practices. Its primary guiding principle is: “The more your tests resemble the way your software is used, the more confidence they can give you.”</p></li>
<li><p><a href="https://reactjs.org/docs/test-utils.html">React Test Utils</a>: ReactTestUtils makes it easy to test React components in the testing framework of your choice. React Testing Library uses the <code>act</code> function exported by React Test Utils.</p></li>
<li><p><a href="https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/">Blogged Answers: The Evolution of Redux Testing Approaches</a>: Mark Erikson’s thoughts on how Redux testing has evolved from ‘isolation’ to ‘integration’.</p></li>
<li><p><a href="https://kentcdodds.com/blog/testing-implementation-details">Testing Implementation Details</a>: Blog post by Kent C. Dodds on why he recommends to avoid testing implementation details.</p></li>
</ul>
<hr />
<p>id: deriving-data-selectors title: Deriving Data with Selectors description: ‘Usage &gt; Redux Logic &gt; Selectors: deriving data from the Redux state’</p>
<hr />
<p>:::tip What You’ll Learn</p>
<ul>
<li>Why good Redux architecture keeps state minimal and derives additional data</li>
<li>Principles of using selector functions to derive data and encapsulate lookups</li>
<li>How to use the Reselect library to write memoized selectors for optimization</li>
<li>Advanced techniques for using Reselect</li>
<li>Additional tools and libraries for creating selectors</li>
<li>Best practices for writing selectors</li>
</ul>
<p>:::</p>
<h2 id="deriving-data">Deriving Data</h2>
<p>We specifically recommend that Redux apps should <a href="../style-guide/style-guide.md#keep-state-minimal-and-derive-additional-values">keep the Redux state minimal, and derive additional values from that state whenever possible</a>.</p>
<p>This includes things like calculating filtered lists or summing up values. As an example, a todo app would keep an original list of todo objects in state, but derive a filtered list of todos outside the state whenever the state is updated. Similarly, a check for whether all todos have been completed, or number of todos remaining, can be calculated outside the store as well.</p>
<p>This has several benefits:</p>
<ul>
<li>The actual state is easier to read</li>
<li>Less logic is needed to calculate those additional values and keep them in sync with the rest of the data</li>
<li>The original state is still there as a reference and isn’t being replaced</li>
</ul>
<div class="tip">
<p>This is <em>also</em> a good principle for React state as well! Many times users tried to define a <code>useEffect</code> hook that waits for a state value to change, and then sets state with some derived value like <code>setAllCompleted(allCompleted)</code>. Instead, that value can be derived during the rendering process and used directly, without having to save the value into state at all:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb177-1" title="1"><span class="kw">function</span> <span class="at">TodoList</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb177-2" title="2">  <span class="kw">const</span> [todos<span class="op">,</span> setTodos] <span class="op">=</span> <span class="at">useState</span>([])<span class="op">;</span></a>
<a class="sourceLine" id="cb177-3" title="3"></a>
<a class="sourceLine" id="cb177-4" title="4">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb177-5" title="5">  <span class="co">// Derive the data while rendering</span></a>
<a class="sourceLine" id="cb177-6" title="6">  <span class="kw">const</span> allTodosCompleted <span class="op">=</span> <span class="va">todos</span>.<span class="at">every</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb177-7" title="7">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb177-8" title="8"></a>
<a class="sourceLine" id="cb177-9" title="9">  <span class="co">// render with this value</span></a>
<a class="sourceLine" id="cb177-10" title="10"><span class="op">}</span></a></code></pre></div>
</div>
<h2 id="calculating-derived-data-with-selectors">Calculating Derived Data with Selectors</h2>
<p>In a typical Redux application, the logic for deriving data is usually written as functions we call <strong><em>selectors</em></strong>.</p>
<p>Selectors are primarily used to encapsulate logic for looking up specific values from state, logic for actually deriving values, and improving performance by avoiding unnecessary recalculations.</p>
<p>You are not <em>required</em> to use selectors for all state lookups, but they are a standard pattern and widely used.</p>
<h3 id="basic-selector-concepts">Basic Selector Concepts</h3>
<p><strong>A “selector function” is any function that accepts the Redux store state (or part of the state) as an argument, and returns data that is based on that state.</strong></p>
<p><strong>Selectors don’t have to be written using a special library</strong>, and it doesn’t matter whether you write them as arrow functions or the <code>function</code> keyword. For example, all of these are valid selector functions:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb178-1" title="1"><span class="co">// Arrow function, direct lookup</span></a>
<a class="sourceLine" id="cb178-2" title="2"><span class="kw">const</span> selectEntities <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">entities</span><span class="op">;</span></a>
<a class="sourceLine" id="cb178-3" title="3"></a>
<a class="sourceLine" id="cb178-4" title="4"><span class="co">// Function declaration, mapping over an array to derive values</span></a>
<a class="sourceLine" id="cb178-5" title="5"><span class="kw">function</span> <span class="at">selectItemIds</span>(state) <span class="op">{</span></a>
<a class="sourceLine" id="cb178-6" title="6">  <span class="cf">return</span> <span class="va">state</span>.<span class="va">items</span>.<span class="at">map</span>((item) <span class="kw">=&gt;</span> <span class="va">item</span>.<span class="at">id</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb178-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb178-8" title="8"></a>
<a class="sourceLine" id="cb178-9" title="9"><span class="co">// Function declaration, encapsulating a deep lookup</span></a>
<a class="sourceLine" id="cb178-10" title="10"><span class="kw">function</span> <span class="at">selectSomeSpecificField</span>(state) <span class="op">{</span></a>
<a class="sourceLine" id="cb178-11" title="11">  <span class="cf">return</span> <span class="va">state</span>.<span class="va">some</span>.<span class="va">deeply</span>.<span class="va">nested</span>.<span class="at">field</span><span class="op">;</span></a>
<a class="sourceLine" id="cb178-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb178-13" title="13"></a>
<a class="sourceLine" id="cb178-14" title="14"><span class="co">// Arrow function, deriving values from an array</span></a>
<a class="sourceLine" id="cb178-15" title="15"><span class="kw">const</span> selectItemsWhoseNamesStartWith <span class="op">=</span> (items<span class="op">,</span> namePrefix) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb178-16" title="16">  <span class="va">items</span>.<span class="at">filter</span>((item) <span class="kw">=&gt;</span> <span class="va">item</span>.<span class="va">name</span>.<span class="at">startsWith</span>(namePrefix))<span class="op">;</span></a></code></pre></div>
<p>A selector function can have any name you want. However, <a href="../style-guide/style-guide.md#name-selector-functions-as-selectthing"><strong>we recommend prefixing selector function names with the word <code>select</code> combined with a description of the value being selected</strong></a>. Typical examples of this would look like <strong><code>selectTodoById</code></strong>, <strong><code>selectFilteredTodos</code></strong>, and <strong><code>selectVisibleTodos</code></strong>.</p>
<p>If you’ve used <a href="../tutorials/fundamentals/part-5-ui-and-react.md">the <code>useSelector</code> hook from React-Redux</a>, you’re probably already familiar with the basic idea of a selector function - the functions that we pass to <code>useSelector</code> must be selectors:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb179-1" title="1"><span class="kw">function</span> <span class="at">TodoList</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb179-2" title="2">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb179-3" title="3">  <span class="co">// This anonymous arrow function is a selector!</span></a>
<a class="sourceLine" id="cb179-4" title="4">  <span class="kw">const</span> todos <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb179-5" title="5">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb179-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>Selector functions are typically defined in two different parts of a Redux application:</p>
<ul>
<li>In slice files, alongside the reducer logic</li>
<li>In component files, either outside the component, or inline in <code>useSelector</code> calls</li>
</ul>
<p>A selector function can be used anywhere you have access to the entire Redux root state value. This includes the <code>useSelector</code> hook, the <code>mapState</code> function for <code>connect</code>, middleware, thunks, and sagas. For example, thunks and middleware have access to the <code>getState</code> argument, so you can call a selector there:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb180-1" title="1"><span class="kw">function</span> <span class="at">addTodosIfAllowed</span>(todoText) <span class="op">{</span></a>
<a class="sourceLine" id="cb180-2" title="2">  <span class="cf">return</span> (dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb180-3" title="3">    <span class="kw">const</span> state <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb180-4" title="4">    <span class="kw">const</span> canAddTodos <span class="op">=</span> <span class="at">selectCanAddTodos</span>(state)<span class="op">;</span></a>
<a class="sourceLine" id="cb180-5" title="5"></a>
<a class="sourceLine" id="cb180-6" title="6">    <span class="cf">if</span> (canAddTodos) <span class="op">{</span></a>
<a class="sourceLine" id="cb180-7" title="7">      <span class="at">dispatch</span>(<span class="at">todoAdded</span>(todoText))<span class="op">;</span></a>
<a class="sourceLine" id="cb180-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb180-9" title="9">  <span class="op">};</span></a>
<a class="sourceLine" id="cb180-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>It’s not typically possible to use selectors inside of reducers, because a slice reducer only has access to its own slice of the Redux state, and most selectors expect to be given the <em>entire</em> Redux root state as an argument.</p>
<h3 id="encapsulating-state-shape-with-selectors">Encapsulating State Shape with Selectors</h3>
<p>The first reason to use selector functions is for encapsulation and reusability when dealing with your Redux state shape.</p>
<p>Let’s say that one of your <code>useSelector</code> hooks makes a very specific lookup into part of your Redux state:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb181-1" title="1"><span class="kw">const</span> data <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">some</span>.<span class="va">deeply</span>.<span class="va">nested</span>.<span class="at">field</span>)<span class="op">;</span></a></code></pre></div>
<p>That is legal code, and will run fine. But, it might not be the best idea architecturally. Imagine that you’ve got several components that need to access that field. What happens if you need to make a change to where that piece of state lives? You would now have to go change <em>every</em> <code>useSelector</code> hook that references that value. So, in the same way that <a href="../style-guide/style-guide.md#use-action-creators">we recommend using action creators to encapsulate details of creating actions</a>, we recommend defining reusable selectors to encapsulate the knowledge of where a given piece of state lives. Then, you can use a given selector function many times in the codebase, anywhere that your app needs to retrieve that particular data.</p>
<p><strong>Ideally, only your reducer functions and selectors should know the exact state structure, so if you change where some state lives, you would only need to update those two pieces of logic</strong>.</p>
<p>Because of this, it’s often a good idea to define reusable selectors directly inside slice files, rather than always defining them inside of a component.</p>
<p>One common description of selectors is that they’re like <strong>“queries into your state”</strong>. You don’t care about exactly how the query came up with the data you needed, just that you asked for the data and got back a result.</p>
<h3 id="optimizing-selectors-with-memoization">Optimizing Selectors with Memoization</h3>
<p>Selector functions often need to perform relatively “expensive” calculations, or create derived values that are new object and array references. This can be a concern for application performance, for several reasons:</p>
<ul>
<li>Selectors used with <code>useSelector</code> or <code>mapState</code> will be re-run after every dispatched action, regardless of what section of the Redux root state was actually updated. Re-running expensive calculations when the input state sections didn’t change is a waste of CPU time, and it’s very likely that the inputs won’t have changed most of the time anyway.</li>
<li><code>useSelector</code> and <code>mapState</code> rely on <code>===</code> reference equality checks of the return values to determine if the component needs to re-render. If a selector <em>always</em> returns new references, it will force the component to re-render even if the derived data is effectively the same as last time. This is especially common with array operations like <code>map()</code> and <code>filter()</code>, which return new array references.</li>
</ul>
<p>As an example, this component is written badly, because its <code>useSelector</code> call <em>always</em> returns a new array reference. That means the component will re-render after <em>every</em> dispatched action, even if the input <code>state.todos</code> slice hasn’t changed:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb182-1" title="1"><span class="kw">function</span> <span class="at">TodoList</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb182-2" title="2">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb182-3" title="3">  <span class="co">// ❌ </span><span class="al">WARNING</span><span class="co">: this _always_ returns a new reference, so it will _always_ re-render!</span></a>
<a class="sourceLine" id="cb182-4" title="4">  <span class="kw">const</span> completedTodos <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb182-5" title="5">    <span class="va">state</span>.<span class="va">todos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)</a>
<a class="sourceLine" id="cb182-6" title="6">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb182-7" title="7">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb182-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>Another example is a component that needs to do some “expensive” work to transform data:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb183-1" title="1"><span class="kw">function</span> <span class="at">ExampleComplexComponent</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb183-2" title="2">  <span class="kw">const</span> data <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb183-3" title="3">    <span class="kw">const</span> initialData <span class="op">=</span> <span class="va">state</span>.<span class="at">data</span><span class="op">;</span></a>
<a class="sourceLine" id="cb183-4" title="4">    <span class="kw">const</span> filteredData <span class="op">=</span> <span class="at">expensiveFiltering</span>(initialData)<span class="op">;</span></a>
<a class="sourceLine" id="cb183-5" title="5">    <span class="kw">const</span> sortedData <span class="op">=</span> <span class="at">expensiveSorting</span>(filteredData)<span class="op">;</span></a>
<a class="sourceLine" id="cb183-6" title="6">    <span class="kw">const</span> transformedData <span class="op">=</span> <span class="at">expensiveTransformation</span>(sortedData)<span class="op">;</span></a>
<a class="sourceLine" id="cb183-7" title="7"></a>
<a class="sourceLine" id="cb183-8" title="8">    <span class="cf">return</span> transformedData<span class="op">;</span></a>
<a class="sourceLine" id="cb183-9" title="9">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb183-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>Similarly, this “expensive” logic will re-run after <em>every</em> dispatched action. Not only will it probably create new references, but it’s work that doesn’t need to be done unless <code>state.data</code> actually changes.</p>
<p>Because of this, we need a way to write optimized selectors that can avoid recalculating results if the same inputs are passed in. This is where the idea of <strong><em>memoization</em></strong> comes in.</p>
<p><strong>Memoization is a form of caching</strong>. It involves tracking inputs to a function, and storing the inputs and the results for later reference. If a function is called with the same inputs as before, the function can skip doing the actual work, and return the same result it generated the last time it received those input values. This optimizes performance by only doing work if inputs have changed, and consistently returning the same result references if the inputs are the same.</p>
<p>Next, we’ll look at some options for writing memoized selectors.</p>
<h2 id="writing-memoized-selectors-with-reselect">Writing Memoized Selectors with Reselect</h2>
<p>The Redux ecosystem has traditionally used a library called <a href="https://github.com/reduxjs/reselect"><strong>Reselect</strong></a> to create memoized selector functions. There also are other similar libraries, as well as multiple variations and wrappers around Reselect - we’ll look at those later.</p>
<h3 id="createselector-overview"><code>createSelector</code> Overview</h3>
<p>Reselect provides a function called <a href="https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc"><code>createSelector</code></a> to generate memoized selectors. <code>createSelector</code> accepts one or more “input selector” functions, plus an “output selector” function, and returns a new selector function for you to use.</p>
<p><code>createSelector</code> is included as part of <a href="https://redux-toolkit.js.org">our official Redux Toolkit package</a>, and is re-exported for ease of use.</p>
<p><code>createSelector</code> can accept multiple input selectors, which can be provided as separate arguments or as an array. The results from all the input selectors are provided as separate arguments to the output selector:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb184-1" title="1"><span class="kw">const</span> selectA <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">a</span><span class="op">;</span></a>
<a class="sourceLine" id="cb184-2" title="2"><span class="kw">const</span> selectB <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">b</span><span class="op">;</span></a>
<a class="sourceLine" id="cb184-3" title="3"><span class="kw">const</span> selectC <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">c</span><span class="op">;</span></a>
<a class="sourceLine" id="cb184-4" title="4"></a>
<a class="sourceLine" id="cb184-5" title="5"><span class="kw">const</span> selectABC <span class="op">=</span> <span class="at">createSelector</span>([selectA<span class="op">,</span> selectB<span class="op">,</span> selectC]<span class="op">,</span> (a<span class="op">,</span> b<span class="op">,</span> c) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb184-6" title="6">  <span class="co">// do something with a, b, and c, and return a result</span></a>
<a class="sourceLine" id="cb184-7" title="7">  <span class="cf">return</span> a <span class="op">+</span> b <span class="op">+</span> c<span class="op">;</span></a>
<a class="sourceLine" id="cb184-8" title="8"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb184-9" title="9"></a>
<a class="sourceLine" id="cb184-10" title="10"><span class="co">// Call the selector function and get a result</span></a>
<a class="sourceLine" id="cb184-11" title="11"><span class="kw">const</span> abc <span class="op">=</span> <span class="at">selectABC</span>(state)<span class="op">;</span></a>
<a class="sourceLine" id="cb184-12" title="12"></a>
<a class="sourceLine" id="cb184-13" title="13"><span class="co">// could also be written as separate arguments, and works exactly the same</span></a>
<a class="sourceLine" id="cb184-14" title="14"><span class="kw">const</span> selectABC2 <span class="op">=</span> <span class="at">createSelector</span>(selectA<span class="op">,</span> selectB<span class="op">,</span> selectC<span class="op">,</span> (a<span class="op">,</span> b<span class="op">,</span> c) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb184-15" title="15">  <span class="co">// do something with a, b, and c, and return a result</span></a>
<a class="sourceLine" id="cb184-16" title="16">  <span class="cf">return</span> a <span class="op">+</span> b <span class="op">+</span> c<span class="op">;</span></a>
<a class="sourceLine" id="cb184-17" title="17"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>When you call the selector, Reselect will run your input selectors with all of the arguments you gave, and looks at the returned values. If any of the results are <code>===</code> different than before, it will re-run the output selector, and pass in those results as the arguments. If all of the results are the same as the last time, it will skip re-running the output selector, and just return the cached final result from before.</p>
<p>This means that <strong>“input selectors” should usually just extract and return values, and the “output selector” should do the transformation work</strong>.</p>
<div class="caution">
<p>A somewhat common mistake is to write an “input selector” that extracts a value or does some derivation, and an “output selector” that just returns its result:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb185-1" title="1"><span class="co">// ❌ BROKEN: this will not memoize correctly, and does nothing useful!</span></a>
<a class="sourceLine" id="cb185-2" title="2"><span class="kw">const</span> brokenSelector <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb185-3" title="3">  (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span><span class="op">,</span></a>
<a class="sourceLine" id="cb185-4" title="4">  (todos) <span class="kw">=&gt;</span> todos</a>
<a class="sourceLine" id="cb185-5" title="5">)<span class="op">;</span></a></code></pre></div>
<p><strong>Any “output selector” that just returns its inputs is incorrect!</strong> The output selector should always have the transformation logic.</p>
<p>Similarly, a memoized selector should <em>never</em> use <code>state =&gt; state</code> as an input! That will force the selector to always recalculate.</p>
</div>
<p>In typical Reselect usage, you write your top-level “input selectors” as plain functions, and use <code>createSelector</code> to create memoized selectors that look up nested values:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb186-1" title="1"><span class="kw">const</span> state <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb186-2" title="2">  <span class="dt">a</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb186-3" title="3">    <span class="dt">first</span><span class="op">:</span> <span class="dv">5</span><span class="op">,</span></a>
<a class="sourceLine" id="cb186-4" title="4">  <span class="op">},</span></a>
<a class="sourceLine" id="cb186-5" title="5">  <span class="dt">b</span><span class="op">:</span> <span class="dv">10</span><span class="op">,</span></a>
<a class="sourceLine" id="cb186-6" title="6"><span class="op">};</span></a>
<a class="sourceLine" id="cb186-7" title="7"></a>
<a class="sourceLine" id="cb186-8" title="8"><span class="kw">const</span> selectA <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">a</span><span class="op">;</span></a>
<a class="sourceLine" id="cb186-9" title="9"><span class="kw">const</span> selectB <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">b</span><span class="op">;</span></a>
<a class="sourceLine" id="cb186-10" title="10"></a>
<a class="sourceLine" id="cb186-11" title="11"><span class="kw">const</span> selectA1 <span class="op">=</span> <span class="at">createSelector</span>([selectA]<span class="op">,</span> (a) <span class="kw">=&gt;</span> <span class="va">a</span>.<span class="at">first</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-12" title="12"></a>
<a class="sourceLine" id="cb186-13" title="13"><span class="kw">const</span> selectResult <span class="op">=</span> <span class="at">createSelector</span>([selectA1<span class="op">,</span> selectB]<span class="op">,</span> (a1<span class="op">,</span> b) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb186-14" title="14">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Output selector running&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-15" title="15">  <span class="cf">return</span> a1 <span class="op">+</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb186-16" title="16"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-17" title="17"></a>
<a class="sourceLine" id="cb186-18" title="18"><span class="kw">const</span> result <span class="op">=</span> <span class="at">selectResult</span>(state)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-19" title="19"><span class="co">// Log: &quot;Output selector running&quot;</span></a>
<a class="sourceLine" id="cb186-20" title="20"><span class="va">console</span>.<span class="at">log</span>(result)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-21" title="21"><span class="co">// 15</span></a>
<a class="sourceLine" id="cb186-22" title="22"></a>
<a class="sourceLine" id="cb186-23" title="23"><span class="kw">const</span> secondResult <span class="op">=</span> <span class="at">selectResult</span>(state)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-24" title="24"><span class="co">// No log output</span></a>
<a class="sourceLine" id="cb186-25" title="25"><span class="va">console</span>.<span class="at">log</span>(secondResult)<span class="op">;</span></a>
<a class="sourceLine" id="cb186-26" title="26"><span class="co">// 15</span></a></code></pre></div>
<p>Note that the second time we called <code>selectResult</code>, the “output selector” didn’t execute. Because the results of <code>selectA1</code> and <code>selectB</code> were the same as the first call, <code>selectResult</code> was able to return the memoized result from the first call.</p>
<h3 id="createselector-behavior"><code>createSelector</code> Behavior</h3>
<p>It’s important to note that by default, <strong><code>createSelector</code> only memoizes the most recent set of parameters</strong>. That means that if you call a selector repeatedly with different inputs, it will still return a result, but it will have to keep re-running the output selector to produce the result:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb187-1" title="1"><span class="kw">const</span> a <span class="op">=</span> <span class="at">someSelector</span>(state<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// first call, not memoized</span></a>
<a class="sourceLine" id="cb187-2" title="2"><span class="kw">const</span> b <span class="op">=</span> <span class="at">someSelector</span>(state<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// same inputs, memoized</span></a>
<a class="sourceLine" id="cb187-3" title="3"><span class="kw">const</span> c <span class="op">=</span> <span class="at">someSelector</span>(state<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span> <span class="co">// different inputs, not memoized</span></a>
<a class="sourceLine" id="cb187-4" title="4"><span class="kw">const</span> d <span class="op">=</span> <span class="at">someSelector</span>(state<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// different inputs from last time, not memoized</span></a></code></pre></div>
<p>Also, you can pass multiple arguments into a selector. Reselect will call all of the input selectors with those exact inputs:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb188-1" title="1"><span class="kw">const</span> selectItems <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">items</span><span class="op">;</span></a>
<a class="sourceLine" id="cb188-2" title="2"><span class="kw">const</span> selectItemId <span class="op">=</span> (state<span class="op">,</span> itemId) <span class="kw">=&gt;</span> itemId<span class="op">;</span></a>
<a class="sourceLine" id="cb188-3" title="3"></a>
<a class="sourceLine" id="cb188-4" title="4"><span class="kw">const</span> selectItemById <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb188-5" title="5">  [selectItems<span class="op">,</span> selectItemId]<span class="op">,</span></a>
<a class="sourceLine" id="cb188-6" title="6">  (items<span class="op">,</span> itemId) <span class="kw">=&gt;</span> items[itemId]</a>
<a class="sourceLine" id="cb188-7" title="7">)<span class="op">;</span></a>
<a class="sourceLine" id="cb188-8" title="8"></a>
<a class="sourceLine" id="cb188-9" title="9"><span class="kw">const</span> item <span class="op">=</span> <span class="at">selectItemById</span>(state<span class="op">,</span> <span class="dv">42</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb188-10" title="10"></a>
<a class="sourceLine" id="cb188-11" title="11"><span class="co">/*</span></a>
<a class="sourceLine" id="cb188-12" title="12"><span class="co">Internally, Reselect does something like this:</span></a>
<a class="sourceLine" id="cb188-13" title="13"></a>
<a class="sourceLine" id="cb188-14" title="14"><span class="co">const firstArg = selectItems(state, 42);  </span></a>
<a class="sourceLine" id="cb188-15" title="15"><span class="co">const secondArg = selectItemId(state, 42);  </span></a>
<a class="sourceLine" id="cb188-16" title="16"><span class="co">  </span></a>
<a class="sourceLine" id="cb188-17" title="17"><span class="co">const result = outputSelector(firstArg, secondArg);  </span></a>
<a class="sourceLine" id="cb188-18" title="18"><span class="co">return result;  </span></a>
<a class="sourceLine" id="cb188-19" title="19"><span class="co">*/</span></a></code></pre></div>
<p>Because of this, <strong>it’s important that all of the “input selectors” you provide should accept the same types of parameters</strong>. Otherwise, the selectors will break.</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb189-1" title="1"><span class="kw">const</span> selectItems <span class="op">=</span> state <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">items</span><span class="op">;</span></a>
<a class="sourceLine" id="cb189-2" title="2"></a>
<a class="sourceLine" id="cb189-3" title="3"><span class="co">// expects a number as the second argument</span></a>
<a class="sourceLine" id="cb189-4" title="4"><span class="kw">const</span> selectItemId <span class="op">=</span> (state<span class="op">,</span> itemId) <span class="kw">=&gt;</span> itemId<span class="op">;</span></a>
<a class="sourceLine" id="cb189-5" title="5"></a>
<a class="sourceLine" id="cb189-6" title="6"><span class="co">// expects an object as the second argument</span></a>
<a class="sourceLine" id="cb189-7" title="7"><span class="kw">const</span> <span class="at">selectOtherField</span> (state<span class="op">,</span> someObject) <span class="kw">=&gt;</span> <span class="va">someObject</span>.<span class="at">someField</span><span class="op">;</span></a>
<a class="sourceLine" id="cb189-8" title="8"></a>
<a class="sourceLine" id="cb189-9" title="9"><span class="kw">const</span> selectItemById <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb189-10" title="10">    [selectItems<span class="op">,</span> selectItemId<span class="op">,</span> selectOtherField]<span class="op">,</span></a>
<a class="sourceLine" id="cb189-11" title="11">    (items<span class="op">,</span> itemId<span class="op">,</span> someField) <span class="kw">=&gt;</span> items[itemId]</a>
<a class="sourceLine" id="cb189-12" title="12">)<span class="op">;</span></a></code></pre></div>
<p>In this example, <code>selectItemId</code> expects that its second argument will be some simple value, while <code>selectOtherField</code> expects that the second argument is an object. If you call <code>selectItemById(state, 42)</code>, <code>selectOtherField</code> will break because it’s trying to access <code>42.someField</code>.</p>
<h3 id="reselect-usage-patterns-and-limitations">Reselect Usage Patterns and Limitations</h3>
<h4 id="nesting-selectors">Nesting Selectors</h4>
<p>It’s possible to take selectors generated with <code>createSelector</code>, and use them as inputs for other selectors as well. In this example, the <code>selectCompletedTodos</code> selector is used as an input to <code>selectCompletedTodoDescriptions</code>:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb190-1" title="1"><span class="kw">const</span> selectTodos <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span><span class="op">;</span></a>
<a class="sourceLine" id="cb190-2" title="2"></a>
<a class="sourceLine" id="cb190-3" title="3"><span class="kw">const</span> selectCompletedTodos <span class="op">=</span> <span class="at">createSelector</span>([selectTodos]<span class="op">,</span> (todos) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb190-4" title="4">  <span class="va">todos</span>.<span class="at">filter</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)</a>
<a class="sourceLine" id="cb190-5" title="5">)<span class="op">;</span></a>
<a class="sourceLine" id="cb190-6" title="6"></a>
<a class="sourceLine" id="cb190-7" title="7"><span class="kw">const</span> selectCompletedTodoDescriptions <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb190-8" title="8">  [selectCompletedTodos]<span class="op">,</span></a>
<a class="sourceLine" id="cb190-9" title="9">  (completedTodos) <span class="kw">=&gt;</span> <span class="va">completedTodos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">text</span>)</a>
<a class="sourceLine" id="cb190-10" title="10">)<span class="op">;</span></a></code></pre></div>
<h4 id="passing-input-parameters">Passing Input Parameters</h4>
<p>A Reselect-generated selector function can be called with as many arguments as you want: <code>selectThings(a, b, c, d, e)</code>. However, what matters for re-running the output is not the number of arguments, or whether the arguments themselves have changed to be new references. Instead, it’s about the “input selectors” that were defined, and whether <em>their</em> results have changed. Similarly, the arguments for the “output selector” are solely based on what the input selectors return.</p>
<p>This means that if you want to pass additional parameters through to the output selector, you must define input selectors that extract those values from the original selector arguments:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb191-1" title="1"><span class="kw">const</span> selectItemsByCategory <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb191-2" title="2">  [</a>
<a class="sourceLine" id="cb191-3" title="3">    <span class="co">// Usual first input - extract value from `state`</span></a>
<a class="sourceLine" id="cb191-4" title="4">    (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">items</span><span class="op">,</span></a>
<a class="sourceLine" id="cb191-5" title="5">    <span class="co">// Take the second arg, `category`, and forward to the output selector</span></a>
<a class="sourceLine" id="cb191-6" title="6">    (state<span class="op">,</span> category) <span class="kw">=&gt;</span> category<span class="op">,</span></a>
<a class="sourceLine" id="cb191-7" title="7">  ]<span class="op">,</span></a>
<a class="sourceLine" id="cb191-8" title="8">  <span class="co">// Output selector gets (`items, category)` as args</span></a>
<a class="sourceLine" id="cb191-9" title="9">  (items<span class="op">,</span> category) <span class="kw">=&gt;</span> <span class="va">items</span>.<span class="at">filter</span>((item) <span class="kw">=&gt;</span> <span class="va">item</span>.<span class="at">category</span> <span class="op">===</span> category)</a>
<a class="sourceLine" id="cb191-10" title="10">)<span class="op">;</span></a></code></pre></div>
<p>For consistency, you may want to consider passing additional parameters to a selector as a single object, such as <code>selectThings(state, otherArgs)</code>, and then extracting values from the <code>otherArgs</code> object.</p>
<h4 id="selector-factories">Selector Factories</h4>
<p><strong><code>createSelector</code> only has a default cache size of 1, and this is per each unique instance of a selector</strong>. This creates problems when a single selector function needs to get reused in multiple places with differing inputs.</p>
<p>One option is to create a “selector factory” - a function that runs <code>createSelector()</code> and generates a new unique selector instance every time it’s called:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb192-1" title="1"><span class="kw">const</span> makeSelectItemsByCategory <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb192-2" title="2">  <span class="kw">const</span> selectItemsByCategory <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb192-3" title="3">    [(state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">items</span><span class="op">,</span> (state<span class="op">,</span> category) <span class="kw">=&gt;</span> category]<span class="op">,</span></a>
<a class="sourceLine" id="cb192-4" title="4">    (items<span class="op">,</span> category) <span class="kw">=&gt;</span> <span class="va">items</span>.<span class="at">filter</span>((item) <span class="kw">=&gt;</span> <span class="va">item</span>.<span class="at">category</span> <span class="op">===</span> category)</a>
<a class="sourceLine" id="cb192-5" title="5">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb192-6" title="6">  <span class="cf">return</span> selectItemsByCategory<span class="op">;</span></a>
<a class="sourceLine" id="cb192-7" title="7"><span class="op">};</span></a></code></pre></div>
<p>This is particularly useful when multiple similar UI components need to derive different subsets of the data based on props.</p>
<h2 id="alternative-selector-libraries">Alternative Selector Libraries</h2>
<p>While Reselect is the most widely used selector library with Redux, there are many other libraries that solve similar problems, or expand on Reselect’s capabilities.</p>
<h3 id="proxy-memoize"><code>proxy-memoize</code></h3>
<p><code>proxy-memoize</code> is a relatively new memoized selector library that uses a unique implementation approach. It relies on ES6 <code>Proxy</code> objects to track attempted reads of nested values, then compares only the nested values on later calls to see if they’ve changed. This can provide better results than Reselect in some cases.</p>
<p>A good example of this is a selector that derives an array of todo descriptions:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb193-1" title="1"><span class="im">import</span> <span class="op">{</span> createSelector <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;reselect&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb193-2" title="2"></a>
<a class="sourceLine" id="cb193-3" title="3"><span class="kw">const</span> selectTodoDescriptionsReselect <span class="op">=</span> <span class="at">createSelector</span>(</a>
<a class="sourceLine" id="cb193-4" title="4">  [(state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb193-5" title="5">  (todos) <span class="kw">=&gt;</span> <span class="va">todos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">text</span>)</a>
<a class="sourceLine" id="cb193-6" title="6">)<span class="op">;</span></a></code></pre></div>
<p>Unfortunately, this will recalculate the derived array if any other value inside of <code>state.todos</code> changes, such as toggling a <code>todo.completed</code> flag. The <em>contents</em> of the derived array are identical, but because the input <code>todos</code> array changed, it has to calculate a new output array, and that has a new reference.</p>
<p>The same selector with <code>proxy-memoize</code> might look like:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb194-1" title="1"><span class="im">import</span> memoize <span class="im">from</span> <span class="st">&quot;proxy-memoize&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb194-2" title="2"></a>
<a class="sourceLine" id="cb194-3" title="3"><span class="kw">const</span> selectTodoDescriptionsProxy <span class="op">=</span> <span class="at">memoize</span>((state) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb194-4" title="4">  <span class="va">state</span>.<span class="va">todos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">text</span>)</a>
<a class="sourceLine" id="cb194-5" title="5">)<span class="op">;</span></a></code></pre></div>
<p>Unlike Reselect, <code>proxy-memoize</code> can detect that only the <code>todo.text</code> fields are being accessed, and will only recalculate the rest if one of the <code>todo.text</code> fields changed.</p>
<p>It also has a built-in <code>size</code> option, which lets you set the desired cache size for a single selector instance.</p>
<p>It has some tradeoffs and differences from Reselect:</p>
<ul>
<li>All values are passed in as a single object argument</li>
<li>It requires that the environment supports ES6 <code>Proxy</code> objects (no IE11)</li>
<li>It’s more magical, whereas Reselect is more explicit</li>
<li>There are some edge cases regarding the <code>Proxy</code>-based tracking behavior</li>
<li>It’s newer and less widely used</li>
</ul>
<p>All that said, <strong>we officially encourage considering using <code>proxy-memoize</code> as a viable alternative to Reselect</strong>.</p>
<h3 id="re-reselect"><code>re-reselect</code></h3>
<p><a href="https://github.com/toomuchdesign/re-reselect" class="uri">https://github.com/toomuchdesign/re-reselect</a> improves Reselect’s caching behavior, by allowing you to define a “key selector”. This is used to manage multiple instances of Reselect selectors internally, which can help simplify usage across multiple components.</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb195-1" title="1"><span class="im">import</span> <span class="op">{</span> createCachedSelector <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;re-reselect&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb195-2" title="2"></a>
<a class="sourceLine" id="cb195-3" title="3"><span class="kw">const</span> getUsersByLibrary <span class="op">=</span> <span class="at">createCachedSelector</span>(</a>
<a class="sourceLine" id="cb195-4" title="4">  <span class="co">// inputSelectors</span></a>
<a class="sourceLine" id="cb195-5" title="5">  getUsers<span class="op">,</span></a>
<a class="sourceLine" id="cb195-6" title="6">  getLibraryId<span class="op">,</span></a>
<a class="sourceLine" id="cb195-7" title="7"></a>
<a class="sourceLine" id="cb195-8" title="8">  <span class="co">// resultFunc</span></a>
<a class="sourceLine" id="cb195-9" title="9">  (users<span class="op">,</span> libraryId) <span class="kw">=&gt;</span> <span class="at">expensiveComputation</span>(users<span class="op">,</span> libraryId)</a>
<a class="sourceLine" id="cb195-10" title="10">)(</a>
<a class="sourceLine" id="cb195-11" title="11">  <span class="co">// re-reselect keySelector (receives selectors&#39; arguments)</span></a>
<a class="sourceLine" id="cb195-12" title="12">  <span class="co">// Use &quot;libraryName&quot; as cacheKey</span></a>
<a class="sourceLine" id="cb195-13" title="13">  (_state_<span class="op">,</span> libraryName) <span class="kw">=&gt;</span> libraryName</a>
<a class="sourceLine" id="cb195-14" title="14">)<span class="op">;</span></a></code></pre></div>
<h3 id="reselect-tools"><code>reselect-tools</code></h3>
<p>Sometimes it can be hard to trace how multiple Reselect selectors relate to each other, and what caused a selector to recalculate. <a href="https://github.com/skortchmark9/reselect-tools" class="uri">https://github.com/skortchmark9/reselect-tools</a> provides a way to trace selector dependencies, and its own DevTools to help visualize those relationships and check selector values.</p>
<h3 id="redux-views"><code>redux-views</code></h3>
<p><a href="https://github.com/josepot/redux-views" class="uri">https://github.com/josepot/redux-views</a> is similar to <code>re-reselect</code>, in that it provides a way to select unique keys for each item for consistent caching. It was designed as a near-drop-in replacement for Reselect, and actually proposed as an option for a potential Reselect version 5.</p>
<h3 id="reselect-v5-proposal">Reselect v5 Proposal</h3>
<p>We’ve opened up a roadmap discussion in the Reselect repo to figure out potential enhancements to a future version of Reselect, such as improving the API to better support larger cache sizes, rewriting the codebase in TypeScript, and other possible improvements. We’d welcome additional community feedback in that discussion:</p>
<p><a href="https://github.com/reduxjs/reselect/discussions/491"><strong>Reselect v5 Roadmap Discussion: Goals and API Design</strong></a></p>
<h2 id="using-selectors-with-react-redux">Using Selectors with React-Redux</h2>
<h3 id="calling-selectors-with-parameters">Calling Selectors with Parameters</h3>
<p>It’s common to want to pass additional arguments to a selector function. However, <code>useSelector</code> always calls the provided selector function with one argument - the Redux root <code>state</code>.</p>
<p>The simplest solution is to pass an anonymous selector to <code>useSelector</code>, and then immediately call the real selector with both <code>state</code> and any additional arguments:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb196-1" title="1"><span class="im">import</span> <span class="op">{</span> selectTodoById <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./todosSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb196-2" title="2"></a>
<a class="sourceLine" id="cb196-3" title="3"><span class="kw">function</span> <span class="at">TodoListitem</span>(<span class="op">{</span> todoId <span class="op">}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb196-4" title="4">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb196-5" title="5">  <span class="co">// Captures `todoId` from scope, gets `state` as an arg, and forwards both</span></a>
<a class="sourceLine" id="cb196-6" title="6">  <span class="co">// to the actual selector function to extract the result</span></a>
<a class="sourceLine" id="cb196-7" title="7">  <span class="kw">const</span> todo <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span> <span class="at">selectTodoById</span>(state<span class="op">,</span> todoId))<span class="op">;</span></a>
<a class="sourceLine" id="cb196-8" title="8">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb196-9" title="9"><span class="op">}</span></a></code></pre></div>
<h3 id="creating-unique-selector-instances">Creating Unique Selector Instances</h3>
<p>There are many cases where a selector function needs to be reused across multiple components. If the components will all be calling the selector with different arguments, it will break memoization - the selector never sees the same arguments multiple times in a row, and thus can never return a cached value.</p>
<p>The standard approach here is to create a unique instance of a memoized selector in the component, and then use that with <code>useSelector</code>. That allows each component to consistently pass the same arguments to its own selector instance, and that selector can correctly memoize the results.</p>
<p>For function components, this is normally done with <code>useMemo</code> or <code>useCallback</code>:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb197-1" title="1"><span class="im">import</span> <span class="op">{</span> makeSelectItemsByCategory <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./categoriesSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb197-2" title="2"></a>
<a class="sourceLine" id="cb197-3" title="3"><span class="kw">function</span> <span class="at">CategoryList</span>(<span class="op">{</span> category <span class="op">}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb197-4" title="4">  <span class="co">// Create a new memoized selector, for each component instance, on mount</span></a>
<a class="sourceLine" id="cb197-5" title="5">  <span class="kw">const</span> selectItemsByCategory <span class="op">=</span> <span class="at">useMemo</span>(makeSelectItemsByCategory<span class="op">,</span> [])<span class="op">;</span></a>
<a class="sourceLine" id="cb197-6" title="6"></a>
<a class="sourceLine" id="cb197-7" title="7">  <span class="kw">const</span> itemsByCategory <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb197-8" title="8">    <span class="at">selectItemsByCategory</span>(state<span class="op">,</span> category)</a>
<a class="sourceLine" id="cb197-9" title="9">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb197-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>For class components with <code>connect</code>, this can be done with an advanced “factory function” syntax for <code>mapState</code>. If the <code>mapState</code> function returns a new function on its first call, that will be used as the real <code>mapState</code> function. This provides a closure where you can create a new selector instance:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb198-1" title="1"><span class="im">import</span> <span class="op">{</span> makeSelectItemsByCategory <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;./categoriesSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb198-2" title="2"></a>
<a class="sourceLine" id="cb198-3" title="3"><span class="kw">const</span> makeMapState <span class="op">=</span> (state<span class="op">,</span> ownProps) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb198-4" title="4">  <span class="co">// Closure - create a new unique selector instance here,</span></a>
<a class="sourceLine" id="cb198-5" title="5">  <span class="co">// and this will run once for every component instance</span></a>
<a class="sourceLine" id="cb198-6" title="6">  <span class="kw">const</span> selectItemsByCategory <span class="op">=</span> <span class="at">makeSelectItemsByCategory</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb198-7" title="7"></a>
<a class="sourceLine" id="cb198-8" title="8">  <span class="kw">const</span> realMapState <span class="op">=</span> (state<span class="op">,</span> ownProps) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb198-9" title="9">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb198-10" title="10">      <span class="dt">itemsByCategory</span><span class="op">:</span> <span class="at">selectItemsByCategory</span>(state<span class="op">,</span> <span class="va">ownProps</span>.<span class="at">category</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb198-11" title="11">    <span class="op">};</span></a>
<a class="sourceLine" id="cb198-12" title="12">  <span class="op">};</span></a>
<a class="sourceLine" id="cb198-13" title="13"></a>
<a class="sourceLine" id="cb198-14" title="14">  <span class="co">// Returning a function here will tell `connect` to use it as</span></a>
<a class="sourceLine" id="cb198-15" title="15">  <span class="co">// `mapState` instead of the original one given to `connect`</span></a>
<a class="sourceLine" id="cb198-16" title="16">  <span class="cf">return</span> realMapState<span class="op">;</span></a>
<a class="sourceLine" id="cb198-17" title="17"><span class="op">};</span></a>
<a class="sourceLine" id="cb198-18" title="18"></a>
<a class="sourceLine" id="cb198-19" title="19"><span class="im">export</span> <span class="im">default</span> <span class="at">connect</span>(makeMapState)(CategoryList)<span class="op">;</span></a></code></pre></div>
<h2 id="using-selectors-effectively">Using Selectors Effectively</h2>
<p>While selectors are a common pattern in Redux applications, they are often misused or misunderstood. Here are some guidelines for using selector functions correctly.</p>
<h3 id="define-selectors-alongside-reducers">Define Selectors Alongside Reducers</h3>
<p>Selector functions are often defined in the UI layer, directly inside of <code>useSelector</code> calls. However, this means that there can be repetition between selectors defined in different files, and the functions are anonymous.</p>
<p>Like any other function, you can extract an anonymous function outside the component to give it a name:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb199-1" title="1"><span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb199-2" title="2"><span class="kw">const</span> selectTodos <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span><span class="op">;</span></a>
<a class="sourceLine" id="cb199-3" title="3"></a>
<a class="sourceLine" id="cb199-4" title="4"><span class="kw">function</span> <span class="at">TodoList</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb199-5" title="5">  <span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb199-6" title="6">  <span class="kw">const</span> todos <span class="op">=</span> <span class="at">useSelector</span>(selectTodos)<span class="op">;</span></a>
<a class="sourceLine" id="cb199-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>However, multiple parts of the application may want to use the same lookups. Also, conceptually, we may want to keep the knowledge of how the <code>todos</code> state is organized as an implementation detail inside the <code>todosSlice</code> file, so that it’s all in one place.</p>
<p>Because of this, <strong>it’s a good idea to define reusable selectors alongside their corresponding reducers</strong>. In this case, we could export <code>selectTodos</code> from the <code>todosSlice</code> file:</p>
<p>```js title=“src/features/todos/todosSlice.js” import { createSlice } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>const todosSlice = createSlice({ name: “todos”, initialState: [], reducers: { todoAdded(state, action) { state.push(action.payload); }, }, });</p>
<p>export const { todoAdded } = todosSlice.actions; export default todosSlice.reducer;</p>
<p>// highlight-start // Export a reusable selector here export const selectTodos = (state) =&gt; state.todos; // highlight-end ```</p>
<p>That way, if we happen to make an update to the structure of the todos slice state, the relevant selectors are right here and can be updated at the same time, with minimal changes to any other parts of the app.</p>
<h3 id="balance-selector-usage">Balance Selector Usage</h3>
<p>It’s possible to add <em>too many</em> selectors to an application. <strong>Adding a separate selector function for every single field is not a good idea!</strong> That ends up turning Redux into something resembling a Java class with getter/setter functions for every field. It’s not going to <em>improve</em> the code, and it’s probably going to make the code <em>worse</em> - maintaining all those extra selectors is a lot of additional effort, and it will be harder to trace what values are being used where.</p>
<p>Similarly, <strong>don’t make every single selector memoized!</strong>. Memoization is only needed if you are truly <em>deriving</em> results, <em>and</em> if the derived results would likely create new references every time. <strong>A selector function that does a direct lookup and return of a value should be a plain function, not memoized</strong>.</p>
<p>Some examples of when and when not to memoize:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb200-1" title="1"><span class="co">// ❌ DO NOT memoize: will always return a consistent reference</span></a>
<a class="sourceLine" id="cb200-2" title="2"><span class="kw">const</span> selectTodos <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span><span class="op">;</span></a>
<a class="sourceLine" id="cb200-3" title="3"><span class="kw">const</span> selectNestedValue <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">some</span>.<span class="va">deeply</span>.<span class="va">nested</span>.<span class="at">field</span><span class="op">;</span></a>
<a class="sourceLine" id="cb200-4" title="4"><span class="kw">const</span> selectTodoById <span class="op">=</span> (state<span class="op">,</span> todoId) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span>[todoId]<span class="op">;</span></a>
<a class="sourceLine" id="cb200-5" title="5"></a>
<a class="sourceLine" id="cb200-6" title="6"><span class="co">// ❌ DO NOT memoize: deriving data, but will return a consistent result</span></a>
<a class="sourceLine" id="cb200-7" title="7"><span class="kw">const</span> selectItemsTotal <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb200-8" title="8">  <span class="cf">return</span> <span class="va">state</span>.<span class="va">items</span>.<span class="at">reduce</span>((result<span class="op">,</span> item) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb200-9" title="9">    <span class="cf">return</span> result <span class="op">+</span> <span class="va">item</span>.<span class="at">total</span><span class="op">;</span></a>
<a class="sourceLine" id="cb200-10" title="10">  <span class="op">},</span> <span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb200-11" title="11"><span class="op">};</span></a>
<a class="sourceLine" id="cb200-12" title="12"><span class="kw">const</span> selectAllCompleted <span class="op">=</span> (state) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb200-13" title="13">  <span class="va">state</span>.<span class="va">todos</span>.<span class="at">every</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb200-14" title="14"></a>
<a class="sourceLine" id="cb200-15" title="15"><span class="co">// ✅ SHOULD memoize: returns new references when called</span></a>
<a class="sourceLine" id="cb200-16" title="16"><span class="kw">const</span> selectTodoDescriptions <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">text</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="reshape-state-as-needed-for-components">Reshape State as Needed for Components</h3>
<p>Selectors do not have to limit themselves to direct lookups - they can perform <em>any</em> needed transformation logic inside. This is especially valuable to help prepare data that is needed by specific components.</p>
<p>A Redux state often has data in a “raw” form, because <a href="#deriving-data">the state should be kept minimal</a>, and many components may need to present the same data differently. You can use selectors to not only <em>extract</em> state, but to <em>reshape</em> it as needed for this specific component’s needs. That could include pulling data from multiple slices of the root state, extracting specific values, merging different pieces of the data together, or any other transformations that are helpful.</p>
<p>It’s fine if a component has some of this logic too, but it can be beneficial to pull all of this transformation logic out into separate selectors for better reuse and testability.</p>
<h3 id="globalize-selectors-if-needed">Globalize Selectors if Needed</h3>
<p>There’s an inherent imbalance between writing slice reducers and selectors. Slice reducers only know about their one portion of the state - to the reducer, its <code>state</code> is all that exists, such as the array of todos in a <code>todoSlice</code>. Selectors, on the other hand, <em>usually</em> are written to take the entire Redux root state as their argument. This means that they have to know where in the root state this slice’s data is kept, such as <code>state.todos</code>, even though that’s not really defined until the root reducer is created (typically in the app-wide store setup logic).</p>
<p>A typical slice file often has both of these patterns side-by-side. That’s fine, especially in small or midsize apps. But, depending on your app’s architecture, you may want to further abstract the selectors so that they <em>don’t</em> know where the slice state is kept - it has to be handed to them.</p>
<p>We refer to this pattern as “globalizing” selectors. A <strong>“globalized” selector</strong> is one that accepts the Redux root state as an argument, and knows how to find the relevant slice of state to perform the real logic. A <strong>“localized” selector</strong> is one that expects <em>just a piece</em> of the state as an argument, without knowing or caring where that is in the root state:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb201-1" title="1"><span class="co">// &quot;Globalized&quot; - accepts root state, knows to find data at `state.todos`</span></a>
<a class="sourceLine" id="cb201-2" title="2"><span class="kw">const</span> selectAllTodosCompletedGlobalized <span class="op">=</span> (state) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb201-3" title="3">  <span class="va">state</span>.<span class="va">todos</span>.<span class="at">every</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb201-4" title="4"></a>
<a class="sourceLine" id="cb201-5" title="5"><span class="co">// &quot;Localized&quot; - only accepts `todos` as argument, doesn&#39;t know where that came from</span></a>
<a class="sourceLine" id="cb201-6" title="6"><span class="kw">const</span> selectAllTodosCompletedLocalized <span class="op">=</span> (todos) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb201-7" title="7">  <span class="va">todos</span>.<span class="at">every</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)<span class="op">;</span></a></code></pre></div>
<p>“Localized” selectors can be turned into “globalized” selectors by wrapping them in a function that knows how to retrieve the right slice of state and pass it onwards.</p>
<p>Redux Toolkit’s <a href="https://redux-toolkit.js.org/api/createEntityAdapter#selector-functions"><code>createEntityAdapter</code> API</a> is an example of this pattern. If you call <code>todosAdapter.getSelectors()</code>, with no argument, it returns a set of “localized” selectors that expect the <em>entity slice state</em> as their argument. If you call <code>todosAdapter.getSelectors(state =&gt; state.todos)</code>, it returns a set of “globalized” selectors that expect to be called with the <em>Redux root state</em> as their argument.</p>
<p>There may also be other benefits to having “localized” versions of selectors as well. For example, say we have an advanced scenario of keeping multiple copies of <code>createEntityAdapter</code> data nested in the store, such as a <code>chatRoomsAdapter</code> that tracks rooms, and each room definition then has a <code>chatMessagesAdapter</code> state to store the messages. We can’t directly look up the messages for each room - we first have to retrieve the room object, then select the messages out of that. This is easier if we have a set of “localized” selectors for the messages.</p>
<h2 id="further-information-1">Further Information</h2>
<ul>
<li>Selector libraries:
<ul>
<li>Reselect: <a href="https://github.com/reduxjs/reselect" class="uri">https://github.com/reduxjs/reselect</a></li>
<li><code>proxy-memoize</code>: <a href="https://github.com/dai-shi/proxy-memoize" class="uri">https://github.com/dai-shi/proxy-memoize</a></li>
<li><code>re-reselect</code>: <a href="https://github.com/toomuchdesign/re-reselect" class="uri">https://github.com/toomuchdesign/re-reselect</a></li>
<li><code>reselect-tools</code>: <a href="https://github.com/skortchmark9/reselect-tools" class="uri">https://github.com/skortchmark9/reselect-tools</a></li>
<li><code>redux-views</code>: <a href="https://github.com/josepot/redux-views" class="uri">https://github.com/josepot/redux-views</a></li>
</ul></li>
<li><a href="https://github.com/reduxjs/reselect/discussions/491">Reselect v5 Roadmap Discussion: Goals and API Design</a></li>
<li>Randy Coulman has an excellent series of blog posts on selector architecture and different approaches for globalizing Redux selectors, with tradeoffs:
<ul>
<li><a href="https://randycoulman.com/blog/2016/09/13/encapsulating-the-redux-state-tree/">Encapsulating the Redux State Tree</a></li>
<li><a href="https://randycoulman.com/blog/2016/09/20/redux-reducer-selector-asymmetry/">Redux Reducer/Selector Asymmetry</a></li>
<li><a href="https://randycoulman.com/blog/2016/09/27/modular-reducers-and-selectors/">Modular Reducers and Selectors</a></li>
<li><a href="https://randycoulman.com/blog/2016/11/29/globalizing-redux-selectors/">Globalizing Redux Selectors</a></li>
<li><a href="https://randycoulman.com/blog/2016/12/27/globalizing-curried-selectors/">Globalizing Curried Selectors</a></li>
<li><a href="https://randycoulman.com/blog/2018/06/12/solving-circular-dependencies-in-modular-redux/">Solving Circular Dependencies in Modular Redux</a></li>
</ul></li>
</ul>
<hr />
<p>id: index title: Usage Guides Index sidebar_label: Usage Guides Index</p>
<hr />
<h1 id="usage-guides">Usage Guides</h1>
<p>The Usage Guides section provides practical guidance on how to correctly use Redux in real-world applications, including project setup and architecture, patterns, practices, and techniques.</p>
<p>:::info Prerequisites</p>
<p>The pages in this category assume you understand the core Redux terms and concepts explained in <a href="../tutorials/fundamentals/part-1-overview.md">the “Redux Fundamentals” tutorial</a>, including actions, reducers, stores, immutability, React-Redux, and async logic.</p>
<p>:::</p>
<h2 id="setup-and-organization">Setup and Organization</h2>
<p>This section covers information on how to set up and organize Redux-based projects.</p>
<ul>
<li><a href="ConfiguringYourStore.md">Configuring Your Store</a></li>
<li><a href="CodeSplitting.md">Code Splitting</a></li>
<li><a href="ServerRendering.md">Server Rendering</a></li>
<li><a href="IsolatingSubapps.md">Isolating Redux Sub-Apps</a></li>
</ul>
<h2 id="code-quality">Code Quality</h2>
<p>This section provides information on tools and techniques used to improve the quality of your Redux code.</p>
<ul>
<li><a href="UsageWithTypescript.md">Usage with TypeScript</a></li>
<li><a href="WritingTests.md">Writing Tests</a></li>
<li><a href="Troubleshooting.md">Troubleshooting</a></li>
</ul>
<h2 id="redux-logic-and-patterns">Redux Logic and Patterns</h2>
<p>This section provides information about typical Redux patterns and approaches for writing different kinds of Redux logic.</p>
<ul>
<li><a href="structuring-reducers/StructuringReducers.md">Structuring Reducers</a></li>
<li><a href="ReducingBoilerplate.md">Reducing Boilerplate</a></li>
<li><a href="../usage/deriving-data-selectors.md">Deriving Data with Selectors</a></li>
<li><a href="ImplementingUndoHistory.md">Implementing Undo History</a></li>
</ul>
<hr />
<p>id: part-1-overview title: ‘Redux Fundamentals, Part 1: Redux Overview’ sidebar_label: ‘Redux Overview’ description: ‘The official Fundamentals tutorial for Redux: learn the fundamentals of using Redux’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-1-redux-overview">Redux Fundamentals, Part 1: Redux Overview</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>What Redux is and why you might want to use it</li>
<li>The basic pieces that make up a Redux app</li>
</ul>
<p>:::</p>
<h2 id="introduction-1">Introduction</h2>
<p>Welcome to the Redux Fundamentals tutorial! <strong>This tutorial will introduce you to the core concepts, principles, and patterns for using Redux</strong>. By the time you finish, you should understand the different pieces that make up a Redux app, how data flows when using Redux, and our standard recommended patterns for building Redux apps.</p>
<p>In Part 1 of this tutorial, we’ll briefly look at a minimal example of a working Redux app to see what the pieces are, and in <a href="./part-2-concepts-data-flow.md">Part 2: Redux Concepts and Data Flow</a> we’ll look at those pieces in more detail and how data flows in a Redux application.</p>
<p>Starting in <a href="./part-3-state-actions-reducers.md">Part 3: State, Actions, and Reducers</a>, we’ll use that knowledge to build a small example app that demonstrates how these pieces fit together and talk about how Redux works in practice. After we finish building the working example app “by hand” so that you can see exactly what’s happening, we’ll talk about some of the standard patterns and abstractions typically used with Redux. Finally, we’ll see how these lower-level examples translate into the higher-level patterns that we recommend for actual usage in real applications.</p>
<h3 id="how-to-read-this-tutorial">How to Read This Tutorial</h3>
<p><strong>This tutorial will teach you “how Redux works”</strong>, as well as <em>why</em> these patterns exist. Fair warning though - learning the concepts is different from putting them into practice in actual apps.</p>
<p><strong>The initial code will be less concise than the way we suggest writing real app code</strong>, but writing it out long-hand is the best way to learn. Once you understand how everything fits together, we’ll look at using Redux Toolkit to simplify things. <strong>Redux Toolkit is the recommended way to build production apps with Redux</strong>, and is built on all of the concepts that we will look at throughout this tutorial. Once you understand the core concepts covered here, you’ll understand how to use Redux Toolkit more efficiently.</p>
<div class="info">
<p>If you’re looking to learn more about how Redux is used to write real-world applications, please see:</p>
<ul>
<li><a href="./part-8-modern-redux.md"><strong>The “Modern Redux” page in this tutorial</strong></a>, which shows how to convert the low-level examples from earlier sections into the modern patterns we do recommend for real-world usage</li>
<li><a href="../essentials/part-1-overview-concepts.md"><strong>The “Redux Essentials” tutorial</strong></a>, which teaches “how to use Redux, the right way” for real-world apps, using our latest recommended patterns and practices.</li>
</ul>
</div>
<p>We’ve tried to keep these explanations beginner-friendly, but we do need to make some assumptions about what you know already so that we can focus on explaining Redux itself. <strong>This tutorial assumes that you know</strong>:</p>
<p>:::important Prerequisites</p>
<ul>
<li>Familiarity with <a href="https://internetingishard.com/">HTML &amp; CSS</a>.</li>
<li>Familiarity with <a href="https://www.taniarascia.com/es6-syntax-and-feature-overview/">ES6 syntax and features</a></li>
<li>Understanding of <a href="https://javascript.info/rest-parameters-spread#spread-syntax">the array and object spread operators</a></li>
<li>Knowledge of React terminology: <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>, <a href="https://reactjs.org/docs/state-and-lifecycle.html">State</a>, <a href="https://reactjs.org/docs/components-and-props.html">Function Components, Props</a>, and <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a></li>
<li>Knowledge of <a href="https://javascript.info/promise-basics">asynchronous JavaScript</a> and <a href="https://javascript.info/fetch">making AJAX requests</a></li>
</ul>
<p>:::</p>
<p><strong>If you’re not already comfortable with those topics, we encourage you to take some time to become comfortable with them first, and then come back to learn about Redux</strong>. We’ll be here when you’re ready!</p>
<p>Finally, you should make sure that you have the React and Redux DevTools extensions installed in your browser:</p>
<ul>
<li>React DevTools Extension:
<ul>
<li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">React DevTools Extension for Chrome</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">React DevTools Extension for Firefox</a></li>
</ul></li>
<li>Redux DevTools Extension:
<ul>
<li><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en">Redux DevTools Extension for Chrome</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/">Redux DevTools Extension for Firefox</a></li>
</ul></li>
</ul>
<h2 id="what-is-redux">What is Redux?</h2>
<p>It helps to understand what this “Redux” thing is in the first place. What does it do? What problems does it help me solve? Why would I want to use it?</p>
<p><strong>Redux is a pattern and library for managing and updating application state, using events called “actions”.</strong> It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.</p>
<h3 id="why-should-i-use-redux">Why Should I Use Redux?</h3>
<p>Redux helps you manage “global” state - state that is needed across many parts of your application.</p>
<p><strong>The patterns and tools provided by Redux make it easier to understand when, where, why, and how the state in your application is being updated, and how your application logic will behave when those changes occur</strong>. Redux guides you towards writing code that is predictable and testable, which helps give you confidence that your application will work as expected.</p>
<h3 id="when-should-i-use-redux">When Should I Use Redux?</h3>
<p>Redux helps you deal with shared state management, but like any tool, it has tradeoffs. There are more concepts to learn, and more code to write. It also adds some indirection to your code, and asks you to follow certain restrictions. It’s a trade-off between short term and long term productivity.</p>
<p>Redux is more useful when:</p>
<ul>
<li>You have large amounts of application state that are needed in many places in the app</li>
<li>The app state is updated frequently over time</li>
<li>The logic to update that state may be complex</li>
<li>The app has a medium or large-sized codebase, and might be worked on by many people</li>
</ul>
<p><strong>Not all apps need Redux. Take some time to think about the kind of app you’re building, and decide what tools would be best to help solve the problems you’re working on.</strong></p>
<p>:::info Want to Know More?</p>
<p>If you’re not sure whether Redux is a good choice for your app, these resources give some more guidance:</p>
<ul>
<li><strong><a href="https://changelog.com/posts/when-and-when-not-to-reach-for-redux">When (and when not) to reach for Redux</a></strong></li>
<li><strong><a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/">The Tao of Redux, Part 1 - Implementation and Intent</a></strong></li>
<li><strong><a href="../../faq/General.md#when-should-i-use-redux">Redux FAQ: When should I use Redux?</a></strong></li>
<li><strong><a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">You Might Not Need Redux</a></strong></li>
</ul>
<p>:::</p>
<h3 id="redux-libraries-and-tools">Redux Libraries and Tools</h3>
<p>Redux is a small standalone JS library. However, it is commonly used with several other packages:</p>
<h4 id="react-redux">React-Redux</h4>
<p>Redux can integrate with any UI framework, and is most frequently used with React. <a href="https://react-redux.js.org/"><strong>React-Redux</strong></a> is our official package that lets your React components interact with a Redux store by reading pieces of state and dispatching actions to update the store.</p>
<h4 id="redux-toolkit-2">Redux Toolkit</h4>
<p><a href="https://redux-toolkit.js.org"><strong>Redux Toolkit</strong></a> is our recommended approach for writing Redux logic. It contains packages and functions that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications.</p>
<h4 id="redux-devtools-extension">Redux DevTools Extension</h4>
<p>The <a href="https://github.com/zalmoxisus/redux-devtools-extension"><strong>Redux DevTools Extension</strong></a> shows a history of the changes to the state in your Redux store over time. This allows you to debug your applications effectively, including using powerful techniques like “time-travel debugging”.</p>
<h2 id="redux-basics">Redux Basics</h2>
<p>Now that you know what Redux is, let’s briefly look at the pieces that make up a Redux app and how it works.</p>
<div class="info">
<p>The rest of the description on this page focuses solely on the Redux core library (the <code>redux</code> package). We’ll talk about the other Redux-related packages as we go through the rest of the tutorial.</p>
</div>
<h3 id="the-redux-store">The Redux Store</h3>
<p>The center of every Redux application is the <strong>store</strong>. A “store” is a container that holds your application’s global <strong>state</strong>.</p>
<p>A store is a JavaScript object with a few special functions and abilities that make it different than a plain global object:</p>
<ul>
<li>You must never directly modify or change the state that is kept inside the Redux store</li>
<li>Instead, the only way to cause an update to the state is to create a plain <strong>action</strong> object that describes “something that happened in the application”, and then <strong>dispatch</strong> the action to the store to tell it what happened.</li>
<li>When an action is dispatched, the store runs the root <strong>reducer</strong> function, and lets it calculate the new state based on the old state and the action</li>
<li>Finally, the store notifies <strong>subscribers</strong> that the state has been updated so the UI can be updated with the new data.</li>
</ul>
<h3 id="redux-core-example-app">Redux Core Example App</h3>
<p>Let’s look at a minimal working example of a Redux app - a small counter application:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/dank-architecture-lr7k1?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-core-example" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>Because Redux is a standalone JS library with no dependencies, this example is written by only loading a single script tag for the Redux library, and uses basic JS and HTML for the UI. In practice, Redux is normally used by <a href="../../introduction/Installation.md">installing the Redux packages from NPM</a>, and the UI is created using a library like <a href="https://reactjs.org">React</a>.</p>
<div class="info">
<p><a href="./part-5-ui-and-react.md">Part 5: UI and React</a> shows how to use Redux and React together.</p>
</div>
<p>Let’s break this example down into its separate parts to see what’s happening.</p>
<h4 id="state-actions-and-reducers">State, Actions, and Reducers</h4>
<p>We start by defining an initial <strong>state</strong> value to describe the application:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb202-1" title="1"><span class="co">// Define an initial state value for the app</span></a>
<a class="sourceLine" id="cb202-2" title="2"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb202-3" title="3">  <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb202-4" title="4"><span class="op">};</span></a></code></pre></div>
<p>For this app, we’re going to track a single number with the current value of our counter.</p>
<p>Redux apps normally have a JS object as the root piece of the state, with other values inside that object.</p>
<p>Then, we define a <strong>reducer</strong> function. The reducer receives two arguments, the current <code>state</code> and an <code>action</code> object describing what happened. When the Redux app starts up, we don’t have any state yet, so we provide the <code>initialState</code> as the default value for this reducer:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb203-1" title="1"><span class="co">// Create a &quot;reducer&quot; function that determines what the new state</span></a>
<a class="sourceLine" id="cb203-2" title="2"><span class="co">// should be when something happens in the app</span></a>
<a class="sourceLine" id="cb203-3" title="3"><span class="kw">function</span> <span class="at">counterReducer</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb203-4" title="4">  <span class="co">// Reducers usually look at the type of action that happened</span></a>
<a class="sourceLine" id="cb203-5" title="5">  <span class="co">// to decide how to update the state</span></a>
<a class="sourceLine" id="cb203-6" title="6">  <span class="cf">switch</span> (<span class="va">action</span>.<span class="at">type</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb203-7" title="7">    <span class="cf">case</span> <span class="st">&quot;counter/incremented&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb203-8" title="8">      <span class="cf">return</span> <span class="op">{</span> ...<span class="at">state</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="va">state</span>.<span class="at">value</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb203-9" title="9">    <span class="cf">case</span> <span class="st">&quot;counter/decremented&quot;</span><span class="op">:</span></a>
<a class="sourceLine" id="cb203-10" title="10">      <span class="cf">return</span> <span class="op">{</span> ...<span class="at">state</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="va">state</span>.<span class="at">value</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb203-11" title="11">    <span class="cf">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb203-12" title="12">      <span class="co">// If the reducer doesn&#39;t care about this action type,</span></a>
<a class="sourceLine" id="cb203-13" title="13">      <span class="co">// return the existing state unchanged</span></a>
<a class="sourceLine" id="cb203-14" title="14">      <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb203-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb203-16" title="16"><span class="op">}</span></a></code></pre></div>
<p>Action objects always have a <code>type</code> field, which is a string you provide that acts as a unique name for the action. The <code>type</code> should be a readable name so that anyone who looks at this code understands what it means. In this case, we use the word ‘counter’ as the first half of our action type, and the second half is a description of “what happened”. In this case, our ‘counter’ was ‘incremented’, so we write the action type as <code>'counter/incremented'</code>.</p>
<p>Based on the type of the action, we either need to return a brand-new object to be the new <code>state</code> result, or return the existing <code>state</code> object if nothing should change. Note that we update the state <em>immutably</em> by copying the existing state and updating the copy, instead of modifying the original object directly.</p>
<h4 id="store-1">Store</h4>
<p>Now that we have a reducer function, we can create a <strong>store</strong> instance by calling the Redux library <code>createStore</code> API.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb204-1" title="1"><span class="co">// Create a new Redux store with the `createStore` function,</span></a>
<a class="sourceLine" id="cb204-2" title="2"><span class="co">// and use the `counterReducer` for the update logic</span></a>
<a class="sourceLine" id="cb204-3" title="3"><span class="kw">const</span> store <span class="op">=</span> <span class="va">Redux</span>.<span class="at">createStore</span>(counterReducer)<span class="op">;</span></a></code></pre></div>
<p>We pass the reducer function to <code>createStore</code>, which uses the reducer function to generate the initial state, and to calculate any future updates.</p>
<h4 id="ui">UI</h4>
<p>In any application, the user interface will show existing state on screen. When a user does something, the app will update its data and then redraw the UI with those values.</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb205-1" title="1"><span class="co">// Our &quot;user interface&quot; is some text in a single HTML element</span></a>
<a class="sourceLine" id="cb205-2" title="2"><span class="kw">const</span> valueEl <span class="op">=</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;value&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb205-3" title="3"></a>
<a class="sourceLine" id="cb205-4" title="4"><span class="co">// Whenever the store state changes, update the UI by</span></a>
<a class="sourceLine" id="cb205-5" title="5"><span class="co">// reading the latest store state and showing new data</span></a>
<a class="sourceLine" id="cb205-6" title="6"><span class="kw">function</span> <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb205-7" title="7">  <span class="kw">const</span> state <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb205-8" title="8">  <span class="va">valueEl</span>.<span class="at">innerHTML</span> <span class="op">=</span> <span class="va">state</span>.<span class="va">value</span>.<span class="at">toString</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb205-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb205-10" title="10"></a>
<a class="sourceLine" id="cb205-11" title="11"><span class="co">// Update the UI with the initial data</span></a>
<a class="sourceLine" id="cb205-12" title="12"><span class="at">render</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb205-13" title="13"><span class="co">// And subscribe to redraw whenever the data changes in the future</span></a>
<a class="sourceLine" id="cb205-14" title="14"><span class="va">store</span>.<span class="at">subscribe</span>(render)<span class="op">;</span></a></code></pre></div>
<p>In this small example, we’re only using some basic HTML elements as our UI, with a single <code>&lt;div&gt;</code> showing the current value.</p>
<p>So, we write a function that knows how to get the latest state from the Redux store using the <code>store.getState()</code> method, then takes that value and updates the UI to show it.</p>
<p>The Redux store lets us call <code>store.subscribe()</code> and pass a subscriber callback function that will be called every time the store is updated. So, we can pass our <code>render</code> function as the subscriber, and know that each time the store updates, we can update the UI with the latest value.</p>
<p>Redux itself is a standalone library that can be used anywhere. This also means that it can be used with any UI layer.</p>
<h4 id="dispatching-actions">Dispatching Actions</h4>
<p>Finally, we need to respond to user input by creating <strong>action</strong> objects that describe what happened, and <strong>dispatching</strong> them to the store. When we call <code>store.dispatch(action)</code>, the store runs the reducer, calculates the updated state, and runs the subscribers to update the UI.</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb206-1" title="1"><span class="co">// Handle user inputs by &quot;dispatching&quot; action objects,</span></a>
<a class="sourceLine" id="cb206-2" title="2"><span class="co">// which should describe &quot;what happened&quot; in the app</span></a>
<a class="sourceLine" id="cb206-3" title="3"><span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;increment&quot;</span>).<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb206-4" title="4">  <span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-5" title="5"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-6" title="6"></a>
<a class="sourceLine" id="cb206-7" title="7"><span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;decrement&quot;</span>).<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb206-8" title="8">  <span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/decremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-9" title="9"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-10" title="10"></a>
<a class="sourceLine" id="cb206-11" title="11">document</a>
<a class="sourceLine" id="cb206-12" title="12">  .<span class="at">getElementById</span>(<span class="st">&quot;incrementIfOdd&quot;</span>)</a>
<a class="sourceLine" id="cb206-13" title="13">  .<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb206-14" title="14">    <span class="co">// We can write logic to decide what to do based on the state</span></a>
<a class="sourceLine" id="cb206-15" title="15">    <span class="cf">if</span> (<span class="va">store</span>.<span class="at">getState</span>().<span class="at">value</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">!==</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb206-16" title="16">      <span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb206-18" title="18">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-19" title="19"></a>
<a class="sourceLine" id="cb206-20" title="20">document</a>
<a class="sourceLine" id="cb206-21" title="21">  .<span class="at">getElementById</span>(<span class="st">&quot;incrementAsync&quot;</span>)</a>
<a class="sourceLine" id="cb206-22" title="22">  .<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb206-23" title="23">    <span class="co">// We can also write async logic that interacts with the store</span></a>
<a class="sourceLine" id="cb206-24" title="24">    <span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb206-25" title="25">      <span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-26" title="26">    <span class="op">},</span> <span class="dv">1000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb206-27" title="27">  <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Here, we’ll dispatch the actions that will make the reducer add 1 or subtract 1 from the current counter value.</p>
<p>We can also write code that only dispatches an action if a certain condition is true, or write some async code that dispatches an action after a delay.</p>
<h3 id="data-flow">Data Flow</h3>
<p>We can summarize the flow of data through a Redux app with this diagram. It represents how:</p>
<ul>
<li>actions are dispatched in response to a user interaction like a click</li>
<li>the store runs the reducer function to calculate a new state</li>
<li>the UI reads the new state to display the new values</li>
</ul>
<p>(Don’t worry if these pieces aren’t quite clear yet! Keep this picture in your mind as you go through the rest of this tutorial, and you’ll see how the pieces fit together.)</p>
<figure>
<img src="/img/tutorials/essentials/ReduxDataFlowDiagram.gif" alt="Redux data flow diagram" /><figcaption>Redux data flow diagram</figcaption>
</figure>
<h2 id="what-youve-learned">What You’ve Learned</h2>
<p>That counter example was small, but it does show all the working pieces of a real Redux app. <strong>Everything we’ll talk about in the following sections expands on those basic pieces.</strong></p>
<p>With that in mind, let’s review what we’ve learned so far:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux is a library for managing global application state</strong>
<ul>
<li>Redux is typically used with the React-Redux library for integrating Redux and React together</li>
<li>Redux Toolkit is the recommended way to write Redux logic</li>
</ul></li>
<li><strong>Redux uses several types of code</strong>
<ul>
<li><em>Actions</em> are plain objects with a <code>type</code> field, and describe “what happened” in the app</li>
<li><em>Reducers</em> are functions that calculate a new state value based on previous state + an action</li>
<li>A Redux <em>store</em> runs the root reducer whenever an action is <em>dispatched</em></li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next">What’s Next?</h2>
<p>Now that you know what the basic pieces of a Redux app are, step ahead to <a href="./part-2-concepts-data-flow.md">Part 2: Redux Concepts and Data Flow</a>, where we’ll look at how data flows through a Redux app in more detail.</p>
<hr />
<p>id: part-2-concepts-data-flow title: ‘Redux Fundamentals, Part 2: Concepts and Data Flow’ sidebar_label: ‘Redux Concepts and Data Flow’ description: ‘The official Redux Fundamentals tutorial: learn key Redux terms and how data flows in a Redux app’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-2-concepts-and-data-flow">Redux Fundamentals, Part 2: Concepts and Data Flow</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>Key terms and concepts for using Redux</li>
<li>How data flows through a Redux app</li>
</ul>
<p>:::</p>
<h2 id="introduction-2">Introduction</h2>
<p>In <a href="./part-1-overview.md">Part 1: Redux Overview</a>, we talked about what Redux is, why you might want to use it, and listed the other Redux libraries that are typically used with the Redux core. We also saw a small example of what a working Redux app looks like and the pieces that make up the app. Finally, we briefly mentioned some of the terms and concepts used with Redux.</p>
<p>In this section, we’ll look at those terms and concepts in more detail, and talk more about how data flows through a Redux application.</p>
<h2 id="background-concepts">Background Concepts</h2>
<p>Before we dive into some actual code, let’s talk about some of the terms and concepts you’ll need to know to use Redux.</p>
<h3 id="state-management">State Management</h3>
<p>Let’s start by looking at a small React counter component. It tracks a number in component state, and increments the number when a button is clicked:</p>
<pre class="jsx"><code>function Counter() {
  // State: a counter value
  const [counter, setCounter] = useState(0);

  // Action: code that causes an update to the state when something happens
  const increment = () =&gt; {
    setCounter((prevCounter) =&gt; prevCounter + 1);
  };

  // View: the UI definition
  return (
    &lt;div&gt;
      Value: {counter} &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>It is a self-contained app with the following parts:</p>
<ul>
<li>The <strong>state</strong>, the source of truth that drives our app;</li>
<li>The <strong>view</strong>, a declarative description of the UI based on the current state</li>
<li>The <strong>actions</strong>, the events that occur in the app based on user input, and trigger updates in the state</li>
</ul>
<p>This is a small example of <strong>“one-way data flow”</strong>:</p>
<ul>
<li>State describes the condition of the app at a specific point in time</li>
<li>The UI is rendered based on that state</li>
<li>When something happens (such as a user clicking a button), the state is updated based on what occurred</li>
<li>The UI re-renders based on the new state</li>
</ul>
<figure>
<img src="/img/tutorials/essentials/one-way-data-flow.png" alt="One-way data flow" /><figcaption>One-way data flow</figcaption>
</figure>
<p>However, the simplicity can break down when we have <strong>multiple components that need to share and use the same state</strong>, especially if those components are located in different parts of the application. Sometimes this can be solved by <a href="https://reactjs.org/docs/lifting-state-up.html">“lifting state up”</a> to parent components, but that doesn’t always help.</p>
<p>One way to solve this is to extract the shared state from the components, and put it into a centralized location outside the component tree. With this, our component tree becomes a big “view”, and any component can access the state or trigger actions, no matter where they are in the tree!</p>
<p>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</p>
<p>This is the basic idea behind Redux: a single centralized place to contain the global state in your application, and specific patterns to follow when updating that state to make the code predictable.</p>
<h3 id="immutability">Immutability</h3>
<p>“Mutable” means “changeable”. If something is “immutable”, it can never be changed.</p>
<p>JavaScript objects and arrays are all mutable by default. If I create an object, I can change the contents of its fields. If I create an array, I can change the contents as well:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb208-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">2</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb208-2" title="2"><span class="co">// still the same object outside, but the contents have changed</span></a>
<a class="sourceLine" id="cb208-3" title="3"><span class="va">obj</span>.<span class="at">b</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></a>
<a class="sourceLine" id="cb208-4" title="4"></a>
<a class="sourceLine" id="cb208-5" title="5"><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb208-6" title="6"><span class="co">// In the same way, we can change the contents of this array</span></a>
<a class="sourceLine" id="cb208-7" title="7"><span class="va">arr</span>.<span class="at">push</span>(<span class="st">&quot;c&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb208-8" title="8">arr[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;d&quot;</span><span class="op">;</span></a></code></pre></div>
<p>This is called <em>mutating</em> the object or array. It’s the same object or array reference in memory, but now the contents inside the object have changed.</p>
<p><strong>In order to update values immutably, your code must make <em>copies</em> of existing objects/arrays, and then modify the copies</strong>.</p>
<p>We can do this by hand using JavaScript’s array / object spread operators, as well as array methods that return new copies of the array instead of mutating the original array:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb209-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb209-2" title="2">  <span class="dt">a</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb209-3" title="3">    <span class="co">// To safely update obj.a.c, we have to copy each piece</span></a>
<a class="sourceLine" id="cb209-4" title="4">    <span class="dt">c</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span></a>
<a class="sourceLine" id="cb209-5" title="5">  <span class="op">},</span></a>
<a class="sourceLine" id="cb209-6" title="6">  <span class="dt">b</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span></a>
<a class="sourceLine" id="cb209-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb209-8" title="8"></a>
<a class="sourceLine" id="cb209-9" title="9"><span class="kw">const</span> obj2 <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb209-10" title="10">  <span class="co">// copy obj</span></a>
<a class="sourceLine" id="cb209-11" title="11">  ...<span class="at">obj</span><span class="op">,</span></a>
<a class="sourceLine" id="cb209-12" title="12">  <span class="co">// overwrite a</span></a>
<a class="sourceLine" id="cb209-13" title="13">  <span class="dt">a</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb209-14" title="14">    <span class="co">// copy obj.a</span></a>
<a class="sourceLine" id="cb209-15" title="15">    ...<span class="va">obj</span>.<span class="at">a</span><span class="op">,</span></a>
<a class="sourceLine" id="cb209-16" title="16">    <span class="co">// overwrite c</span></a>
<a class="sourceLine" id="cb209-17" title="17">    <span class="dt">c</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span></a>
<a class="sourceLine" id="cb209-18" title="18">  <span class="op">},</span></a>
<a class="sourceLine" id="cb209-19" title="19"><span class="op">};</span></a>
<a class="sourceLine" id="cb209-20" title="20"></a>
<a class="sourceLine" id="cb209-21" title="21"><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb209-22" title="22"><span class="co">// Create a new copy of arr, with &quot;c&quot; appended to the end</span></a>
<a class="sourceLine" id="cb209-23" title="23"><span class="kw">const</span> arr2 <span class="op">=</span> <span class="va">arr</span>.<span class="at">concat</span>(<span class="st">&quot;c&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb209-24" title="24"></a>
<a class="sourceLine" id="cb209-25" title="25"><span class="co">// or, we can make a copy of the original array:</span></a>
<a class="sourceLine" id="cb209-26" title="26"><span class="kw">const</span> arr3 <span class="op">=</span> <span class="va">arr</span>.<span class="at">slice</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb209-27" title="27"><span class="co">// and mutate the copy:</span></a>
<a class="sourceLine" id="cb209-28" title="28"><span class="va">arr3</span>.<span class="at">push</span>(<span class="st">&quot;c&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p><strong>Redux expects that all state updates are done immutably</strong>. We’ll look at where and how this is important a bit later, as well as some easier ways to write immutable update logic.</p>
<p>:::info Want to Know More?</p>
<p>For more info on how immutability works in JavaScript, see:</p>
<ul>
<li><a href="https://daveceddia.com/javascript-references/">A Visual Guide to References in JavaScript</a></li>
<li><a href="https://daveceddia.com/react-redux-immutability-guide/">Immutability in React and Redux: The Complete Guide</a></li>
</ul>
<p>:::</p>
<h2 id="redux-terminology">Redux Terminology</h2>
<p>There’s some important Redux terms that you’ll need to be familiar with before we continue:</p>
<h3 id="actions-2">Actions</h3>
<p>An <strong>action</strong> is a plain JavaScript object that has a <code>type</code> field. <strong>You can think of an action as an event that describes something that happened in the application</strong>.</p>
<p>The <code>type</code> field should be a string that gives this action a descriptive name, like <code>"todos/todoAdded"</code>. We usually write that type string like <code>"domain/eventName"</code>, where the first part is the feature or category that this action belongs to, and the second part is the specific thing that happened.</p>
<p>An action object can have other fields with additional information about what happened. By convention, we put that information in a field called <code>payload</code>.</p>
<p>A typical action object might look like this:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb210-1" title="1"><span class="kw">const</span> addTodoAction <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb210-2" title="2">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todoAdded&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb210-3" title="3">  <span class="dt">payload</span><span class="op">:</span> <span class="st">&quot;Buy milk&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb210-4" title="4"><span class="op">};</span></a></code></pre></div>
<h3 id="reducers-4">Reducers</h3>
<p>A <strong>reducer</strong> is a function that receives the current <code>state</code> and an <code>action</code> object, decides how to update the state if necessary, and returns the new state: <code>(state, action) =&gt; newState</code>. <strong>You can think of a reducer as an event listener which handles events based on the received action (event) type.</strong></p>
<div class="info">
<p>“Reducer” functions get their name because they’re similar to the kind of callback function you pass to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><code>Array.reduce()</code></a> method.</p>
</div>
<p>Reducers must <em>always</em> follow some specific rules:</p>
<ul>
<li>They should only calculate the new state value based on the <code>state</code> and <code>action</code> arguments</li>
<li>They are not allowed to modify the existing <code>state</code>. Instead, they must make <em>immutable updates</em>, by copying the existing <code>state</code> and making changes to the copied values.</li>
<li>They must not do any asynchronous logic, calculate random values, or cause other “side effects”</li>
</ul>
<p>We’ll talk more about the rules of reducers later, including why they’re important and how to follow them correctly.</p>
<p>The logic inside reducer functions typically follows the same series of steps:</p>
<ul>
<li>Check to see if the reducer cares about this action
<ul>
<li>If so, make a copy of the state, update the copy with new values, and return it</li>
</ul></li>
<li>Otherwise, return the existing state unchanged</li>
</ul>
<p>Here’s a small example of a reducer, showing the steps that each reducer should follow:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb211-1" title="1"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb211-2" title="2"></a>
<a class="sourceLine" id="cb211-3" title="3"><span class="kw">function</span> <span class="at">counterReducer</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb211-4" title="4">  <span class="co">// Check to see if the reducer cares about this action</span></a>
<a class="sourceLine" id="cb211-5" title="5">  <span class="cf">if</span> (<span class="va">action</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&quot;counter/incremented&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb211-6" title="6">    <span class="co">// If so, make a copy of `state`</span></a>
<a class="sourceLine" id="cb211-7" title="7">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb211-8" title="8">      ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb211-9" title="9">      <span class="co">// and update the copy with the new value</span></a>
<a class="sourceLine" id="cb211-10" title="10">      <span class="dt">value</span><span class="op">:</span> <span class="va">state</span>.<span class="at">value</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb211-11" title="11">    <span class="op">};</span></a>
<a class="sourceLine" id="cb211-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb211-13" title="13">  <span class="co">// otherwise return the existing state unchanged</span></a>
<a class="sourceLine" id="cb211-14" title="14">  <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb211-15" title="15"><span class="op">}</span></a></code></pre></div>
<p>Reducers can use any kind of logic inside to decide what the new state should be: <code>if/else</code>, <code>switch</code>, loops, and so on.</p>
<p><DetailedExplanation title="Detailed Explanation: Why Are They Called 'Reducers?'" ></p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><code>Array.reduce()</code></a> method lets you take an array of values, process each item in the array one at a time, and return a single final result. You can think of it as “reducing the array down to one value”.</p>
<p><code>Array.reduce()</code> takes a callback function as an argument, which will be called one time for each item in the array. It takes two arguments:</p>
<ul>
<li><code>previousResult</code>, the value that your callback returned last time</li>
<li><code>currentItem</code>, the current item in the array</li>
</ul>
<p>The first time that the callback runs, there isn’t a <code>previousResult</code> available, so we need to also pass in an initial value that will be used as the first <code>previousResult</code>.</p>
<p>If we wanted to add together an array of numbers to find out what the total is, we could write a reduce callback that looks like this:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb212-1" title="1"><span class="kw">const</span> numbers <span class="op">=</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb212-2" title="2"></a>
<a class="sourceLine" id="cb212-3" title="3"><span class="kw">const</span> addNumbers <span class="op">=</span> (previousResult<span class="op">,</span> currentItem) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb212-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="op">{</span> previousResult<span class="op">,</span> currentItem <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb212-5" title="5">  <span class="cf">return</span> previousResult <span class="op">+</span> currentItem<span class="op">;</span></a>
<a class="sourceLine" id="cb212-6" title="6"><span class="op">};</span></a>
<a class="sourceLine" id="cb212-7" title="7"></a>
<a class="sourceLine" id="cb212-8" title="8"><span class="kw">const</span> initialValue <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb212-9" title="9"></a>
<a class="sourceLine" id="cb212-10" title="10"><span class="kw">const</span> total <span class="op">=</span> <span class="va">numbers</span>.<span class="at">reduce</span>(addNumbers<span class="op">,</span> initialValue)<span class="op">;</span></a>
<a class="sourceLine" id="cb212-11" title="11"><span class="co">// {previousResult: 0, currentItem: 2}</span></a>
<a class="sourceLine" id="cb212-12" title="12"><span class="co">// {previousResult: 2, currentItem: 5}</span></a>
<a class="sourceLine" id="cb212-13" title="13"><span class="co">// {previousResult: 7, currentItem: 8}</span></a>
<a class="sourceLine" id="cb212-14" title="14"></a>
<a class="sourceLine" id="cb212-15" title="15"><span class="va">console</span>.<span class="at">log</span>(total)<span class="op">;</span></a>
<a class="sourceLine" id="cb212-16" title="16"><span class="co">// 15</span></a></code></pre></div>
<p>Notice that this <code>addNumbers</code> “reduce callback” function doesn’t need to keep track of anything itself. It takes the <code>previousResult</code> and <code>currentItem</code> arguments, does something with them, and returns a new result value.</p>
<p><strong>A Redux reducer function is exactly the same idea as this “reduce callback” function!</strong> It takes a “previous result” (the <code>state</code>), and the “current item” (the <code>action</code> object), decides a new state value based on those arguments, and returns that new state.</p>
<p>If we were to create an array of Redux actions, call <code>reduce()</code>, and pass in a reducer function, we’d get a final result the same way:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb213-1" title="1"><span class="kw">const</span> actions <span class="op">=</span> [</a>
<a class="sourceLine" id="cb213-2" title="2">  <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb213-3" title="3">  <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb213-4" title="4">  <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb213-5" title="5">]<span class="op">;</span></a>
<a class="sourceLine" id="cb213-6" title="6"></a>
<a class="sourceLine" id="cb213-7" title="7"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb213-8" title="8"></a>
<a class="sourceLine" id="cb213-9" title="9"><span class="kw">const</span> finalResult <span class="op">=</span> <span class="va">actions</span>.<span class="at">reduce</span>(counterReducer<span class="op">,</span> initialState)<span class="op">;</span></a>
<a class="sourceLine" id="cb213-10" title="10"><span class="va">console</span>.<span class="at">log</span>(finalResult)<span class="op">;</span></a>
<a class="sourceLine" id="cb213-11" title="11"><span class="co">// {value: 3}</span></a></code></pre></div>
<p>We can say that <strong>Redux reducers reduce a set of actions (over time) into a single state</strong>. The difference is that with <code>Array.reduce()</code> it happens all at once, and with Redux, it happens over the lifetime of your running app.</p>
<p></DetailedExplanation></p>
<h3 id="store-2">Store</h3>
<p>The current Redux application state lives in an object called the <strong>store</strong> .</p>
<p>The store is created by passing in a reducer, and has a method called <code>getState</code> that returns the current state value:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb214-1" title="1"><span class="im">import</span> <span class="op">{</span> configureStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb214-2" title="2"></a>
<a class="sourceLine" id="cb214-3" title="3"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span> <span class="dt">reducer</span><span class="op">:</span> counterReducer <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb214-4" title="4"></a>
<a class="sourceLine" id="cb214-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb214-6" title="6"><span class="co">// {value: 0}</span></a></code></pre></div>
<h3 id="dispatch">Dispatch</h3>
<p>The Redux store has a method called <code>dispatch</code>. <strong>The only way to update the state is to call <code>store.dispatch()</code> and pass in an action object</strong>. The store will run its reducer function and save the new state value inside, and we can call <code>getState()</code> to retrieve the updated value:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb215-1" title="1"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb215-2" title="2"></a>
<a class="sourceLine" id="cb215-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb215-4" title="4"><span class="co">// {value: 1}</span></a></code></pre></div>
<p><strong>You can think of dispatching actions as “triggering an event”</strong> in the application. Something happened, and we want the store to know about it. Reducers act like event listeners, and when they hear an action they are interested in, they update the state in response.</p>
<h3 id="selectors-1">Selectors</h3>
<p><strong>Selectors</strong> are functions that know how to extract specific pieces of information from a store state value. As an application grows bigger, this can help avoid repeating logic as different parts of the app need to read the same data:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb216-1" title="1"><span class="kw">const</span> selectCounterValue <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">value</span><span class="op">;</span></a>
<a class="sourceLine" id="cb216-2" title="2"></a>
<a class="sourceLine" id="cb216-3" title="3"><span class="kw">const</span> currentValue <span class="op">=</span> <span class="at">selectCounterValue</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb216-4" title="4"><span class="va">console</span>.<span class="at">log</span>(currentValue)<span class="op">;</span></a>
<a class="sourceLine" id="cb216-5" title="5"><span class="co">// 2</span></a></code></pre></div>
<h2 id="core-concepts-and-principles">Core Concepts and Principles</h2>
<p>Overall, we can summarize the intent behind Redux’s design in three core concepts:</p>
<h3 id="single-source-of-truth">Single Source of Truth</h3>
<p>The <strong>global state</strong> of your application is stored as an object inside a single <strong>store</strong>. Any given piece of data should only exist in one location, rather than being duplicated in many places.</p>
<p>This makes it easier to debug and inspect your app’s state as things change, as well as centralizing logic that needs to interact with the entire application.</p>
<div class="tip">
<p>This does <em>not</em> mean that <em>every</em> piece of state in your app must go into the Redux store! You should decide whether a piece of state belongs in Redux or your UI components, based on where it’s needed.</p>
</div>
<h3 id="state-is-read-only">State is Read-Only</h3>
<p>The only way to change the state is to dispatch an <strong>action</strong>, an object that describes what happened.</p>
<p>This way, the UI won’t accidentally overwrite data, and it’s easier to trace why a state update happened. Since actions are plain JS objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</p>
<h3 id="changes-are-made-with-pure-reducer-functions">Changes are Made with Pure Reducer Functions</h3>
<p>To specify how the state tree is updated based on actions, you write <strong>reducer</strong> functions. Reducers are pure functions that take the previous state and an action, and return the next state. Like any other functions, you can split reducers into smaller functions to help do the work, or write reusable reducers for common tasks.</p>
<h2 id="redux-application-data-flow">Redux Application Data Flow</h2>
<p>Earlier, we talked about “one-way data flow”, which describes this sequence of steps to update the app:</p>
<ul>
<li>State describes the condition of the app at a specific point in time</li>
<li>The UI is rendered based on that state</li>
<li>When something happens (such as a user clicking a button), the state is updated based on what occurred</li>
<li>The UI re-renders based on the new state</li>
</ul>
<p>For Redux specifically, we can break these steps into more detail:</p>
<ul>
<li>Initial setup:
<ul>
<li>A Redux store is created using a root reducer function</li>
<li>The store calls the root reducer once, and saves the return value as its initial <code>state</code></li>
<li>When the UI is first rendered, UI components access the current state of the Redux store, and use that data to decide what to render. They also subscribe to any future store updates so they can know if the state has changed.</li>
</ul></li>
<li>Updates:
<ul>
<li>Something happens in the app, such as a user clicking a button</li>
<li>The app code dispatches an action to the Redux store, like <code>dispatch({type: 'counter/incremented'})</code></li>
<li>The store runs the reducer function again with the previous <code>state</code> and the current <code>action</code>, and saves the return value as the new <code>state</code></li>
<li>The store notifies all parts of the UI that are subscribed that the store has been updated</li>
<li>Each UI component that needs data from the store checks to see if the parts of the state they need have changed.</li>
<li>Each component that sees its data has changed forces a re-render with the new data, so it can update what’s shown on the screen</li>
</ul></li>
</ul>
<p>Here’s what that data flow looks like visually:</p>
<figure>
<img src="/img/tutorials/essentials/ReduxDataFlowDiagram.gif" alt="Redux data flow diagram" /><figcaption>Redux data flow diagram</figcaption>
</figure>
<h2 id="what-youve-learned-1">What You’ve Learned</h2>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux’s intent can be summarized in three principles</strong>
<ul>
<li>Global app state is kept in a single store</li>
<li>The store state is read-only to the rest of the app</li>
<li>Reducer functions are used to update the state in response to actions</li>
</ul></li>
<li><strong>Redux uses a “one-way data flow” app structure</strong>
<ul>
<li>State describes the condition of the app at a point in time, and UI renders based on that state</li>
<li>When something happens in the app:
<ul>
<li>The UI dispatches an action</li>
<li>The store runs the reducers, and the state is updated based on what occurred</li>
<li>The store notifies the UI that the state has changed</li>
</ul></li>
<li>The UI re-renders based on the new state</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-1">What’s Next?</h2>
<p>You should now be familiar with the key concepts and terms that describe the different parts of a Redux app.</p>
<p>Now, let’s see how those pieces work together as we start building a new Redux application in <a href="./part-3-state-actions-reducers">Part 3: State, Actions, and Reducers</a>.</p>
<hr />
<p>id: part-3-state-actions-reducers title: ‘Redux Fundamentals, Part 3: State, Actions, and Reducers’ sidebar_label: ‘State, Actions, and Reducers’ description: ‘The official Redux Fundamentals tutorial: learn how reducers update state in response to actions’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-3-state-actions-and-reducers">Redux Fundamentals, Part 3: State, Actions, and Reducers</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to define state values that contain your app’s data</li>
<li>How to define action objects that describe what happens in your app</li>
<li>How to write reducer functions that calculate updated state based on existing state and actions</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Familiarity with key Redux terms and concepts like “actions”, “reducers”, “store”, and “dispatching”. (See <strong><a href="./part-2-concepts-data-flow.md">Part 2: Redux Concepts and Data Flow</a></strong> for explanations of these terms.)</li>
</ul>
<p>:::</p>
<h2 id="introduction-3">Introduction</h2>
<p>In <a href="./part-2-concepts-data-flow.md">Part 2: Redux Concepts and Data Flow</a>, we looked at how Redux can help us build maintainable apps by giving us a single central place to put global app state. We also talked about core Redux concepts like dispatching action objects and using reducer functions that return new state values.</p>
<p>Now that you have some idea of what these pieces are, it’s time to put that knowledge into practice. We’re going to build a small example app to see how these pieces actually work together.</p>
<div class="caution">
<p><strong>The example app is not meant as a complete production-ready project</strong>. The goal is to help you learn core Redux APIs and usage patterns, and point you in the right direction using some limited examples. Also, some of the early pieces we build will be updated later on to show better ways to do things. <strong>Please read through the whole tutorial to see all the concepts in use</strong>.</p>
</div>
<h3 id="project-setup">Project Setup</h3>
<p>For this tutorial, we’ve created a pre-configured starter project that already has React set up, includes some default styling, and has a fake REST API that will allow us to write actual API requests in our app. You’ll use this as the basis for writing the actual application code.</p>
<p>To get started, you can open and fork this CodeSandbox:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/master/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>You can also <a href="https://github.com/reduxjs/redux-fundamentals-example-app">clone the same project from this Github repo</a>. After cloning the repo, you can install the tools for the project with <code>npm install</code>, and start it with <code>npm start</code>.</p>
<p>If you’d like to see the final version of what we’re going to build, you can check out <a href="https://github.com/reduxjs/redux-fundamentals-example-app/tree/tutorial-steps">the <strong><code>tutorial-steps</code> branch</strong></a>, or <a href="https://codesandbox.io/s/github/reduxjs/redux-fundamentals-example-app/tree/tutorial-steps">look at the final version in this CodeSandbox</a>.</p>
<h4 id="creating-a-new-redux-react-project">Creating a New Redux + React Project</h4>
<p>Once you’ve finished this tutorial, you’ll probably want to try working on your own projects. <strong>We recommend using the <a href="https://github.com/reduxjs/cra-template-redux">Redux templates for Create-React-App</a> as the fastest way to create a new Redux + React project</strong>. It comes with Redux Toolkit and React-Redux already configured, using <a href="./part-1-overview.md">a modernized version of the “counter” app example you saw in Part 1</a>. This lets you jump right into writing your actual application code without having to add the Redux packages and set up the store.</p>
<p>If you want to know specific details on how to add Redux to a project, see this explanation:</p>
<p><DetailedExplanation title="Detailed Explanation: Adding Redux to a React Project"></p>
<p>The Redux template for CRA comes with Redux Toolkit and React-Redux already configured. If you’re setting up a new project from scratch without that template, follow these steps:</p>
<ul>
<li>Add the <code>@reduxjs/toolkit</code> and <code>react-redux</code> packages</li>
<li>Create a Redux store using RTK’s <code>configureStore</code> API, and pass in at least one reducer function</li>
<li>Import the Redux store into your application’s entry point file (such as <code>src/index.js</code>)</li>
<li>Wrap your root React component with the <code>&lt;Provider&gt;</code> component from React-Redux, like:</li>
</ul>
<pre class="jsx"><code>ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&quot;root&quot;)
);</code></pre>
<p></DetailedExplanation></p>
<h4 id="exploring-the-initial-project">Exploring the Initial Project</h4>
<p>This initial project is based on <a href="https://create-react-app.dev/docs/getting-started">the standard Create-React-App</a> project template, with some modifications.</p>
<p>Let’s take a quick look at what the initial project contains:</p>
<ul>
<li><code>/src</code>
<ul>
<li><code>index.js</code>: the entry point file for the application. It renders the main <code>&lt;App&gt;</code> component.</li>
<li><code>App.js</code>: the main application component.</li>
<li><code>index.css</code>: styles for the complete application</li>
<li><code>/api</code>
<ul>
<li><code>client.js</code>: a small AJAX request client that allows us to make GET and POST requests</li>
<li><code>server.js</code>: provides a fake REST API for our data. Our app will fetch data from these fake endpoints later.</li>
</ul></li>
<li><code>/exampleAddons</code>: contains some additional Redux addons that we’ll use later in the tutorial to show how things work</li>
</ul></li>
</ul>
<p>If you load the app now, you should see a welcome message, but the rest of the app is otherwise empty.</p>
<p>With that, let’s get started!</p>
<h2 id="starting-the-todo-example-app">Starting the Todo Example App</h2>
<p>Our example application will be a small “todo” application. You’ve probably seen todo app examples before - they make good examples because they let us show how to do things like tracking a list of items, handling user input, and updating the UI when that data changes, which are all things that happen in a normal application.</p>
<h3 id="defining-requirements">Defining Requirements</h3>
<p>Let’s start by figuring out the initial business requirements for this application:</p>
<ul>
<li>The UI should consist of three main sections:
<ul>
<li>An input box to let the user type in the text of a new todo item</li>
<li>A list of all the existing todo items</li>
<li>A footer section that shows the number of non-completed todos, and shows filtering options</li>
</ul></li>
<li>Todo list items should have a checkbox that toggles their “completed” status. We should also be able to add a color-coded category tag for a predefined list of colors, and delete todo items.</li>
<li>The counter should pluralize the number of active todos: “0 items”, “1 item”, “3 items”, etc</li>
<li>There should be buttons to mark all todos as completed, and to clear all completed todos by removing them</li>
<li>There should be two ways to filter the displayed todos in the list:
<ul>
<li>Filtering based on showing “All”, “Active”, and “Completed” todos</li>
<li>Filtering based on selecting one or more colors, and showing any todos whose tag that match those colors</li>
</ul></li>
</ul>
<p>We’ll add some more requirements later on, but this is enough to get us started.</p>
<p>The end goal is an app that should look like this:</p>
<figure>
<img src="/img/tutorials/fundamentals/todos-app-screenshot.png" alt="Example todo app screenshot" /><figcaption>Example todo app screenshot</figcaption>
</figure>
<h3 id="designing-the-state-values">Designing the State Values</h3>
<p>One of the core principles of React and Redux is that <strong>your UI should be based on your state</strong>. So, one approach to designing an application is to first think of all the state needed to describe how the application works. It’s also a good idea to try to describe your UI with as few values in the state as possible, so there’s less data you need to keep track of and update.</p>
<p>Conceptually, there are two main aspects of this application:</p>
<ul>
<li>The actual list of current todo items</li>
<li>The current filtering options</li>
</ul>
<p>We’ll also need to keep track of the data the user is typing into the “Add Todo” input box, but that’s less important and we’ll handle that later.</p>
<p>For each todo item, we need to store a few pieces of information:</p>
<ul>
<li>The text the user entered</li>
<li>The boolean flag saying if it’s completed or not</li>
<li>A unique ID value</li>
<li>A color category, if selected</li>
</ul>
<p>Our filtering behavior can probably be described with some enumerated values:</p>
<ul>
<li>Completed status: “All”, “Active”, and “Completed”</li>
<li>Colors: “Red”, “Yellow”, “Green”, “Blue”, “Orange”, “Purple”</li>
</ul>
<p>Looking at these values, we can also say that the todos are “app state” (the core data that the application works with), while the filtering values are “UI state” (state that describes what the app is doing right now). It can be helpful to think about these different kinds of categories to help understand how the different pieces of state are being used.</p>
<h3 id="designing-the-state-structure">Designing the State Structure</h3>
<p>With Redux, <strong>our application state is always kept in plain JavaScript objects and arrays</strong>. That means you may not put other things into the Redux state - no class instances, built-in JS types like <code>Map</code> / <code>Set</code> <code>Promise</code> / <code>Date</code>, functions, or anything else that is not plain JS data.</p>
<p><strong>The root Redux state value is almost always a plain JS object</strong>, with other data nested inside of it.</p>
<p>Based on this information, we should now be able to describe the kinds of values we need to have inside our Redux state:</p>
<ul>
<li>First, we need an array of todo item objects. Each item should have these fields:
<ul>
<li><code>id</code>: a unique number</li>
<li><code>text</code>: the text the user typed in</li>
<li><code>completed</code>: a boolean flag</li>
<li><code>color</code>: An optional color category</li>
</ul></li>
<li>Then, we need to describe our filtering options. We need to have:
<ul>
<li>The current “completed” filter value</li>
<li>An array of the currently selected color categories</li>
</ul></li>
</ul>
<p>So, here’s what an example of our app’s state might look like:</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb218-1" title="1"><span class="kw">const</span> todoAppState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb218-2" title="2">  <span class="dt">todos</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb218-3" title="3">    <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Learn React&quot;</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb218-4" title="4">    <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Learn Redux&quot;</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="dt">color</span><span class="op">:</span> <span class="st">&quot;purple&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb218-5" title="5">    <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Build something fun!&quot;</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span> <span class="dt">color</span><span class="op">:</span> <span class="st">&quot;blue&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb218-6" title="6">  ]<span class="op">,</span></a>
<a class="sourceLine" id="cb218-7" title="7">  <span class="dt">filters</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb218-8" title="8">    <span class="dt">status</span><span class="op">:</span> <span class="st">&quot;Active&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb218-9" title="9">    <span class="dt">colors</span><span class="op">:</span> [<span class="st">&quot;red&quot;</span><span class="op">,</span> <span class="st">&quot;blue&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb218-10" title="10">  <span class="op">},</span></a>
<a class="sourceLine" id="cb218-11" title="11"><span class="op">};</span></a></code></pre></div>
<p>It’s important to note that <strong>it’s okay to have other state values outside of Redux!</strong>. This example is small enough so far that we actually do have all our state in the Redux store, but as we’ll see later, some data really doesn’t need to be kept in Redux (like “is this dropdown open?” or “current value of a form input”).</p>
<h3 id="designing-actions">Designing Actions</h3>
<p><strong>Actions</strong> are plain JavaScript objects that have a <code>type</code> field. As mentioned earlier, <strong>you can think of an action as an event that describes something that happened in the application</strong>.</p>
<p>In the same way that we designed the state structure based on the app’s requirements, we should also be able to come up with a list of some of the actions that describe what’s happening:</p>
<ul>
<li>Add a new todo entry based on the text the user entered</li>
<li>Toggle the completed status of a todo</li>
<li>Select a color category for a todo</li>
<li>Delete a todo</li>
<li>Mark all todos as completed</li>
<li>Clear all completed todos</li>
<li>Choose a different “completed” filter value</li>
<li>Add a new color filter</li>
<li>Remove a color filter</li>
</ul>
<p>We normally put any extra data needed to describe what’s happening into the <code>action.payload</code> field. This could be a number, a string, or an object with multiple fields inside.</p>
<p>The Redux store doesn’t care what the actual text of the <code>action.type</code> field is. However, your own code will look at <code>action.type</code> to see if an update is needed. Also, you will frequently look at action type strings in the Redux DevTools Extension while debugging to see what’s going on in your app. So, try to choose action types that are readable and clearly describe what’s happening - it’ll be much easier to understand things when you look at them later!</p>
<p>Based on that list of things that can happen, we can create a list of actions that our application will use:</p>
<ul>
<li><code>{type: 'todos/todoAdded', payload: todoText}</code></li>
<li><code>{type: 'todos/todoToggled', payload: todoId}</code></li>
<li><code>{type: 'todos/colorSelected, payload: {todoId, color}}</code></li>
<li><code>{type: 'todos/todoDeleted', payload: todoId}</code></li>
<li><code>{type: 'todos/allCompleted'}</code></li>
<li><code>{type: 'todos/completedCleared'}</code></li>
<li><code>{type: 'filters/statusFilterChanged', payload: filterValue}</code></li>
<li><code>{type: 'filters/colorFilterChanged', payload: {color, changeType}}</code></li>
</ul>
<p>In this case, the actions primarily have a single extra piece of data apiece, so we can put that directly in the <code>action.payload</code> field. We could have split the color filter behavior into two actions, one for “added” and one for “removed”, but in this case we’ll do it as one action with an extra field inside specifically to show that we can have objects as an action payload.</p>
<p>Like the state data, <strong>actions should contain the smallest amount of information needed to describe what happened</strong>.</p>
<h2 id="writing-reducers">Writing Reducers</h2>
<p>Now that we know what our state structure and our actions look like, it’s time to write our first reducer.</p>
<p><strong>Reducers</strong> are functions that take the current <code>state</code> and an <code>action</code> as arguments, and return a new <code>state</code> result. In other words, <strong><code>(state, action) =&gt; newState</code></strong>.</p>
<h3 id="creating-the-root-reducer">Creating the Root Reducer</h3>
<p><strong>A Redux app really only has one reducer function: the “root reducer” function</strong> that you will pass to <code>createStore</code> later on. That one root reducer function is responsible for handling <em>all</em> of the actions that are dispatched, and calculating what the <em>entire</em> new state result should be every time.</p>
<p>Let’s start by creating a <code>reducer.js</code> file in the <code>src</code> folder, alongside <code>index.js</code> and <code>App.js</code>.</p>
<p>Every reducer needs some initial state, so we’ll add some fake todo entries to get us started. Then, we can write an outline for the logic inside the reducer function:</p>
<p>```js title=“src/reducer.js” const initialState = { todos: [ { id: 0, text: “Learn React”, completed: true }, { id: 1, text: “Learn Redux”, completed: false, color: “purple” }, { id: 2, text: “Build something fun!”, completed: false, color: “blue” }, ], filters: { status: “All”, colors: [], }, };</p>
<p>// Use the initialState as a default value export default function appReducer(state = initialState, action) { // The reducer normally looks at the action type field to decide what happens switch (action.type) { // Do something here based on the different types of actions default: // If this reducer doesn’t recognize the action type, or doesn’t // care about this specific action, return the existing state unchanged return state; } } ```</p>
<p>A reducer may be called with <code>undefined</code> as the state value when the application is being initialized. If that happens, we need to provide an initial state value so the rest of the reducer code has something to work with. <strong>Reducers normally use ES6 default argument syntax to provide initial state: <code>(state = initialState, action)</code></strong>.</p>
<p>Next, let’s add the logic to handle the <code>'todos/todoAdded'</code> action.</p>
<p>We know we need to check to see the current action’s type matches that specific string. Then, we need to return a new object containing <em>all</em> of the state, even for the fields that didn’t change.</p>
<p>```js title=“src/reducer.js” function nextTodoId(todos) { const maxId = todos.reduce((maxId, todo) =&gt; Math.max(todo.id, maxId), -1); return maxId + 1; }</p>
<p>// Use the initialState as a default value export default function appReducer(state = initialState, action) { // The reducer normally looks at the action type field to decide what happens switch (action.type) { // Do something here based on the different types of actions // highlight-start case “todos/todoAdded”: { // We need to return a new state object return { // that has all the existing state data …state, // but has a new array for the <code>todos</code> field todos: [ // with all of the old todos …state.todos, // and the new todo object { // Use an auto-incrementing numeric ID for this example id: nextTodoId(state.todos), text: action.payload, completed: false, }, ], }; } // highlight-end default: // If this reducer doesn’t recognize the action type, or doesn’t // care about this specific action, return the existing state unchanged return state; } } ```</p>
<p>That’s… an awful lot of work to add one todo item to the state. Why is all this extra work necessary?</p>
<h3 id="rules-of-reducers">Rules of Reducers</h3>
<p>We said earlier that <strong>reducers must <em>always</em> follow some special rules</strong>:</p>
<ul>
<li>They should only calculate the new state value based on the <code>state</code> and <code>action</code> arguments</li>
<li>They are not allowed to modify the existing <code>state</code>. Instead, they must make <em>immutable updates</em>, by copying the existing <code>state</code> and making changes to the copied values.</li>
<li>They must not do any asynchronous logic or other “side effects”</li>
</ul>
<div class="tip">
<p><strong>A “side effect” is any change to state or behavior that can be seen outside of returning a value from a function</strong>. Some common kinds of side effects are things like:</p>
<ul>
<li>Logging a value to the console</li>
<li>Saving a file</li>
<li>Setting an async timer</li>
<li>Making an AJAX HTTP request</li>
<li>Modifying some state that exists outside of a function, or mutating arguments to a function</li>
<li>Generating random numbers or unique random IDs (such as <code>Math.random()</code> or <code>Date.now()</code>)</li>
</ul>
</div>
<p>Any function that follows these rules is also known as a <strong>“pure” function</strong>, even if it’s not specifically written as a reducer function.</p>
<p>But why are these rules important? There’s a few different reasons:</p>
<ul>
<li>One of the goals of Redux is to make your code predictable. When a function’s output is only calculated from the input arguments, it’s easier to understand how that code works, and to test it.</li>
<li>On the other hand, if a function depends on variables outside itself, or behaves randomly, you never know what will happen when you run it.</li>
<li>If a function modifies other values, including its arguments, that can change the way the application works unexpectedly. This can be a common source of bugs, such as “I updated my state, but now my UI isn’t updating when it should!”</li>
<li>Some of the Redux DevTools capabilities depend on having your reducers follow these rules correctly</li>
</ul>
<p>The rule about “immutable updates” is particularly important, and worth talking about further.</p>
<h3 id="reducers-and-immutable-updates">Reducers and Immutable Updates</h3>
<p>Earlier, we talked about “mutation” (modifying existing object/array values) and “immutability” (treating values as something that cannot be changed).</p>
<div class="warning">
<p>In Redux, <strong>our reducers are <em>never</em> allowed to mutate the original / current state values!</strong></p>
<div class="sourceCode" id="cb219"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb219-1" title="1"><span class="co">// ❌ Illegal - by default, this will mutate the state!</span></a>
<a class="sourceLine" id="cb219-2" title="2"><span class="va">state</span>.<span class="at">value</span> <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></a></code></pre></div>
</div>
<p>There are several reasons why you must not mutate state in Redux:</p>
<ul>
<li>It causes bugs, such as the UI not updating properly to show the latest values</li>
<li>It makes it harder to understand why and how the state has been updated</li>
<li>It makes it harder to write tests</li>
<li>It breaks the ability to use “time-travel debugging” correctly</li>
<li>It goes against the intended spirit and usage patterns for Redux</li>
</ul>
<p>So if we can’t change the originals, how do we return an updated state?</p>
<div class="tip">
<p><strong>Reducers can only make <em>copies</em> of the original values, and then they can mutate the copies.</strong></p>
<div class="sourceCode" id="cb220"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb220-1" title="1"><span class="co">// ✅ This is safe, because we made a copy</span></a>
<a class="sourceLine" id="cb220-2" title="2"><span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb220-3" title="3">  ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb220-4" title="4">  <span class="dt">value</span><span class="op">:</span> <span class="dv">123</span><span class="op">,</span></a>
<a class="sourceLine" id="cb220-5" title="5"><span class="op">};</span></a></code></pre></div>
</div>
<p>We already saw that we can <a href="./part-2-concepts-data-flow.md#immutability">write immutable updates by hand</a>, by using JavaScript’s array / object spread operators and other functions that return copies of the original values.</p>
<p>This becomes harder when the data is nested. <strong>A critical rule of immutable updates is that you must make a copy of <em>every</em> level of nesting that needs to be updated.</strong></p>
<p>However, if you’re thinking that “writing immutable updates by hand this way looks hard to remember and do correctly”… yeah, you’re right! :)</p>
<p>Writing immutable update logic by hand <em>is</em> hard, and <strong>accidentally mutating state in reducers is the single most common mistake Redux users make</strong>.</p>
<div class="tip">
<p><strong>In real-world applications, you won’t have to write these complex nested immutable updates by hand</strong>. In <a href="./part-8-modern-redux.md">Part 8: Modern Redux with Redux Toolkit</a>, you’ll learn how to use Redux Toolkit to simplify writing immutable update logic in reducers.</p>
</div>
<h3 id="handling-additional-actions">Handling Additional Actions</h3>
<p>With that in mind, let’s add the reducer logic for a couple more cases. First, toggling a todo’s <code>completed</code> field based on its ID:</p>
<p>```js title=“src/reducer.js” export default function appReducer(state = initialState, action) { switch (action.type) { case “todos/todoAdded”: { return { …state, todos: [ …state.todos, { id: nextTodoId(state.todos), text: action.payload, completed: false, }, ], }; } // highlight-start case “todos/todoToggled”: { return { // Again copy the entire state object …state, // This time, we need to make a copy of the old todos array todos: state.todos.map((todo) =&gt; { // If this isn’t the todo item we’re looking for, leave it alone if (todo.id !== action.payload) { return todo; }</p>
<pre><code>      // We&#39;ve found the todo that has to change. Return a copy:
      return {
        ...todo,
        // Flip the completed flag
        completed: !todo.completed,
      };
    }),
  };
}
// highlight-end
default:
  return state;</code></pre>
<p>} } ```</p>
<p>And since we’ve been focusing on the todos state, let’s add a case to handle the “visibility selection changed” action as well:</p>
<p>```js title=“src/reducer.js” export default function appReducer(state = initialState, action) { switch (action.type) { case “todos/todoAdded”: { return { …state, todos: [ …state.todos, { id: nextTodoId(state.todos), text: action.payload, completed: false, }, ], }; } case “todos/todoToggled”: { return { …state, todos: state.todos.map((todo) =&gt; { if (todo.id !== action.payload) { return todo; }</p>
<pre><code>      return {
        ...todo,
        completed: !todo.completed,
      };
    }),
  };
}
// highlight-start
case &quot;filters/statusFilterChanged&quot;: {
  return {
    // Copy the whole state
    ...state,
    // Overwrite the filters value
    filters: {
      // copy the other filter fields
      ...state.filters,
      // And replace the status field with the new value
      status: action.payload,
    },
  };
}
// highlight-end
default:
  return state;</code></pre>
<p>} } ```</p>
<p>We’ve only handled 3 actions, but this is already getting a bit long. If we try to handle every action in this one reducer function, it’s going to be hard to read it all.</p>
<p>That’s why <strong>reducers are typically split into multiple smaller reducer functions</strong> - to make it easier to understand and maintain the reducer logic.</p>
<h2 id="splitting-reducers">Splitting Reducers</h2>
<p>As part of this, <strong>Redux reducers are typically split apart based on the section of the Redux state that they update</strong>. Our todo app state currently has two top-level sections: <code>state.todos</code> and <code>state.filters</code>. So, we can split the large root reducer function into two smaller reducers - a <code>todosReducer</code> and a <code>filtersReducer</code>.</p>
<p>So, where should these split-up reducer functions live?</p>
<p><strong>We recommend organizing your Redux app folders and files based on “features”</strong> - code that relates to a specific concept or area of your application. <strong>The Redux code for a particular feature is usually written as a single file, known as a “slice” file</strong>, which contains all the reducer logic and all of the action-related code for that part of your app state.</p>
<p>Because of that, <strong>the reducer for a specific section of the Redux app state is called a “slice reducer”</strong>. Typically, some of the action objects will be closely related to a specific slice reducer, and so the action type strings should start with the name of that feature (like <code>'todos'</code>) and describe the event that happened (like <code>'todoAdded'</code>), joined together into one string (<code>'todos/todoAdded'</code>).</p>
<p>In our project, create a new <code>features</code> folder, and then a <code>todos</code> folder inside that. Create a new file named <code>todosSlice.js</code>, and let’s cut and paste the todo-related initial state over into this file:</p>
<p>```js title=“src/features/todos/todosSlice.js” const initialState = [ { id: 0, text: “Learn React”, completed: true }, { id: 1, text: “Learn Redux”, completed: false, color: “purple” }, { id: 2, text: “Build something fun!”, completed: false, color: “blue” },];</p>
<p>function nextTodoId(todos) { const maxId = todos.reduce((maxId, todo) =&gt; Math.max(todo.id, maxId), -1); return maxId + 1; }</p>
<p>export default function todosReducer(state = initialState, action) { switch (action.type) { default: return state; } } ```</p>
<p>Now we can copy over the logic for updating the todos. However, there’s an important difference here. <strong>This file only has to update the todos-related state - it’s not nested any more!</strong> This is another reason why we split up reducers. Since the todos state is an array by itself, we don’t have to copy the outer root state object in here. That makes this reducer easier to read.</p>
<p>This is called <strong>reducer composition</strong>, and it’s the fundamental pattern of building Redux apps.</p>
<p>Here’s what the updated reducer looks like after we handle those actions:</p>
<p>```js title=“src/features/todos/todosSlice.js” export default function todosReducer(state = initialState, action) { switch (action.type) { // highlight-start case “todos/todoAdded”: { // Can return just the new todos array - no extra object around it return [ …state, { id: nextTodoId(state), text: action.payload, completed: false, }, ]; } case “todos/todoToggled”: { return state.map((todo) =&gt; { if (todo.id !== action.payload) { return todo; }</p>
<pre><code>    return {
      ...todo,
      completed: !todo.completed,
    };
  });
}
//highlight-end
default:
  return state;</code></pre>
<p>} } ```</p>
<p>That’s a bit shorter and easier to read.</p>
<p>Now we can do the same thing for the visibility logic. Create <code>src/features/filters/filtersSlice.js</code>, and let’s move all the filter-related code over there:</p>
<p>```js title=“src/features/filters/filtersSlice.js” const initialState = { status: “All”, colors: [], };</p>
<p>export default function filtersReducer(state = initialState, action) { switch (action.type) { // highlight-start case “filters/statusFilterChanged”: { return { // Again, one less level of nesting to copy …state, status: action.payload, }; } // highlight-end default: return state; } } ```</p>
<p>We still have to copy the object containing the filters state, but since there’s less nesting, it’s easier to read what’s happening.</p>
<div class="info">
<p>To keep this page shorter, we’ll skip showing how to write the reducer update logic for the other actions.</p>
<p><strong>Try writing the updates for those yourself</strong>, based on <a href="#defining-requirements">the requirements described above</a>.</p>
<p>If you get stuck, see <a href="#what-youve-learned">the CodeSandbox at the end of this page</a> for the complete implementation of these reducers.</p>
</div>
<h2 id="combining-reducers">Combining Reducers</h2>
<p>We now have two separate slice files, each with its own slice reducer function. But, we said earlier that the Redux store needs <em>one</em> root reducer function when we create it. So, how can we go back to having a root reducer without putting all the code in one big function?</p>
<p>Since reducers are normal JS functions, we can import the slice reducers back into <code>reducer.js</code>, and write a new root reducer whose only job is to call the other two functions.</p>
<p>```js title=“src/reducer.js” import todosReducer from “./features/todos/todosSlice”; import filtersReducer from “./features/filters/filtersSlice”;</p>
<p>export default function rootReducer(state = {}, action) { // always return a new object for the root state return { // the value of <code>state.todos</code> is whatever the todos reducer returns todos: todosReducer(state.todos, action), // For both reducers, we only pass in their slice of the state filters: filtersReducer(state.filters, action), }; } ```</p>
<p><strong>Note that each of these reducers is managing its own part of the global state. The state parameter is different for every reducer, and corresponds to the part of the state it manages.</strong></p>
<p>This allows us to split up our logic based on features and slices of state, to keep things maintainable.</p>
<h3 id="combinereducers"><code>combineReducers</code></h3>
<p>We can see that the new root reducer is doing the same thing for each slice: calling the slice reducer, passing in the slice of the state owned by that reducer, and assigning the result back to the root state object. If we were to add more slices, the pattern would repeat.</p>
<p>The Redux core library includes a utility called <a href="../../api/combineReducers.md"><code>combineReducers</code></a>, which does this same boilerplate step for us. We can replace our hand-written <code>rootReducer</code> with a shorter one generated by <code>combineReducers</code>.</p>
<p><strong>Now that we need <code>combineReducers</code>, it’s time to actually install the Redux core library</strong>:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb224-1" title="1">npm install redux</a></code></pre></div>
<p>Once that’s done, we can import <code>combineReducers</code> and use it:</p>
<p>```js title=“src/reducer.js” // highlight-next-line import { combineReducers } from “redux”;</p>
<p>import todosReducer from “./features/todos/todosSlice”; import filtersReducer from “./features/filters/filtersSlice”;</p>
<p>const rootReducer = combineReducers({ // Define a top-level state field named <code>todos</code>, handled by <code>todosReducer</code> todos: todosReducer, filters: filtersReducer, });</p>
<p>export default rootReducer; ```</p>
<p><code>combineReducers</code> accepts an object where the key names will become the keys in your root state object, and the values are the slice reducer functions that know how to update those slices of the Redux state.</p>
<p><strong>Remember, the key names you give to <code>combineReducers</code> decides what the key names of your state object will be!</strong></p>
<h2 id="what-youve-learned-2">What You’ve Learned</h2>
<p><strong>State, Actions, and Reducers are the building blocks of Redux</strong>. Every Redux app has state values, creates actions to describe what happened, and uses reducer functions to calculate new state values based on the previous state and an action.</p>
<p>Here’s the contents of our app so far:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-1-combinedReducers/?fontsize=14&amp;hidenavigation=1&amp;module=%2Fsrc%2Freducer.js&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts">
</iframe>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux apps use plain JS objects, arrays, and primitives as the state values</strong>
<ul>
<li>The root state value should be a plain JS object</li>
<li>The state should contain the smallest amount of data needed to make the app work</li>
<li>Classes, Promises, functions, and other non-plain values should <em>not</em> go in the Redux state</li>
<li>Reducers must not create random values like <code>Math.random()</code> or <code>Date.now()</code></li>
<li>It’s okay to have other state values that are not in the Redux store (like local component state) side-by side with Redux</li>
</ul></li>
<li><strong>Actions are plain objects with a <code>type</code> field that describe what happened</strong>
<ul>
<li>The <code>type</code> field should be a readable string, and is usually written as <code>'feature/eventName'</code></li>
<li>Actions may contain other values, which are typically stored in the <code>action.payload</code> field</li>
<li>Actions should have the smallest amount of data needed to describe what happened</li>
</ul></li>
<li><strong>Reducers are functions that look like <code>(state, action) =&gt; newState</code></strong>
<ul>
<li>Reducers must always follow special rules:
<ul>
<li>Only calculate the new state based on the <code>state</code> and <code>action</code> arguments</li>
<li>Never mutate the existing <code>state</code> - always return a copy</li>
<li>No “side effects” like AJAX calls or async logic</li>
</ul></li>
</ul></li>
<li><strong>Reducers should be split up to make them easier to read</strong>
<ul>
<li>Reducers are usually split based on top-level state keys or “slices” of state</li>
<li>Reducers are usually written in “slice” files, organized into “feature” folders</li>
<li>Reducers can be combined together with the Redux <code>combineReducers</code> function</li>
<li>The key names given to <code>combineReducers</code> define the top-level state object keys</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-2">What’s Next?</h2>
<p>We now have some reducer logic that will update our state, but those reducers won’t do anything by themselves. They need to be put inside a Redux store, which can call the reducer code with actions when something has happened.</p>
<p>In <a href="./part-4-store.md">Part 4: Store</a>, we’ll see how to create a Redux store and run our reducer logic.</p>
<hr />
<p>id: part-4-store title: ‘Redux Fundamentals, Part 4: Store’ sidebar_label: ‘Store’ description: ‘The official Redux Fundamentals tutorial: learn how to create and use a Redux store’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-4-store">Redux Fundamentals, Part 4: Store</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to create a Redux store</li>
<li>How to use the store to update state and listen for updates</li>
<li>How to configure the store to extend its capabilities</li>
<li>How to set up the Redux DevTools Extension to debug your app</li>
</ul>
<p>:::</p>
<h2 id="introduction-4">Introduction</h2>
<p>In <a href="./part-3-state-actions-reducers.md">Part 3: State, Actions, and Reducers</a>, we started writing our example todo app. We listed business requirements, defined the <strong>state</strong> structure we need to make the app work, and created a series of action types to describe “what happened” and match the kinds of events that can happen as a user interacts with our app. We also wrote <strong>reducer</strong> functions that can handle updating our <code>state.todos</code> and <code>state.filters</code> sections, and saw how we can use the Redux <code>combineReducers</code> function to create a “root reducer” based on the different “slice reducers” for each feature in our app.</p>
<p>Now, it’s time to pull those pieces together, with the central piece of a Redux app: the <strong>store</strong>.</p>
<h2 id="redux-store">Redux Store</h2>
<p>The Redux <strong>store</strong> brings together the state, actions, and reducers that make up your app. The store has several responsibilities:</p>
<ul>
<li>Holds the current application state inside</li>
<li>Allows access to the current state via <a href="../../api/Store.md#getState"><code>store.getState()</code></a>;</li>
<li>Allows state to be updated via <a href="../../api/Store.md#dispatch"><code>store.dispatch(action)</code></a>;</li>
<li>Registers listener callbacks via <a href="../../api/Store.md#subscribe"><code>store.subscribe(listener)</code></a>;</li>
<li>Handles unregistering of listeners via the <code>unsubscribe</code> function returned by <a href="../../api/Store.md#subscribe"><code>store.subscribe(listener)</code></a>.</li>
</ul>
<p>It’s important to note that <strong>you’ll only have a single store in a Redux application</strong>. When you want to split your data handling logic, you’ll use <a href="./part-3-state-actions-reducers.md#splitting-reducers">reducer composition</a> and create multiple reducers that can be combined together, instead of creating separate stores.</p>
<h3 id="creating-a-store">Creating a Store</h3>
<p><strong>Every Redux store has a single root reducer function</strong>. In the previous section, we <a href="./part-3-state-actions-reducers.md#combinereducers">created a root reducer function using <code>combineReducers</code></a>. That root reducer is currently defined in <code>src/reducer.js</code> in our example app. Let’s import that root reducer and create our first store.</p>
<p>The Redux core library has <a href="../../api/createStore.md"><strong>a <code>createStore</code> API</strong></a> that will create the store. Add a new file called <code>store.js</code>, and import <code>createStore</code> and the root reducer. Then, call <code>createStore</code> and pass in the root reducer:</p>
<p>```js title=“src/store.js” import { createStore } from “redux”; import rootReducer from “./reducer”;</p>
<p>// highlight-next-line const store = createStore(rootReducer);</p>
<p>export default store; ```</p>
<h3 id="loading-initial-state">Loading Initial State</h3>
<p><code>createStore</code> can also accept a <code>preloadedState</code> value as its second argument. You could use this to add initial data when the store is created, such as values that were included in an HTML page sent from the server, or persisted in <code>localStorage</code> and read back when the user visits the page again, like this:</p>
<p>```js title=“storeStatePersistenceExample.js” import { createStore } from “redux”; import rootReducer from “./reducer”;</p>
<p>// highlight-start let preloadedState; const persistedTodosString = localStorage.getItem(“todos”);</p>
<p>if (persistedTodosString) { preloadedState = { todos: JSON.parse(persistedTodosString), }; }</p>
<p>const store = createStore(rootReducer, preloadedState); // highlight-end ```</p>
<h2 id="dispatching-actions-1">Dispatching Actions</h2>
<p>Now that we have created a store, let’s verify our program works! Even without any UI, we can already test the update logic.</p>
<div class="tip">
<p>Before you run this code, try going back to <code>src/features/todos/todosSlice.js</code>, and remove all the example todo objects from the <code>initialState</code> so that it’s an empty array. That will make the output from this example a bit easier to read.</p>
</div>
<p>```js title=“src/index.js” // Omit existing React imports</p>
<p>import store from “./store”;</p>
<p>// Log the initial state // highlight-next-line console.log(“Initial state:”, store.getState()); // {todos: [….], filters: {status, colors}}</p>
<p>// Every time the state changes, log it // Note that subscribe() returns a function for unregistering the listener // highlight-start const unsubscribe = store.subscribe(() =&gt; console.log(“State after dispatch:”, store.getState()) ); // highlight-end</p>
<p>// Now, dispatch some actions</p>
<p>// highlight-next-line store.dispatch({ type: “todos/todoAdded”, payload: “Learn about actions” }); store.dispatch({ type: “todos/todoAdded”, payload: “Learn about reducers” }); store.dispatch({ type: “todos/todoAdded”, payload: “Learn about stores” });</p>
<p>store.dispatch({ type: “todos/todoToggled”, payload: 0 }); store.dispatch({ type: “todos/todoToggled”, payload: 1 });</p>
<p>store.dispatch({ type: “filters/statusFilterChanged”, payload: “Active” });</p>
<p>store.dispatch({ type: “filters/colorFilterChanged”, payload: { color: “red”, changeType: “added” }, });</p>
<p>// Stop listening to state updates // highlight-next-line unsubscribe();</p>
<p>// Dispatch one more action to see what happens</p>
<p>store.dispatch({ type: “todos/todoAdded”, payload: “Try creating a store” });</p>
<p>// Omit existing React rendering logic ```</p>
<p>Remember, every time we call <code>store.dispatch(action)</code>:</p>
<ul>
<li>The store calls <code>rootReducer(state, action)</code>
<ul>
<li>That root reducer may call other slice reducers inside of itself, like <code>todosReducer(state.todos, action)</code></li>
</ul></li>
<li>The store saves the <em>new</em> state value inside</li>
<li>The store calls all the listener subscription callbacks</li>
<li>If a listener has access to the <code>store</code>, it can now call <code>store.getState()</code> to read the latest state value</li>
</ul>
<p>If we look at the console log output from that example, you can see how the Redux state changes as each action was dispatched:</p>
<figure>
<img src="/img/tutorials/fundamentals/initial-state-updates.png" alt="Logged Redux state after dispatching actions" /><figcaption>Logged Redux state after dispatching actions</figcaption>
</figure>
<p>Notice that our app did <em>not</em> log anything from the last action. That’s because we removed the listener callback when we called <code>unsubscribe()</code>, so nothing else ran after the action was dispatched.</p>
<p>We specified the behavior of our app before we even started writing the UI. That helps give us confidence that the app will work as intended.</p>
<div class="info">
<p>If you want, you can now try writing tests for your reducers. Because they’re <a href="../../understanding/thinking-in-redux/ThreePrinciples.md#changes-are-made-with-pure-functions">pure functions</a>, it should be straightforward to test them. Call them with an example <code>state</code> and <code>action</code>, take the result, and check to see if it matches what you expect:</p>
<p>```js title=“todosSlice.spec.js” import todosReducer from “./todosSlice”;</p>
<p>test(“Toggles a todo based on id”, () =&gt; { const initialState = [{ id: 0, text: “Test text”, completed: false }];</p>
<p>const action = { type: “todos/todoToggled”, payload: 0 }; const result = todosReducer(initialState, action); expect(result[0].completed).toBe(true); }); ```</p>
</div>
<h2 id="inside-a-redux-store">Inside a Redux Store</h2>
<p>It might be helpful to take a peek inside a Redux store to see how it works. Here’s a miniature example of a working Redux store, in about 25 lines of code:</p>
<p>```js title=“miniReduxStoreExample.js” function createStore(reducer, preloadedState) { let state = preloadedState; const listeners = [];</p>
<p>function getState() { return state; }</p>
<p>function subscribe(listener) { listeners.push(listener); return function unsubscribe() { const index = listeners.indexOf(listener); listeners.splice(index, 1); }; }</p>
<p>function dispatch(action) { state = reducer(state, action); listeners.forEach((listener) =&gt; listener()); }</p>
<p>dispatch({ type: “@<span class="citation" data-cites="redux/INIT">@redux/INIT</span>” });</p>
<p>return { dispatch, subscribe, getState }; } ```</p>
<p>This small version of a Redux store works well enough that you could use it to replace the actual Redux <code>createStore</code> function you’ve been using in your app so far. (Try it and see for yourself!) <a href="https://github.com/reduxjs/redux/blob/v4.0.5/src/createStore.js">The actual Redux store implementation is longer and a bit more complicated</a>, but most of that is comments, warning messages, and handling some edge cases.</p>
<p>As you can see, the actual logic here is fairly short:</p>
<ul>
<li>The store has the current <code>state</code> value and <code>reducer</code> function inside of itself</li>
<li><code>getState</code> returns the current state value</li>
<li><code>subscribe</code> keeps an array of listener callbacks and returns a function to remove the new callback</li>
<li><code>dispatch</code> calls the reducer, saves the state, and runs the listeners</li>
<li>The store dispatches one action on startup to initialize the reducers with their state</li>
<li>The store API is an object with <code>{dispatch, subscribe, getState}</code> inside</li>
</ul>
<p>To emphasize one of those in particular: notice that <code>getState</code> just returns whatever the current <code>state</code> value is. That means that <strong>by default, nothing prevents you from accidentally mutating the current state value!</strong> This code will run without any errors, but it’s incorrect:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb225-1" title="1"><span class="kw">const</span> state <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb225-2" title="2"><span class="co">// ❌ Don&#39;t do this - it mutates the current state!</span></a>
<a class="sourceLine" id="cb225-3" title="3"><span class="va">state</span>.<span class="va">filters</span>.<span class="at">status</span> <span class="op">=</span> <span class="st">&quot;Active&quot;</span><span class="op">;</span></a></code></pre></div>
<p>In other words:</p>
<ul>
<li>The Redux store doesn’t make an extra copy of the <code>state</code> value when you call <code>getState()</code>. It’s exactly the same reference that was returned from the root reducer function</li>
<li>The Redux store doesn’t do anything else to prevent accidental mutations. It <em>is</em> possible to mutate the state, either inside a reducer or outside the store, and you must always be careful to avoid mutations.</li>
</ul>
<p>One common cause of accidental mutations is sorting arrays. <a href="https://doesitmutate.xyz/sort/"><strong>Calling <code>array.sort()</code> actually mutates the existing array</strong></a>. If we called <code>const sortedTodos = state.todos.sort()</code>, we’d end up mutating the real store state unintentionally.</p>
<div class="tip">
<p>In <a href="./part-8-modern-redux.md">Part 8: Modern Redux</a>, we’ll see how Redux Toolkit helps avoid mutations in reducers, and detects and warns about accidental mutations outside of reducers.</p>
</div>
<h2 id="configuring-the-store">Configuring the Store</h2>
<p>We’ve already seen that we can pass <code>rootReducer</code> and <code>preloadedState</code> arguments to <code>createStore</code>. However, <code>createStore</code> can also take one more argument, which is used to customize the store’s abilities and give it new powers.</p>
<p>Redux stores are customized using something called a <strong>store enhancer</strong>. A store enhancer is like a special version of <code>createStore</code> that adds another layer wrapping around the original Redux store. An enhanced store can then change how the store behaves, by supplying its own versions of the store’s <code>dispatch</code>, <code>getState</code>, and <code>subscribe</code> functions instead of the originals.</p>
<p>For this tutorial, we won’t go into details about how store enhancers actually work - we’ll focus on how to use them.</p>
<h3 id="creating-a-store-with-enhancers">Creating a Store with Enhancers</h3>
<p>Our project has two small example store enhancers available, in the <code>src/exampleAddons/enhancers.js</code> file:</p>
<ul>
<li><code>sayHiOnDispatch</code>: an enhancer that always logs <code>'Hi'!</code> to the console every time an action is dispatched</li>
<li><code>includeMeaningOfLife</code>: an enhancer that always adds the field <code>meaningOfLife: 42</code> to the value returned from <code>getState()</code></li>
</ul>
<p>Let’s start by using <code>sayHiOnDispatch</code>. First, we’ll import it, and pass it to <code>createStore</code>:</p>
<p>```js title=“src/store.js” import { createStore } from “redux”; import rootReducer from “./reducer”; import { sayHiOnDispatch } from “./exampleAddons/enhancers”;</p>
<p>const store = createStore(rootReducer, undefined, sayHiOnDispatch);</p>
<p>export default store; ```</p>
<p>We don’t have a <code>preloadedState</code> value here, so we’ll pass <code>undefined</code> as the second argument instead.</p>
<p>Next, let’s try dispatching an action:</p>
<p>```js title=“src/index.js” import store from “./store”;</p>
<p>// highlight-start console.log(“Dispatching action”); store.dispatch({ type: “todos/todoAdded”, payload: “Learn about actions” }); console.log(“Dispatch complete”); // highlight-end ```</p>
<p>Now look at the console. You should see <code>'Hi!'</code> logged there, in between the other two log statements:</p>
<figure>
<img src="/img/tutorials/fundamentals/sayhi-enhancer-logging.png" alt="sayHi store enhancer logging" /><figcaption>sayHi store enhancer logging</figcaption>
</figure>
<p>The <code>sayHiOnDispatch</code> enhancer wrapped the original <code>store.dispatch</code> function with its own specialized version of <code>dispatch</code>. When we called <code>store.dispatch()</code>, we were actually calling the wrapper function from <code>sayHiOnDispatch</code>, which called the original and then printed ‘Hi’.</p>
<p>Now, let’s try adding a second enhancer. We can import <code>includeMeaningOfLife</code> from that same file… but we have a problem. <strong><code>createStore</code> only accepts one enhancer as its third argument!</strong> How can we pass <em>two</em> enhancers at the same time?</p>
<p>What we really need is some way to merge both the <code>sayHiOnDispatch</code> enhancer and the <code>includeMeaningOfLife</code> enhancer into a single combined enhancer, and then pass that instead.</p>
<p>Fortunately, <strong>the Redux core includes <a href="../../api/compose.md">a <code>compose</code> function</a> that can be used to merge multiple enhancers together</strong>. Let’s use that here:</p>
<p>```js title=“src/store.js” // highlight-next-line import { createStore, compose } from “redux”; import rootReducer from “./reducer”; import { sayHiOnDispatch, includeMeaningOfLife, } from “./exampleAddons/enhancers”;</p>
<p>// highlight-next-line const composedEnhancer = compose(sayHiOnDispatch, includeMeaningOfLife);</p>
<p>// highlight-next-line const store = createStore(rootReducer, undefined, composedEnhancer);</p>
<p>export default store; ```</p>
<p>Now we can see what happens if we use the store:</p>
<p>```js title=“src/index.js” import store from “./store”;</p>
<p>store.dispatch({ type: “todos/todoAdded”, payload: “Learn about actions” }); // log: ‘Hi!’</p>
<p>console.log(“State after dispatch:”, store.getState()); // log: {todos: […], filters: {status, colors}, meaningOfLife: 42} ```</p>
<p>And the logged output looks like this:</p>
<figure>
<img src="/img/tutorials/fundamentals/meaningOfLife-enhancer-logging.png" alt="meaningOfLife store enhancer logging" /><figcaption>meaningOfLife store enhancer logging</figcaption>
</figure>
<p>So, we can see that both enhancers are modifying the behavior of the store at the same time. <code>sayHiOnDispatch</code> has changed how <code>dispatch</code> works, and <code>includeMeaningOfLife</code> has changed how <code>getState</code> works.</p>
<p>Store enhancers are a very powerful way to modify the store, and almost all Redux apps will include at least one enhancer when setting up the store.</p>
<div class="tip">
<p>If you don’t have any <code>preloadedState</code> to pass in, you can pass the <code>enhancer</code> as the second argument instead:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb226-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> storeEnhancer)<span class="op">;</span></a></code></pre></div>
</div>
<h2 id="middleware-3">Middleware</h2>
<p>Enhancers are powerful because they can override or replace any of the store’s methods: <code>dispatch</code>, <code>getState</code>, and <code>subscribe</code>.</p>
<p>But, much of the time, we only need to customize how <code>dispatch</code> behaves. It would be nice if there was a way to add some customized behavior when <code>dispatch</code> runs.</p>
<p>Redux uses a special kind of addon called <strong>middleware</strong> to let us customize the <code>dispatch</code> function.</p>
<p>If you’ve ever used a library like Express or Koa, you might already be familiar with the idea of adding middleware to customize behavior. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it’s composable in a chain. You can use multiple independent third-party middleware in a single project.</p>
<p>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. <strong>Redux middleware provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</strong> People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</p>
<p>First, we’ll look at how to add middleware to the store, then we’ll show how you can write your own.</p>
<h3 id="using-middleware">Using Middleware</h3>
<p>We already saw that you can customize a Redux store using store enhancers. Redux middleware are actually implemented on top of a very special store enhancer that comes built in with Redux, called <strong><code>applyMiddleware</code></strong>.</p>
<p>Since we already know how to add enhancers to our store, we should be able to do that now. We’ll start with <code>applyMiddleware</code> by itself, and we’ll add three example middleware that have been included in this project.</p>
<p>```js title=“src/store.js” import { createStore, applyMiddleware } from “redux”; import rootReducer from “./reducer”; import { print1, print2, print3 } from “./exampleAddons/middleware”;</p>
<p>const middlewareEnhancer = applyMiddleware(print1, print2, print3);</p>
<p>// Pass enhancer as the second arg, since there’s no preloadedState const store = createStore(rootReducer, middlewareEnhancer);</p>
<p>export default store; ```</p>
<p>As their names say, each of these middleware will print a number when an action is dispatched.</p>
<p>What happens if we dispatch now?</p>
<p>```js title=“src/index.js” import store from “./store”;</p>
<p>store.dispatch({ type: “todos/todoAdded”, payload: “Learn about actions” }); // log: ‘1’ // log: ‘2’ // log: ‘3’ ```</p>
<p>And we can see the output in the console:</p>
<figure>
<img src="/img/tutorials/fundamentals/print-middleware-logging.png" alt="print middleware logging" /><figcaption>print middleware logging</figcaption>
</figure>
<p>So how does that work?</p>
<p><strong>Middleware form a pipeline around the store’s <code>dispatch</code> method</strong>. When we call <code>store.dispatch(action)</code>, we’re <em>actually</em> calling the first middleware in the pipeline. That middleware can then do anything it wants when it sees the action. Typically, a middleware will check to see if the action is a specific type that it cares about, much like a reducer would. If it’s the right type, the middleware might run some custom logic. Otherwise, it passes the action to the next middleware in the pipeline.</p>
<p><em>Unlike</em> a reducer, <strong>middleware can have side effects inside</strong>, including timeouts and other async logic.</p>
<p>In this case, the action is passed through:</p>
<ol type="1">
<li>The <code>print1</code> middleware (which we see as <code>store.dispatch</code>)</li>
<li>The <code>print2</code> middleware</li>
<li>The <code>print3</code> middleware</li>
<li>The original <code>store.dispatch</code></li>
<li>The root reducer inside <code>store</code></li>
</ol>
<p>And since these are all function calls, they all <em>return</em> from that call stack. So, the <code>print1</code> middleware is the first to run, and the last to finish.</p>
<h3 id="writing-custom-middleware">Writing Custom Middleware</h3>
<p>We can also write our own middleware. You might not need to do this all the time, but custom middleware are a great way to add specific behaviors to a Redux application.</p>
<p><strong>Redux middleware are written as a series of three nested functions</strong>. Let’s see what that pattern looks like. We’ll start by trying to write this middleware using the <code>function</code> keyword, so that it’s more clear what’s happening:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb227-1" title="1"><span class="co">// Middleware written as ES5 functions</span></a>
<a class="sourceLine" id="cb227-2" title="2"></a>
<a class="sourceLine" id="cb227-3" title="3"><span class="co">// Outer function:</span></a>
<a class="sourceLine" id="cb227-4" title="4"><span class="kw">function</span> <span class="at">exampleMiddleware</span>(storeAPI) <span class="op">{</span></a>
<a class="sourceLine" id="cb227-5" title="5">  <span class="cf">return</span> <span class="kw">function</span> <span class="at">wrapDispatch</span>(next) <span class="op">{</span></a>
<a class="sourceLine" id="cb227-6" title="6">    <span class="cf">return</span> <span class="kw">function</span> <span class="at">handleAction</span>(action) <span class="op">{</span></a>
<a class="sourceLine" id="cb227-7" title="7">      <span class="co">// Do anything here: pass the action onwards with next(action),</span></a>
<a class="sourceLine" id="cb227-8" title="8">      <span class="co">// or restart the pipeline with storeAPI.dispatch(action)</span></a>
<a class="sourceLine" id="cb227-9" title="9">      <span class="co">// Can also use storeAPI.getState() here</span></a>
<a class="sourceLine" id="cb227-10" title="10"></a>
<a class="sourceLine" id="cb227-11" title="11">      <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb227-12" title="12">    <span class="op">};</span></a>
<a class="sourceLine" id="cb227-13" title="13">  <span class="op">};</span></a>
<a class="sourceLine" id="cb227-14" title="14"><span class="op">}</span></a></code></pre></div>
<p>Let’s break down what these three functions do and what their arguments are.</p>
<ul>
<li><code>exampleMiddleware</code>: The outer function is actually the “middleware” itself. It will be called by <code>applyMiddleware</code>, and receives a <code>storeAPI</code> object containing the store’s <code>{dispatch, getState}</code> functions. These are the same <code>dispatch</code> and <code>getState</code> functions that are actually part of the store. If you call this <code>dispatch</code> function, it will send the action to the <em>start</em> of the middleware pipeline. This is only called once.</li>
<li><code>wrapDispatch</code>: The middle function receives a function called <code>next</code> as its argument. This function is actually the <em>next middleware</em> in the pipeline. If this middleware is the last one in the sequence, then <code>next</code> is actually the original <code>store.dispatch</code> function instead. Calling <code>next(action)</code> passes the middleware to the <em>next</em> middleware in the pipeline. This is also only called once</li>
<li><code>handleAction</code>: Finally, the inner function receives the current <code>action</code> as its argument, and will be called <em>every</em> time an action is dispatched.</li>
</ul>
<div class="tip">
<p>You can give these middleware functions any names you want, but it can help to use these names to remember what each one does:</p>
<ul>
<li>Outer: <code>someCustomMiddleware</code> (or whatever your middleware is called)</li>
<li>Middle: <code>wrapDispatch</code></li>
<li>Inner: <code>handleAction</code></li>
</ul>
</div>
<p>Because these are normal functions, we can also write them using ES6 arrow functions. This lets us write them shorter because arrow functions don’t have to have a <code>return</code> statement, but it can also be a bit harder to read if you’re not yet familiar with arrow functions and implicit returns.</p>
<p>Here’s the same example as above, using arrow functions:</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb228-1" title="1"><span class="kw">const</span> anotherExampleMiddleware <span class="op">=</span> (storeAPI) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb228-2" title="2">  <span class="co">// Do something in here, when each action is dispatched</span></a>
<a class="sourceLine" id="cb228-3" title="3"></a>
<a class="sourceLine" id="cb228-4" title="4">  <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb228-5" title="5"><span class="op">};</span></a></code></pre></div>
<p>We’re still nesting those three functions together, and returning each function, but the implicit returns make this shorter.</p>
<h3 id="your-first-custom-middleware">Your First Custom Middleware</h3>
<p>Let’s say we want to add some logging to our application. We’d like to see the contents of each action in the console when it’s dispatched, and we’d like to see what the state is after the action has been handled by the reducers.</p>
<div class="info">
<p>These example middleware aren’t specifically part of the actual todo app, but you can try adding them to your project to see what happens when you use them.</p>
</div>
<p>We can write a small middleware that will log that information to the console for us:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb229-1" title="1"><span class="kw">const</span> loggerMiddleware <span class="op">=</span> (storeAPI) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb229-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;dispatching&quot;</span><span class="op">,</span> action)<span class="op">;</span></a>
<a class="sourceLine" id="cb229-3" title="3">  <span class="kw">let</span> result <span class="op">=</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb229-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;next state&quot;</span><span class="op">,</span> <span class="va">storeAPI</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb229-5" title="5">  <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb229-6" title="6"><span class="op">};</span></a></code></pre></div>
<p>Whenever an action is dispatched:</p>
<ul>
<li>The first part of the <code>handleAction</code> function runs, and we print <code>'dispatching'</code></li>
<li>We pass the action to the <code>next</code> section, which may be another middleware or the real <code>store.dispatch</code></li>
<li>Eventually the reducers run and the state is updated, and the <code>next</code> function returns</li>
<li>We can now call <code>storeAPI.getState()</code> and see what the new state is</li>
<li>We finish by returning whatever <code>result</code> value came from the <code>next</code> middleware</li>
</ul>
<p>Any middleware can return any value, and the return value from the first middleware in the pipeline is actually returned when you call <code>store.dispatch()</code>. For example:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb230-1" title="1"><span class="kw">const</span> alwaysReturnHelloMiddleware <span class="op">=</span> storeAPI <span class="kw">=&gt;</span> next <span class="kw">=&gt;</span> action <span class="op">{</span></a>
<a class="sourceLine" id="cb230-2" title="2">  <span class="kw">const</span> originalResult <span class="op">=</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb230-3" title="3">  <span class="co">// Ignore the original result, return something else</span></a>
<a class="sourceLine" id="cb230-4" title="4">  <span class="cf">return</span> <span class="st">&#39;Hello!&#39;</span></a>
<a class="sourceLine" id="cb230-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb230-6" title="6"></a>
<a class="sourceLine" id="cb230-7" title="7"><span class="kw">const</span> middlewareEnhancer <span class="op">=</span> <span class="at">applyMiddleware</span>(alwaysReturnHelloMiddleware)</a>
<a class="sourceLine" id="cb230-8" title="8"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> middlewareEnhancer)</a>
<a class="sourceLine" id="cb230-9" title="9"></a>
<a class="sourceLine" id="cb230-10" title="10"><span class="kw">const</span> dispatchResult <span class="op">=</span> <span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span><span class="dt">type</span><span class="op">:</span> <span class="st">&#39;some/action&#39;</span><span class="op">}</span>)</a>
<a class="sourceLine" id="cb230-11" title="11"><span class="va">console</span>.<span class="at">log</span>(dispatchResult)</a>
<a class="sourceLine" id="cb230-12" title="12"><span class="co">// log: &#39;Hello!&#39;</span></a></code></pre></div>
<p>Let’s try one more example. Middleware often look for a specific action, and then do something when that action is dispatched. Middleware also have the ability to run async logic inside. We can write a middleware that prints something on a delay when it sees a certain action:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb231-1" title="1"><span class="kw">const</span> delayedMessageMiddleware <span class="op">=</span> (storeAPI) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb231-2" title="2">  <span class="cf">if</span> (<span class="va">action</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&quot;todos/todoAdded&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb231-3" title="3">    <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb231-4" title="4">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Added a new todo: &quot;</span><span class="op">,</span> <span class="va">action</span>.<span class="at">payload</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb231-5" title="5">    <span class="op">},</span> <span class="dv">1000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb231-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb231-7" title="7"></a>
<a class="sourceLine" id="cb231-8" title="8">  <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb231-9" title="9"><span class="op">};</span></a></code></pre></div>
<p>This middleware will look for “todo added” actions. Every time it sees one, it sets a 1-second timer, and then prints the action’s payload to the console.</p>
<h3 id="middleware-use-cases">Middleware Use Cases</h3>
<p>So, what can we do with middleware? Lots of things!</p>
<p>A middleware can do anything it wants when it sees a dispatched action:</p>
<ul>
<li>Log something to the console</li>
<li>Set timeouts</li>
<li>Make asynchronous API calls</li>
<li>Modify the action</li>
<li>Pause the action or even stop it entirely</li>
</ul>
<p>and anything else you can think of.</p>
<p>In particular, <strong>middleware are <em>intended</em> to contain logic with side effects</strong>. In addition, <strong>middleware can modify <code>dispatch</code> to accept things that are <em>not</em> plain action objects</strong>. We’ll talk more about both of these <a href="./part-6-async-logic.md">in Part 6: Async Logic</a>.</p>
<h2 id="redux-devtools">Redux DevTools</h2>
<p>Finally, there’s one more very important thing to cover with configuring the store.</p>
<p><strong>Redux was specifically designed to make it easier to understand when, where, why, and how your state has changed over time</strong>. As part of that, Redux was built to enable the use of the <strong>Redux DevTools</strong> - an addon that shows you a history of what actions were dispatched, what those actions contained, and how the state changed after each dispatched action.</p>
<p>The Redux DevTools UI is available as a browser extension for <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en">Chrome</a> and <a href="https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/">Firefox</a>. If you haven’t already added that to your browser, go ahead and do that now.</p>
<p>Once that’s installed, open up the browser’s DevTools window. You should now see a new “Redux” tab there. It doesn’t do anything, yet - we’ve got to set it up to talk to a Redux store first.</p>
<h3 id="adding-the-devtools-to-the-store">Adding the DevTools to the Store</h3>
<p>Once the extension is installed, we need to configure the store so that the DevTools can see what’s happening inside. The DevTools require a specific store enhancer to be added to make that possible.</p>
<p>The <a href="https://github.com/zalmoxisus/redux-devtools-extension">Redux DevTools Extension docs</a> have some instructions on how to set up the store, but the steps listed are a bit complicated. However, there’s an NPM package called <code>redux-devtools-extension</code> that takes care of the complicated part. That package exports a specialized <code>composeWithDevTools</code> function that we can use instead of the original Redux <code>compose</code> function.</p>
<p>Here’s how that looks:</p>
<p>```js title=“src/store.js” import { createStore, applyMiddleware } from “redux”; import { composeWithDevTools } from “redux-devtools-extension”; import rootReducer from “./reducer”; import { print1, print2, print3 } from “./exampleAddons/middleware”;</p>
<p>const composedEnhancer = composeWithDevTools( // EXAMPLE: Add whatever middleware you actually want to use here applyMiddleware(print1, print2, print3) // other store enhancers if any );</p>
<p>const store = createStore(rootReducer, composedEnhancer); export default store; ```</p>
<p>Make sure that <code>index.js</code> is still dispatching an action after importing the store. Now, open up the Redux DevTools tab in the browser’s DevTools window. You should see something that looks like this:</p>
<figure>
<img src="/img/tutorials/fundamentals/devtools-action-tab.png" alt="Redux DevTools Extension: action tab" /><figcaption>Redux DevTools Extension: action tab</figcaption>
</figure>
<p>There’s a list of dispatched actions on the left. If we click one of them, the right pane shows several tabs:</p>
<ul>
<li>The contents of that action object</li>
<li>The entire Redux state as it looked after the reducer ran</li>
<li>The diff between the previous state and this state</li>
<li>If enabled, the function stack trace leading back to the line of code that called <code>store.dispatch()</code> in the first place</li>
</ul>
<p>Here’s what the “State” and “Diff” tabs look like after we dispatched that “add todo” action:</p>
<figure>
<img src="/img/tutorials/fundamentals/devtools-state-tab.png" alt="Redux DevTools Extension: state tab" /><figcaption>Redux DevTools Extension: state tab</figcaption>
</figure>
<figure>
<img src="/img/tutorials/fundamentals/devtools-diff-tab.png" alt="Redux DevTools Extension: diff tab" /><figcaption>Redux DevTools Extension: diff tab</figcaption>
</figure>
<p>These are very powerful tools that can help us debug our apps and understand exactly what’s happening inside.</p>
<h2 id="what-youve-learned-3">What You’ve Learned</h2>
<p>As you’ve seen, the store is the central piece of every Redux application. Stores contain state and handle actions by running reducers, and can be customized to add additional behaviors.</p>
<p>Let’s see how our example app looks now:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-2-storeSetup/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;module=%2Fsrc%2Fstore.js&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>And as a reminder, here’s what we covered in this section:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux apps always have a single store</strong>
<ul>
<li>Stores are created with the Redux <code>createStore</code> API</li>
<li>Every store has a single root reducer function</li>
</ul></li>
<li><strong>Stores have three main methods</strong>
<ul>
<li><code>getState</code> returns the current state</li>
<li><code>dispatch</code> sends an action to the reducer to update the state</li>
<li><code>subscribe</code> takes a listener callback that runs each time an action is dispatched</li>
</ul></li>
<li><strong>Store enhancers let us customize the store when it’s created</strong>
<ul>
<li>Enhancers wrap the store and can override its methods</li>
<li><code>createStore</code> accepts one enhancer as an argument</li>
<li>Multiple enhancers can be merged together using the <code>compose</code> API</li>
</ul></li>
<li><strong>Middleware are the main way to customize the store</strong>
<ul>
<li>Middleware are added using the <code>applyMiddleware</code> enhancer</li>
<li>Middleware are written as three nested functions inside each other</li>
<li>Middleware run each time an action is dispatched</li>
<li>Middleware can have side effects inside</li>
</ul></li>
<li><strong>The Redux DevTools let you see what’s changed in your app over time</strong>
<ul>
<li>The DevTools Extension can be installed in your browser</li>
<li>The store needs the DevTools enhancer added, using <code>composeWithDevTools</code></li>
<li>The DevTools show dispatched actions and changes in state over time</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-3">What’s Next?</h2>
<p>We now have a working Redux store that can run our reducers and update the state when we dispatch actions.</p>
<p>However, every app needs a user interface to display the data and let the user do something useful. In <a href="./part-5-ui-and-react.md">Part 5: UI and React</a>, we’ll see how the Redux store works with a UI, and specifically see how Redux can work together with React.</p>
<hr />
<p>id: part-5-ui-react title: ‘Redux Fundamentals, Part 5: UI and React’ sidebar_label: ‘UI and React’ description: ‘The official Redux Fundamentals tutorial: learn how to use Redux with React’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-5-ui-and-react">Redux Fundamentals, Part 5: UI and React</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How a Redux store works with a UI</li>
<li>How to use Redux with React</li>
</ul>
<p>:::</p>
<h2 id="introduction-5">Introduction</h2>
<p>In <a href="./part-4-store.md">Part 4: Store</a>, we saw how to create a Redux store, dispatch actions, and read the current state. We also looked at how a store works inside, how enhancers and middleware let us customize the store with additional abilities, and how to add the Redux DevTools to let us see what’s happening inside our app as actions are dispatched.</p>
<p>In this section, we’ll add a User Interface for our todo app. We’ll see how Redux works with a UI layer overall, and we’ll specifically cover how Redux works together with React.</p>
<h2 id="integrating-redux-with-a-ui">Integrating Redux with a UI</h2>
<p>Redux is a standalone JS library. As we’ve already seen, you can create and use a Redux store even if you don’t have a user interface set up. This also means that <strong>you can use Redux with any UI framework</strong> (or even without <em>any</em> UI framework), and use it on both client and server. You can write Redux apps with React, Vue, Angular, Ember, jQuery, or vanilla JavaScript.</p>
<p>That said, <strong>Redux was specifically designed to work well with <a href="https://reactjs.org">React</a></strong>. React lets you describe your UI as a function of your state, and Redux contains state and updates it in response to actions.</p>
<p>Because of that, we’ll use React for this tutorial as we build our todo app, and cover the basics of how to use React with Redux.</p>
<p>Before we get to that part, let’s take a quick look at how Redux interacts with a UI layer in general.</p>
<h3 id="basic-redux-and-ui-integration">Basic Redux and UI Integration</h3>
<p>Using Redux with any UI layer requires a few consistent steps:</p>
<ol type="1">
<li>Create a Redux store</li>
<li>Subscribe to updates</li>
<li>Inside the subscription callback:
<ol type="1">
<li>Get the current store state</li>
<li>Extract the data needed by this piece of UI</li>
<li>Update the UI with the data</li>
</ol></li>
<li>If necessary, render the UI with initial state</li>
<li>Respond to UI inputs by dispatching Redux actions</li>
</ol>
<p>Let’s go back to the <a href="./part-1-overview.md">the counter app example we saw in Part 1</a> and see how it follows those steps:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb232-1" title="1"><span class="co">// 1) Create a new Redux store with the `createStore` function</span></a>
<a class="sourceLine" id="cb232-2" title="2"><span class="kw">const</span> store <span class="op">=</span> <span class="va">Redux</span>.<span class="at">createStore</span>(counterReducer)<span class="op">;</span></a>
<a class="sourceLine" id="cb232-3" title="3"></a>
<a class="sourceLine" id="cb232-4" title="4"><span class="co">// 2) Subscribe to redraw whenever the data changes in the future</span></a>
<a class="sourceLine" id="cb232-5" title="5"><span class="va">store</span>.<span class="at">subscribe</span>(render)<span class="op">;</span></a>
<a class="sourceLine" id="cb232-6" title="6"></a>
<a class="sourceLine" id="cb232-7" title="7"><span class="co">// Our &quot;user interface&quot; is some text in a single HTML element</span></a>
<a class="sourceLine" id="cb232-8" title="8"><span class="kw">const</span> valueEl <span class="op">=</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;value&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb232-9" title="9"></a>
<a class="sourceLine" id="cb232-10" title="10"><span class="co">// 3) When the subscription callback runs:</span></a>
<a class="sourceLine" id="cb232-11" title="11"><span class="kw">function</span> <span class="at">render</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb232-12" title="12">  <span class="co">// 3.1) Get the current store state</span></a>
<a class="sourceLine" id="cb232-13" title="13">  <span class="kw">const</span> state <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb232-14" title="14">  <span class="co">// 3.2) Extract the data you want</span></a>
<a class="sourceLine" id="cb232-15" title="15">  <span class="kw">const</span> newValue <span class="op">=</span> <span class="va">state</span>.<span class="va">value</span>.<span class="at">toString</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb232-16" title="16"></a>
<a class="sourceLine" id="cb232-17" title="17">  <span class="co">// 3.3) Update the UI with the new value</span></a>
<a class="sourceLine" id="cb232-18" title="18">  <span class="va">valueEl</span>.<span class="at">innerHTML</span> <span class="op">=</span> newValue<span class="op">;</span></a>
<a class="sourceLine" id="cb232-19" title="19"><span class="op">}</span></a>
<a class="sourceLine" id="cb232-20" title="20"></a>
<a class="sourceLine" id="cb232-21" title="21"><span class="co">// 4) Display the UI with the initial store state</span></a>
<a class="sourceLine" id="cb232-22" title="22"><span class="at">render</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb232-23" title="23"></a>
<a class="sourceLine" id="cb232-24" title="24"><span class="co">// 5) Dispatch actions based on UI inputs</span></a>
<a class="sourceLine" id="cb232-25" title="25"><span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&quot;increment&quot;</span>).<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb232-26" title="26">  <span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/incremented&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb232-27" title="27"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>No matter what UI layer you’re using, <strong>Redux works this same way with every UI</strong>. The actual implementations are typically a bit more complicated to help optimize performance, but it’s the same steps each time.</p>
<p>Since Redux is a separate library, there are different “binding” libraries to help you use Redux with a given UI framework. Those UI binding libraries handle the details of subscribing to the store and efficiently updating the UI as state changes, so that you don’t have to write that code yourself.</p>
<h2 id="using-redux-with-react-1">Using Redux with React</h2>
<p>The official <a href="https://react-redux.js.org"><strong>React-Redux UI bindings library</strong></a> is a separate package from the Redux core. You’ll need to install that in addition as well:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb233-1" title="1"><span class="ex">npm</span> install react-redux</a></code></pre></div>
<p>(If you don’t use npm, you may grab the latest UMD build from unpkg (either a <a href="https://unpkg.com/react-redux@latest/dist/react-redux.js">development</a> or a <a href="https://unpkg.com/react-redux@latest/dist/react-redux.min.js">production</a> build). The UMD build exports a global called <code>window.ReactRedux</code> if you add it to your page via a <code>&lt;script&gt;</code> tag.)</p>
<p>For this tutorial, we’ll cover the most important patterns and examples you need to use React and Redux together, and see how they work in practice as part of our todo app.</p>
<div class="info">
<p>See <strong>the official React-Redux docs at <a href="https://react-redux.js.org" class="uri">https://react-redux.js.org</a></strong> for a complete guide on how to use Redux and React together, and reference documentation on the React-Redux APIs.</p>
</div>
<h3 id="designing-the-component-tree">Designing the Component Tree</h3>
<p>Much like we <a href="./part-3-state-actions-reducers.md#designing-the-state-structure">designed the state structure</a> based on requirements, we can also design the overall set of UI components and how they relate to each other in the application.</p>
<p>Based on <a href="./part-3-state-actions-reducers.md#defining-requirements">the list of business requirements for the app</a>, at a minimum we’re going to need this set of components:</p>
<ul>
<li><strong><code>&lt;App&gt;</code></strong>: the root component that renders everything else.
<ul>
<li><strong><code>&lt;Header&gt;</code></strong>: contains the “new todo” text input and the “complete all todos” checkbox</li>
<li><strong><code>&lt;TodoList&gt;</code></strong>: a list of all currently visible todo items, based on the filtered results
<ul>
<li><strong><code>&lt;TodoListItem&gt;</code></strong>: a single todo list item, with a checkbox that can be clicked to toggle the todo’s completed status, and a color category selector</li>
</ul></li>
<li><strong><code>&lt;Footer&gt;</code></strong>: Shows the number of active todos and controls for filtering the list based on completed status and color category</li>
</ul></li>
</ul>
<p>Beyond this basic component structure, we could potentially divide the components up in several different ways. For example, the <code>&lt;Footer&gt;</code> component <em>could</em> be one larger component, or it could have multiple smaller components inside like <code>&lt;CompletedTodos&gt;</code>, <code>&lt;StatusFilter&gt;</code>, and <code>&lt;ColorFilters&gt;</code>. There’s no single right way to divide these, and you’ll find that it may be better to write larger components or split things into many smaller components depending on your situation.</p>
<p>For now, we’ll start with this small list of components to keep things easier to follow. On that note, since we assume that <a href="https://reactjs.org">you already know React</a>, <strong>we’re going to skip past the details of how to write the layout code for these components and focus on how to actually use the React-Redux library in your React components</strong>.</p>
<p>Here’s the initial React UI of this app looks like before we start adding any Redux-related logic:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-3-initialUI/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;view=preview&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<h3 id="reading-state-from-the-store-with-useselector">Reading State from the Store with <code>useSelector</code></h3>
<p>We know that we need to be able to show a list of todo items. Let’s start by creating a <code>&lt;TodoList&gt;</code> component that can read the list of todos from the store, loop over them, and show one <code>&lt;TodoListItem&gt;</code> component for each todo entry.</p>
<p>You should be familiar with <a href="https://reactjs.org/docs/hooks-state.html">React hooks like <code>useState</code></a>, which can be called in React function components to give them access to React state values. React also lets us write <a href="https://reactjs.org/docs/hooks-custom.html">custom hooks</a>, which let us extract reusable hooks to add our own behavior on top of React’s built-in hooks.</p>
<p>Like many other libraries, React-Redux includes <a href="https://react-redux.js.org/api/hooks">its own custom hooks</a>, which you can use in your own components. The React-Redux hooks give your React component the ability to talk to the Redux store by reading state and dispatching actions.</p>
<p>The first React-Redux hook that we’ll look at is the <a href="https://react-redux.js.org/api/hooks#useselector"><strong><code>useSelector</code> hook</strong></a>, which <strong>lets your React components read data from the Redux store</strong>.</p>
<p><code>useSelector</code> accepts a single function, which we call a <strong>selector</strong> function. <strong>A selector is a function that takes the entire Redux store state as its argument, reads some value from the state, and returns that result</strong>.</p>
<p>For example, we know that our todo app’s Redux state keeps the array of todo items as <code>state.todos</code>. We can write a small selector function that returns that todos array:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb234-1" title="1"><span class="kw">const</span> selectTodos <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span><span class="op">;</span></a></code></pre></div>
<p>Or, maybe we want to find out how many todos are currently marked as “completed”:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb235-1" title="1"><span class="kw">const</span> selectTotalCompletedTodos <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb235-2" title="2">  <span class="kw">const</span> completedTodos <span class="op">=</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="at">filter</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">completed</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb235-3" title="3">  <span class="cf">return</span> <span class="va">completedTodos</span>.<span class="at">length</span><span class="op">;</span></a>
<a class="sourceLine" id="cb235-4" title="4"><span class="op">};</span></a></code></pre></div>
<p>So, <strong>selectors can return values from the Redux store state, and also return <em>derived</em> values based on that state as well</strong>.</p>
<p>Let’s read the array of todos into our <code>&lt;TodoList&gt;</code> component. First, we’ll import the <code>useSelector</code> hook from the <code>react-redux</code> library, then call it with a selector function as its argument:</p>
<p>```jsx title=“src/features/todos/TodoList.js” import React from “react”; // highlight-next-line import { useSelector } from “react-redux”; import TodoListItem from “./TodoListItem”;</p>
<p>// highlight-next-line const selectTodos = (state) =&gt; state.todos;</p>
<p>const TodoList = () =&gt; { // highlight-next-line const todos = useSelector(selectTodos);</p>
<p>// since <code>todos</code> is an array, we can loop over it const renderedListItems = todos.map((todo) =&gt; { return <TodoListItem key={todo.id} todo={todo} />; });</p>
return
<ul className="todo-list">
{renderedListItems}
</ul>
<p>; };</p>
<p>export default TodoList; ```</p>
<p>The first time the <code>&lt;TodoList&gt;</code> component renders, the <code>useSelector</code> hook will call <code>selectTodos</code> and pass in the <em>entire</em> Redux state object. Whatever the selector returns will be returned by the hook to your component. So, the <code>const todos</code> in our component will end up holding the same <code>state.todos</code> array inside our Redux store state.</p>
<p>But, what happens if we dispatch an action like <code>{type: 'todos/todoAdded'}</code>? The Redux state will be updated by the reducer, but our component needs to know that something has changed so that it can re-render with the new list of todos.</p>
<p>We know that we can call <code>store.subscribe()</code> to listen for changes to the store, so we <em>could</em> try writing the code to subscribe to the store in every component. But, that would quickly get very repetitive and hard to handle.</p>
<p>Fortunately, <strong><code>useSelector</code> automatically subscribes to the Redux store for us!</strong> That way, any time an action is dispatched, it will call its selector function again right away. <strong>If the value returned by the selector changes from the last time it ran, <code>useSelector</code> will force our component to re-render with the new data</strong>. All we have to do is call <code>useSelector()</code> once in our component, and it does the rest of the work for us.</p>
<p>However, there’s a very important thing to remember here:</p>
<div class="caution">
<p><strong><code>useSelector</code> compares its results using strict <code>===</code> reference comparisons, so the component will re-render any time the selector result is a new reference!</strong> This means that if you create a new reference in your selector and return it, your component could re-render <em>every</em> time an action has been dispatched, even if the data really isn’t different.</p>
</div>
<p>For example, passing this selector to <code>useSelector</code> will cause the component to <em>always</em> re-render, because <code>array.map()</code> always returns a new array reference:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb236-1" title="1"><span class="co">// Bad: always returning a new reference</span></a>
<a class="sourceLine" id="cb236-2" title="2"><span class="kw">const</span> selectTodoDescriptions <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb236-3" title="3">  <span class="co">// This creates a new array reference!</span></a>
<a class="sourceLine" id="cb236-4" title="4">  <span class="cf">return</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">text</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb236-5" title="5"><span class="op">};</span></a></code></pre></div>
<div class="tip">
<p>We’ll talk about one way to fix this issue later in this section. We’ll also talk about how you can improve performance and avoid unnecessary re-renders using “memoized” selector function in <a href="./part-7-standard-patterns.md">Part 7: Standard Redux Patterns</a>.</p>
</div>
<p>It’s also worth noting that we don’t have to write a selector function as a separate variable. You can write a selector function directly inside the call to <code>useSelector</code>, like this:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb237-1" title="1"><span class="kw">const</span> todos <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="dispatching-actions-with-usedispatch">Dispatching Actions with <code>useDispatch</code></h3>
<p>We now know how to read data from the Redux store into our components. But, how can we dispatch actions to the store from a component? We know that outside of React, we can call <code>store.dispatch(action)</code>. Since we don’t have access to the store in a component file, we need some way to get access to the <code>dispatch</code> function by itself inside our components.</p>
<p>The React-Redux <a href="https://react-redux.js.org/api/hooks#usedispatch"><strong><code>useDispatch</code> hook</strong></a> gives us the store’s <code>dispatch</code> method as its result. (In fact, the implementation of the hook really is <code>return store.dispatch</code>.)</p>
<p>So, we can call <code>const dispatch = useDispatch()</code> in any component that needs to dispatch actions, and then call <code>dispatch(someAction)</code> as needed.</p>
<p>Let’s try that in our <code>&lt;Header&gt;</code> component. We know that we need to let the user type in some text for a new todo item, and then dispatch a <code>{type: 'todos/todoAdded'}</code> action containing that text.</p>
<p>We’ll write a typical React form component that uses <a href="https://reactjs.org/docs/forms.html#controlled-components">“controlled inputs”</a> to let the user type in the form text. Then, when the user presses the Enter key specifically, we’ll dispatch that action.</p>
<p>```jsx title=“src/features/header/Header.js” import React, { useState } from “react”; // highlight-next-line import { useDispatch } from “react-redux”;</p>
<p>const Header = () =&gt; { const [text, setText] = useState(""); // highlight-next-line const dispatch = useDispatch();</p>
<p>const handleChange = (e) =&gt; setText(e.target.value);</p>
<p>const handleKeyDown = (e) =&gt; { const trimmedText = e.target.value.trim(); // If the user pressed the Enter key: if (e.key === “Enter” &amp;&amp; trimmedText) { // highlight-start // Dispatch the “todo added” action with this text dispatch({ type: “todos/todoAdded”, payload: trimmedText }); // highlight-end // And clear out the text input setText(""); } };</p>
<p>return ( <input
      type="text"
      placeholder="What needs to be done?"
      autoFocus={true}
      value={text}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
    /> ); };</p>
<p>export default Header; ```</p>
<h3 id="passing-the-store-with-provider">Passing the Store with <code>Provider</code></h3>
<p>Our components can now read state from the store, and dispatch actions to the store. However, we’re still missing something. Where and how are the React-Redux hooks finding the right Redux store? A hook is a JS function, so it can’t automatically import a store from <code>store.js</code> by itself.</p>
<p>Instead, we have to specifically tell React-Redux what store we want to use in our components. We do this by <strong>rendering a <code>&lt;Provider&gt;</code> component around our entire <code>&lt;App&gt;</code>, and passing the Redux store as a prop to <code>&lt;Provider&gt;</code></strong>. After we do this once, every component in the application will be able to access the Redux store if needs to.</p>
<p>Let’s add that to our main <code>index.js</code> file:</p>
<p>```jsx title=“src/index.js” import React from “react”; import ReactDOM from “react-dom”; // highlight-next-line import { Provider } from “react-redux”;</p>
<p>import App from “./App”; import store from “./store”;</p>
<p>ReactDOM.render( // highlight-start // Render a <code>&lt;Provider&gt;</code> around the entire <code>&lt;App&gt;</code>, // and pass the Redux store to as a prop &lt;React.StrictMode&gt; <Provider store={store}> <App /> </Provider> &lt;/React.StrictMode&gt;, // highlight-end document.getElementById(“root”) ); ```</p>
<p>That covers the key parts of using React-Redux with React:</p>
<ul>
<li>Call the <code>useSelector</code> hook to read data in React components</li>
<li>Call the <code>useDispatch</code> hook to dispatch actions in React components</li>
<li>Put <code>&lt;Provider store={store}&gt;</code> around your entire <code>&lt;App&gt;</code> component so that other components can talk to the store</li>
</ul>
<p>We should now be able to actually interact with the app! Here’s the working UI so far:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-4-initialHooks/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>Now, let’s look at a couple more ways we can use these together in our todo app.</p>
<h2 id="react-redux-patterns">React-Redux Patterns</h2>
<h3 id="global-state-component-state-and-forms">Global State, Component State, and Forms</h3>
<p>By now you might be wondering, “Do I always have to put all my app’s state into the Redux store?”</p>
<p>The answer is <strong>NO. Global state that is needed across the app should go in the Redux store. State that’s only needed in one place should be kept in component state.</strong></p>
<p>A good example of this is the <code>&lt;Header&gt;</code> component we wrote earlier. We <em>could</em> keep the current text input string in the Redux store, by dispatching an action in the input’s <code>onChange</code> handler and keeping it in our reducer. But, that doesn’t give us any benefit. The only place that text string is used is here, in the <code>&lt;Header&gt;</code> component.</p>
<p>So, it makes sense to keep that value in a <code>useState</code> hook here in the <code>&lt;Header&gt;</code> component.</p>
<p>Similarly, if we had a boolean flag called <code>isDropdownOpen</code>, no other components in the app would care about that - it should really stay local to this component.</p>
<div class="tip">
<p><strong>In a React + Redux app, your global state should go in the Redux store, and your local state should stay in React components.</strong></p>
<p>If you’re not sure where to put something, here are some common rules of thumb for determining what kind of data should be put into Redux:</p>
<ul>
<li>Do other parts of the application care about this data?</li>
<li>Do you need to be able to create further derived data based on this original data?</li>
<li>Is the same data being used to drive multiple components?</li>
<li>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</li>
<li>Do you want to cache the data (ie, use what’s in state if it’s already there instead of re-requesting it)?</li>
<li>Do you want to keep this data consistent while hot-reloading UI components (which may lose their internal state when swapped)?</li>
</ul>
</div>
<p>This is also a good example of how to think about forms in Redux in general. <strong>Most form state probably shouldn’t be kept in Redux.</strong> Instead, keep the data in your form components as you’re editing it, and then dispatch Redux actions to update the store when the user is done.</p>
<h3 id="using-multiple-selectors-in-a-component">Using Multiple Selectors in a Component</h3>
<p>Right now only our <code>&lt;TodoList&gt;</code> component is reading data from the store. Let’s see what it might look like for the <code>&lt;Footer&gt;</code> component to start reading some data as well.</p>
<p>The <code>&lt;Footer&gt;</code> needs to know three different pieces of information:</p>
<ul>
<li>How many completed todos there are</li>
<li>The current “status” filter value</li>
<li>The current list of selected “color” category filters</li>
</ul>
<p>How can we read these values into the component?</p>
<p><strong>We can call <code>useSelector</code> multiple times within one component</strong>. In fact, this is actually a good idea - <strong>each call to <code>useSelector</code> should always return the smallest amount of state possible</strong>.</p>
<p>We already saw how to write a selector that counts completed todos earlier. For the filters values, both the status filter value and the color filters values live in the <code>state.filters</code> slice. Since this component needs both of them, we can select the entire <code>state.filters</code> object.</p>
<p>As we mentioned earlier, we could put all the input handling directly into <code>&lt;Footer&gt;</code>, or we could split it out into separate components like <code>&lt;StatusFilter&gt;</code>. To keep this explanation shorter, we’ll skip the exact details of writing the input handling and assume we’ve got smaller separate components that are given some data and change handler callbacks as props.</p>
<p>Given that assumption, the React-Redux parts of the component might look like this:</p>
<p>```jsx title=“src/features/footer/Footer.js” import React from “react”; // highlight-next-line import { useSelector } from “react-redux”;</p>
<p>import { availableColors, capitalize } from “../filters/colors”; import { StatusFilters } from “../filters/filtersSlice”;</p>
<p>// Omit other footer components</p>
<p>const Footer = () =&gt; { // highlight-start const todosRemaining = useSelector((state) =&gt; { const uncompletedTodos = state.todos.filter((todo) =&gt; !todo.completed); return uncompletedTodos.length; });</p>
<p>const { status, colors } = useSelector((state) =&gt; state.filters); // highlight-end</p>
<p>// omit placeholder change handlers</p>
return (
<footer className="footer">
<div className="actions">
<pre><code>    &lt;h5&gt;Actions&lt;/h5&gt;
    &lt;button className=&quot;button&quot;&gt;Mark All Completed&lt;/button&gt;
    &lt;button className=&quot;button&quot;&gt;Clear Completed&lt;/button&gt;
  &lt;/div&gt;

  &lt;RemainingTodos count={todosRemaining} /&gt;
  &lt;StatusFilter value={status} onChange={onStatusChange} /&gt;
  &lt;ColorFilters value={colors} onChange={onColorChange} /&gt;
&lt;/footer&gt;</code></pre>
<p>); };</p>
<p>export default Footer; ```</p>
<h3 id="selecting-data-in-list-items-by-id">Selecting Data in List Items by ID</h3>
<p>Currently, our <code>&lt;TodoList&gt;</code> is reading the entire <code>state.todos</code> array and passing the actual todo objects as a prop to each <code>&lt;TodoListItem&gt;</code> component.</p>
<p>This works, but there’s a potential performance problem.</p>
<ul>
<li>Changing one todo object means creating copies of both the todo and the <code>state.todos</code> array, and each copy is a new reference in memory</li>
<li>When <code>useSelector</code> sees a new reference as its result, it forces its component to re-render</li>
<li>So, any time <em>one</em> todo object is updated (like clicking it to toggle its completed status), the whole <code>&lt;TodoList&gt;</code> parent component will re-render</li>
<li>Then, <a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#standard-render-behavior">because React re-renders all child components recursively by default</a>, it also means that <em>all</em> of the <code>&lt;TodoListItem&gt;</code> components will re-render, even though most of them didn’t actually change at all!</li>
</ul>
<p>Re-rendering components isn’t bad - that’s how React knows if it needs to update the DOM. But, re-rendering lots of components when nothing has actually changed can potentially get too slow if the list is too big.</p>
<p>There’s a couple ways we could try to fix this. One option is to <a href="https://reactjs.org/docs/react-api.html#reactmemo">wrap all the <code>&lt;TodoListItem&gt;</code> components in <code>React.memo()</code></a>, so that they only re-render when their props actually change. This is often a good choice for improving performance, but it does require that the child component always receives the same props until something really changes. Since each <code>&lt;TodoListItem&gt;</code> component is receiving a todo item as a prop, only one of them should actually get a changed prop and have to re-render.</p>
<p>Another option is to have the <code>&lt;TodoList&gt;</code> component only read an array of todo IDs from the store, and pass those IDs as props to the child <code>&lt;TodoListItem&gt;</code> components. Then, each <code>&lt;TodoListItem&gt;</code> can use that ID to find the right todo object it needs.</p>
<p>Let’s give that a shot.</p>
<p>```jsx title=“src/features/todos/TodoList.js” import React from “react”; import { useSelector } from “react-redux”; import TodoListItem from “./TodoListItem”;</p>
<p>// highlight-next-line const selectTodoIds = (state) =&gt; state.todos.map((todo) =&gt; todo.id);</p>
<p>const TodoList = () =&gt; { // highlight-next-line const todoIds = useSelector(selectTodoIds);</p>
<p>const renderedListItems = todoIds.map((todoId) =&gt; { // highlight-next-line return <TodoListItem key={todoId} id={todoId} />; });</p>
return
<ul className="todo-list">
{renderedListItems}
</ul>
<p>; }; ```</p>
<p>This time, we only select an array of todo IDs from the store in <code>&lt;TodoList&gt;</code>, and we pass each <code>todoId</code> as an <code>id</code> prop to the child <code>&lt;TodoListItem&gt;</code>s.</p>
<p>Then, in <code>&lt;TodoListItem&gt;</code>, we can use that ID value to read our todo item. We can also update <code>&lt;TodoListItem&gt;</code> to dispatch the “toggled” action based on the todo’s ID.</p>
<p>```jsx title=“src/features/todos/TodoListItem.js” import React from “react”; // highlight-next-line import { useSelector, useDispatch } from “react-redux”;</p>
<p>import { availableColors, capitalize } from “../filters/colors”;</p>
<p>// highlight-start const selectTodoById = (state, todoId) =&gt; { return state.todos.find((todo) =&gt; todo.id === todoId); }; // highlight-end</p>
<p>// Destructure <code>props.id</code>, since we only need the ID value const TodoListItem = ({ id }) =&gt; { // Call our <code>selectTodoById</code> with the state <em>and</em> the ID value // highlight-next-line const todo = useSelector((state) =&gt; selectTodoById(state, id)); const { text, completed, color } = todo;</p>
<p>// highlight-next-line const dispatch = useDispatch();</p>
<p>// highlight-start const handleCompletedChanged = () =&gt; { dispatch({ type: “todos/todoToggled”, payload: todo.id }); }; // highlight-end</p>
<p>// omit other change handlers // omit other list item rendering logic and contents</p>
return (
<li>
<div data-classname="view">
{/* omit other rendering output */}
</div>
</li>
<p>); };</p>
<p>export default TodoListItem; ```</p>
<p>There’s a problem with this, though. We said earlier that <strong>returning new array references in selectors causes components to re-render every time</strong>, and right now we’re returning a new IDs array in <code>&lt;TodoList&gt;</code>. In this case, the <em>contents</em> of the IDs array should be the same if we’re toggling a todo, because we’re still showing the same todo items - we haven’t added or deleted any. But, the array <em>containing</em> those IDs is a new reference, so <code>&lt;TodoList&gt;</code> will re-render when it really doesn’t need to.</p>
<p>One possible solution to this is to change how <code>useSelector</code> compares its values to see if they’ve changed. <code>useSelector</code> can take a comparison function as its second argument. A comparison function is called with the old and new values, and returns <code>true</code> if they’re considered the same. If they’re the same, <code>useSelector</code> won’t make the component re-render.</p>
<p>React-Redux has a <code>shallowEqual</code> comparison function we can use to check if the items <em>inside</em> the array are still the same. Let’s try that:</p>
<p>```jsx title=“src/features/todos/TodoList.js” import React from “react”; // highlight-next-line import { useSelector, shallowEqual } from “react-redux”; import TodoListItem from “./TodoListItem”;</p>
<p>// highlight-next-line const selectTodoIds = (state) =&gt; state.todos.map((todo) =&gt; todo.id);</p>
<p>const TodoList = () =&gt; { // highlight-next-line const todoIds = useSelector(selectTodoIds, shallowEqual);</p>
<p>const renderedListItems = todoIds.map((todoId) =&gt; { return <TodoListItem key={todoId} id={todoId} />; });</p>
return
<ul className="todo-list">
{renderedListItems}
</ul>
<p>; }; ```</p>
<p>Now, if we toggle a todo item, the list of IDs will be considered the same, and <code>&lt;TodoList&gt;</code> won’t have to re-render. The one <code>&lt;TodoListItem&gt;</code> will get an updated todo object and re-render, but all the rest of them will still have the existing todo object and not have to re-render at all.</p>
<p>As mentioned earlier, you can also use a specialized kind of selector function called <a href="part-7-standard-patterns.md">a “memoized selector”</a> to help improve component rendering, and we’ll look at how to use those in another section.</p>
<h2 id="what-youve-learned-4">What You’ve Learned</h2>
<p>We now have a working todo app! Our app creates a store, passes the store to the React UI layer using <code>&lt;Provider&gt;</code>, and then calls <code>useSelector</code> and <code>useDispatch</code> to talk to the store in our React components.</p>
<div class="info">
<p>Try implementing the rest of the missing UI features on your own! Here’s a list of the things you’ll need to add:</p>
<ul>
<li>In <code>&lt;TodoListItem&gt;</code> component, use the <code>useDispatch</code> hook to dispatch actions to for changing the color category and deleting the todo</li>
<li>In <code>&lt;Footer&gt;</code>, use the <code>useDispatch</code> hook to dispatch actions for marking all todos as completed, clearing completed todos, and changing the filter values.</li>
</ul>
<p>We’ll cover implementing the filters in <a href="./part-7-standard-patterns.md">Part 7: Standard Redux Patterns</a>.</p>
</div>
<p>Let’s see how the app looks now, including the components and sections we skipped to keep this shorter:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-5-uiAllActions/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux stores can be used with any UI layer</strong>
<ul>
<li>UI code always subscribes to the store, gets the latest state, and redraws itself</li>
</ul></li>
<li><strong>React-Redux is the official Redux UI bindings library for React</strong>
<ul>
<li>React-Redux is installed as a separate <code>react-redux</code> package</li>
</ul></li>
<li><strong>The <code>useSelector</code> hook lets React components read data from the store</strong>
<ul>
<li>Selector functions take the entire store <code>state</code> as an argument, and return a value based on that state</li>
<li><code>useSelector</code> calls its selector function and returns the result from the selector</li>
<li><code>useSelector</code> subscribes to the store, and re-runs the selector each time an action is dispatched.</li>
<li>Whenever the selector result changes, <code>useSelector</code> forces the component to re-render with the new data</li>
</ul></li>
<li><strong>The <code>useDispatch</code> hook lets React components dispatch actions to the store</strong>
<ul>
<li><code>useDispatch</code> returns the actual <code>store.dispatch</code> function</li>
<li>You can call <code>dispatch(action)</code> as needed inside your components</li>
</ul></li>
<li><strong>The <code>&lt;Provider&gt;</code> component makes the store available to other React components</strong>
<ul>
<li>Render <code>&lt;Provider store={store}&gt;</code> around your entire <code>&lt;App&gt;</code></li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-4">What’s Next?</h2>
<p>Now that our UI is working, it’s time to see how to make our Redux app talk to a server. In <a href="./part-6-async-logic.md">Part 6: Async Logic</a>, we’ll talk about how asynchronous logic like timeouts and AJAX calls fit into the Redux data flow.</p>
<hr />
<p>id: part-6-async-logic title: ‘Redux Fundamentals, Part 6: Async Logic and Data Fetching’ sidebar_label: ‘Async Logic and Data Fetching’ description: ‘The official Redux Fundamentals tutorial: learn how to use async logic with Redux’</p>
<hr />
<h1 id="redux-fundamentals-part-6-async-logic-and-data-fetching">Redux Fundamentals, Part 6: Async Logic and Data Fetching</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How the Redux data flow works with async data</li>
<li>How to use Redux middleware for async logic</li>
<li>Patterns for handling async request state</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Familiarity with using AJAX requests to fetch and update data from a server</li>
<li>Understanding asynchronous logic in JS, including Promises</li>
</ul>
<p>:::</p>
<h2 id="introduction-6">Introduction</h2>
<p>In <a href="./part-5-ui-and-react.md">Part 5: UI and React</a>, we saw how to use the React-Redux library to let our React components interact with a Redux store, including calling <code>useSelector</code> to read Redux state, calling <code>useDispatch</code> to give us access to the <code>dispatch</code> function, and wrapping our app in a <code>&lt;Provider&gt;</code> component to give those hooks access to the store.</p>
<p>So far, all the data we’ve worked with has been directly inside of our React+Redux client application. However, most real applications need to work with data from a server, by making HTTP API calls to fetch and save items.</p>
<p>In this section, we’ll update our todo app to fetch the todos from an API, and add new todos by saving them to the API.</p>
<h3 id="example-rest-api-and-client">Example REST API and Client</h3>
<p>To keep the example project isolated but realistic, the initial project setup already included a fake in-memory REST API for our data (configured using <a href="https://miragejs.com/">the Mirage.js mock API tool</a>). The API uses <code>/fakeApi</code> as the base URL for the endpoints, and supports the typical <code>GET/POST/PUT/DELETE</code> HTTP methods for <code>/fakeApi/todos</code>. It’s defined in <code>src/api/server.js</code>.</p>
<p>The project also includes a small HTTP API client object that exposes <code>client.get()</code> and <code>client.post()</code> methods, similar to popular HTTP libraries like <code>axios</code>. It’s defined in <code>src/api/client.js</code>.</p>
<p>We’ll use the <code>client</code> object to make HTTP calls to our in-memory fake REST API for this section.</p>
<h2 id="redux-middleware-and-side-effects">Redux Middleware and Side Effects</h2>
<p>By itself, a Redux store doesn’t know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store.</p>
<p>Earlier, we said that Redux reducers must never contain “side effects”. <strong>A “side effect” is any change to state or behavior that can be seen outside of returning a value from a function</strong>. Some common kinds of side effects are things like:</p>
<ul>
<li>Logging a value to the console</li>
<li>Saving a file</li>
<li>Setting an async timer</li>
<li>Making an AJAX HTTP request</li>
<li>Modifying some state that exists outside of a function, or mutating arguments to a function</li>
<li>Generating random numbers or unique random IDs (such as <code>Math.random()</code> or <code>Date.now()</code>)</li>
</ul>
<p>However, any real app will need to do these kinds of things <em>somewhere</em>. So, if we can’t put side effects in reducers, where <em>can</em> we put them?</p>
<p><strong>Redux middleware were designed to enable writing logic that has side effects</strong>.</p>
<p>As we said <a href="./part-4-store.md#middleware-use-cases">in Part 4</a>, a Redux middleware can do <em>anything</em> when it sees a dispatched action: log something, modify the action, delay the action, make an async call, and more. Also, since middleware form a pipeline around the real <code>store.dispatch</code> function, this also means that we could actually pass something that <em>isn’t</em> a plain action object to <code>dispatch</code>, as long as a middleware intercepts that value and doesn’t let it reach the reducers.</p>
<p>Middleware also have access to <code>dispatch</code> and <code>getState</code>. That means you could write some async logic in a middleware, and still have the ability to interact with the Redux store by dispatching actions.</p>
<h3 id="using-middleware-to-enable-async-logic">Using Middleware to Enable Async Logic</h3>
<p>Let’s look at a couple examples of how middleware can enable us to write some kind of async logic that interacts with the Redux store.</p>
<p>One possibility is writing a middleware that looks for specific action types, and runs async logic when it sees those actions, like these examples:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb239-1" title="1"><span class="im">import</span> <span class="op">{</span> client <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../api/client&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb239-2" title="2"></a>
<a class="sourceLine" id="cb239-3" title="3"><span class="kw">const</span> delayedActionMiddleware <span class="op">=</span> (storeAPI) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb239-4" title="4">  <span class="cf">if</span> (<span class="va">action</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&quot;todos/todoAdded&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb239-5" title="5">    <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb239-6" title="6">      <span class="co">// Delay this action by one second</span></a>
<a class="sourceLine" id="cb239-7" title="7">      <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb239-8" title="8">    <span class="op">},</span> <span class="dv">1000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb239-9" title="9">    <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb239-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb239-11" title="11"></a>
<a class="sourceLine" id="cb239-12" title="12">  <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb239-13" title="13"><span class="op">};</span></a>
<a class="sourceLine" id="cb239-14" title="14"></a>
<a class="sourceLine" id="cb239-15" title="15"><span class="kw">const</span> fetchTodosMiddleware <span class="op">=</span> (storeAPI) <span class="kw">=&gt;</span> (next) <span class="kw">=&gt;</span> (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb239-16" title="16">  <span class="cf">if</span> (<span class="va">action</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&quot;todos/fetchTodos&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb239-17" title="17">    <span class="co">// Make an API call to fetch todos from the server</span></a>
<a class="sourceLine" id="cb239-18" title="18">    <span class="va">client</span>.<span class="at">get</span>(<span class="st">&quot;todos&quot;</span>).<span class="at">then</span>((todos) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb239-19" title="19">      <span class="co">// Dispatch an action with the todos we received</span></a>
<a class="sourceLine" id="cb239-20" title="20">      <span class="va">storeAPI</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todosLoaded&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> todos <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb239-21" title="21">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb239-22" title="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb239-23" title="23"></a>
<a class="sourceLine" id="cb239-24" title="24">  <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb239-25" title="25"><span class="op">};</span></a></code></pre></div>
<div class="info">
<p>For more details on why and how Redux uses middleware for async logic, see these StackOverflow answers by Redux creator Dan Abramov:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559">“How to dispatch a Redux action with a timeout?”</a></li>
<li><a href="https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594">“Why do we need middleware for async flow?”</a></li>
</ul>
</div>
<h3 id="writing-an-async-function-middleware">Writing an Async Function Middleware</h3>
<p>Both of the middleware in that last section were very specific and only do one thing. It would be nice if we had a way to write <em>any</em> async logic ahead of time, separate from the middleware itself, and still have access to <code>dispatch</code> and <code>getState</code> so that we can interact with the store.</p>
<p><strong>What if we wrote a middleware that let us pass a <em>function</em> to <code>dispatch</code>, instead of an action object</strong>? We could have our middleware check to see if the “action” is actually a function instead, and if it’s a function, call the function right away. That would let us write async logic in separate functions, outside of the middleware definition.</p>
<p>Here’s what that middleware might look like:</p>
<p>``<code>js title="Example async function middleware" const asyncFunctionMiddleware = (storeAPI) =&gt; (next) =&gt; (action) =&gt; {   // If the "action" is actually a function instead...   if (typeof action === "function") {     // then call the function and pass</code>dispatch<code>and</code>getState` as arguments return action(storeAPI.dispatch, storeAPI.getState); }</p>
<p>// Otherwise, it’s a normal action - send it onwards return next(action); }; ```</p>
<p>And then we could use that middleware like this:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb240-1" title="1"><span class="kw">const</span> middlewareEnhancer <span class="op">=</span> <span class="at">applyMiddleware</span>(asyncFunctionMiddleware)<span class="op">;</span></a>
<a class="sourceLine" id="cb240-2" title="2"><span class="kw">const</span> store <span class="op">=</span> <span class="at">createStore</span>(rootReducer<span class="op">,</span> middlewareEnhancer)<span class="op">;</span></a>
<a class="sourceLine" id="cb240-3" title="3"></a>
<a class="sourceLine" id="cb240-4" title="4"><span class="co">// Write a function that has `dispatch` and `getState` as arguments</span></a>
<a class="sourceLine" id="cb240-5" title="5"><span class="kw">const</span> fetchSomeData <span class="op">=</span> (dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb240-6" title="6">  <span class="co">// Make an async HTTP request</span></a>
<a class="sourceLine" id="cb240-7" title="7">  <span class="va">client</span>.<span class="at">get</span>(<span class="st">&quot;todos&quot;</span>).<span class="at">then</span>((todos) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb240-8" title="8">    <span class="co">// Dispatch an action with the todos we received</span></a>
<a class="sourceLine" id="cb240-9" title="9">    <span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todosLoaded&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> todos <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb240-10" title="10">    <span class="co">// Check the updated store state after dispatching</span></a>
<a class="sourceLine" id="cb240-11" title="11">    <span class="kw">const</span> allTodos <span class="op">=</span> <span class="at">getState</span>().<span class="at">todos</span><span class="op">;</span></a>
<a class="sourceLine" id="cb240-12" title="12">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Number of todos after loading: &quot;</span><span class="op">,</span> <span class="va">allTodos</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb240-13" title="13">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb240-14" title="14"><span class="op">};</span></a>
<a class="sourceLine" id="cb240-15" title="15"></a>
<a class="sourceLine" id="cb240-16" title="16"><span class="co">// Pass the _function_ we wrote to `dispatch`</span></a>
<a class="sourceLine" id="cb240-17" title="17"><span class="va">store</span>.<span class="at">dispatch</span>(fetchSomeData)<span class="op">;</span></a>
<a class="sourceLine" id="cb240-18" title="18"><span class="co">// logs: &#39;Number of todos after loading: ###&#39;</span></a></code></pre></div>
<p>Again, notice that <strong>this “async function middleware” let us pass a <em>function</em> to <code>dispatch</code>!</strong> Inside that function, we were able to write some async logic (an HTTP request), then dispatch a normal action object when the request completed.</p>
<h2 id="redux-async-data-flow">Redux Async Data Flow</h2>
<p>So how do middleware and async logic affect the overall data flow of a Redux app?</p>
<p>Just like with a normal action, we first need to handle a user event in the application, such as a click on a button. Then, we call <code>dispatch()</code>, and pass in <em>something</em>, whether it be a plain action object, a function, or some other value that a middleware can look for.</p>
<p>Once that dispatched value reaches a middleware, it can make an async call, and then dispatch a real action object when the async call completes.</p>
<p>Earlier, we saw <a href="./part-2-concepts-data-flow.md#redux-application-data-flow">a diagram that represents the normal synchronous Redux data flow</a>. When we add async logic to a Redux app, we add an extra step where middleware can run logic like AJAX requests, then dispatch actions. That makes the async data flow look like this:</p>
<figure>
<img src="/img/tutorials/essentials/ReduxAsyncDataFlowDiagram.gif" alt="Redux async data flow diagram" /><figcaption>Redux async data flow diagram</figcaption>
</figure>
<h2 id="using-the-redux-thunk-middleware">Using the Redux Thunk Middleware</h2>
<p>As it turns out, Redux already has an official version of that “async function middleware”, called the <a href="https://github.com/reduxjs/redux-thunk"><strong>Redux “Thunk” middleware</strong></a>. The thunk middleware allows us to write functions that get <code>dispatch</code> and <code>getState</code> as arguments. The thunk functions can have any async logic we want inside, and that logic can dispatch actions and read the store state as needed.</p>
<p><strong>Writing async logic as thunk functions allows us to reuse that logic without knowing what Redux store we’re using ahead of time</strong>.</p>
<div class="info">
<p>The word “thunk” is a programming term that means <a href="https://en.wikipedia.org/wiki/Thunk">“a piece of code that does some delayed work”</a>. For more details on how to use thunks, see the thunk usage guide page:</p>
<ul>
<li><a href="../../usage/writing-logic-thunks.mdx">Using Redux: Writing Logic with Thunks</a></li>
</ul>
<p>as well as these posts:</p>
<ul>
<li><a href="https://daveceddia.com/what-is-a-thunk/">What the heck is a thunk?</a></li>
<li><a href="https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60">Thunks in Redux: the basics</a></li>
</ul>
</div>
<h3 id="configuring-the-store-1">Configuring the Store</h3>
<p>The Redux thunk middleware is available on NPM as a package called <code>redux-thunk</code>. We need to install that package to use it in our app:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb241-1" title="1"><span class="ex">npm</span> install redux-thunk</a></code></pre></div>
<p>Once it’s installed, we can update the Redux store in our todo app to use that middleware:</p>
<p>```js title=“src/store.js” import { createStore, applyMiddleware } from “redux”; // highlight-next-line import thunkMiddleware from “redux-thunk”; import { composeWithDevTools } from “redux-devtools-extension”; import rootReducer from “./reducer”;</p>
<p>// highlight-next-line const composedEnhancer = composeWithDevTools(applyMiddleware(thunkMiddleware));</p>
<p>// The store now has the ability to accept thunk functions in <code>dispatch</code> const store = createStore(rootReducer, composedEnhancer); export default store; ```</p>
<h3 id="fetching-todos-from-a-server">Fetching Todos from a Server</h3>
<p>Right now our todo entries can only exist in the client’s browser. We need a way to load a list of todos from the server when the app starts up.</p>
<p>We’ll start by writing a thunk function that makes an AJAX call to our <code>/fakeApi/todos</code> endpoint to request an array of todo objects, and then dispatch an action containing that array as the payload. Since this is related to the todos feature in general, we’ll write the thunk function in the <code>todosSlice.js</code> file:</p>
<p>```js title=“src/features/todos/todosSlice.js” import { client } from “../../api/client”;</p>
<p>const initialState = [];</p>
<p>export default function todosReducer(state = initialState, action) { // omit reducer logic }</p>
<p>// Thunk function // highlight-start export async function fetchTodos(dispatch, getState) { const response = await client.get(“/fakeApi/todos”); dispatch({ type: “todos/todosLoaded”, payload: response.todos }); } // highlight-end ```</p>
<p>We only want to make this API call once, when the application loads for the first time. There’s a few places we <em>could</em> put this:</p>
<ul>
<li>In the <code>&lt;App&gt;</code> component, in a <code>useEffect</code> hook</li>
<li>In the <code>&lt;TodoList&gt;</code> component, in a <code>useEffect</code> hook</li>
<li>In the <code>index.js</code> file directly, right after we import the store</li>
</ul>
<p>For now, let’s try putting this directly in <code>index.js</code>:</p>
<p>```js title=“src/index.js” import React from “react”; import ReactDOM from “react-dom”; import { Provider } from “react-redux”; import “./index.css”; import App from “./App”;</p>
<p>import “./api/server”;</p>
<p>// highlight-start import store from “./store”; import { fetchTodos } from “./features/todos/todosSlice”;</p>
<p>store.dispatch(fetchTodos); // highlight-end</p>
<p>ReactDOM.render( &lt;React.StrictMode&gt; <Provider store={store}> <App /> </Provider> &lt;/React.StrictMode&gt;, document.getElementById(“root”) ); ```</p>
<p>If we reload the page, there’s no visible change in the UI. However, if we open up the Redux DevTools extension, we should now see that a <code>'todos/todosLoaded'</code> action was dispatched, and it should contain some todo objects that were generated by our fake server API:</p>
<figure>
<img src="/img/tutorials/fundamentals/devtools-todosLoaded-action.png" alt="Devtools - todosLoaded action contents" /><figcaption>Devtools - todosLoaded action contents</figcaption>
</figure>
<p>Notice that even though we’ve dispatched an action, nothing’s happening to change the state. <strong>We need to handle this action in our todos reducer to have the state updated.</strong></p>
<p>Let’s add a case to the reducer to load this data into the store. Since we’re fetching the data from the server, we want to completely replace any existing todos, so we can return the <code>action.payload</code> array to make it be the new todos <code>state</code> value:</p>
<p>```js title=“src/features/todos/todosSlice.js” import { client } from “../../api/client”;</p>
<p>const initialState = [];</p>
<p>export default function todosReducer(state = initialState, action) { switch (action.type) { // omit other reducer cases // highlight-start case “todos/todosLoaded”: { // Replace the existing state entirely by returning the new value return action.payload; } // highlight-end default: return state; } }</p>
<p>export async function fetchTodos(dispatch, getState) { const response = await client.get(“/fakeApi/todos”); dispatch({ type: “todos/todosLoaded”, payload: response.todos }); } ```</p>
<p>Since dispatching an action immediately updates the store, we can also call <code>getState</code> in the thunk to read the updated state value after we dispatch. For example, we could log the number of total todos to the console before and after dispatching the <code>'todos/todosLoaded'</code> action:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb242-1" title="1"><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="at">fetchTodos</span>(dispatch<span class="op">,</span> getState) <span class="op">{</span></a>
<a class="sourceLine" id="cb242-2" title="2">  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="va">client</span>.<span class="at">get</span>(<span class="st">&quot;/fakeApi/todos&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb242-3" title="3"></a>
<a class="sourceLine" id="cb242-4" title="4">  <span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb242-5" title="5">  <span class="kw">const</span> stateBefore <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb242-6" title="6">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Todos before dispatch: &quot;</span><span class="op">,</span> <span class="va">stateBefore</span>.<span class="va">todos</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb242-7" title="7"></a>
<a class="sourceLine" id="cb242-8" title="8">  <span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todosLoaded&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> <span class="va">response</span>.<span class="at">todos</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb242-9" title="9"></a>
<a class="sourceLine" id="cb242-10" title="10">  <span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb242-11" title="11">  <span class="kw">const</span> stateAfter <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb242-12" title="12">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Todos after dispatch: &quot;</span><span class="op">,</span> <span class="va">stateAfter</span>.<span class="va">todos</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb242-13" title="13"><span class="op">}</span></a></code></pre></div>
<h3 id="saving-todo-items">Saving Todo Items</h3>
<p>We also need to update the server whenever we try to create a new todo item. Instead of dispatching the <code>'todos/todoAdded'</code> action right away, we should make an API call to the server with the initial data, wait for the server to send back a copy of the newly saved todo item, and <em>then</em> dispatch an action with that todo item.</p>
<p>However, if we start trying to write this logic as a thunk function, we’re going to run into a problem: since we’re writing the thunk as a separate function in the <code>todosSlice.js</code> file, the code that makes the API call doesn’t know what the new todo text is supposed to be:</p>
<p><code>js title="src/features/todos/todosSlice.js" async function saveNewTodo(dispatch, getState) {   // ❌ We need to have the text of the new todo, but where is it coming from?   // highlight-next-line   const initialTodo = { text };   const response = await client.post("/fakeApi/todos", { todo: initialTodo });   dispatch({ type: "todos/todoAdded", payload: response.todo }); }</code></p>
<p>We need a way to write one function that accepts <code>text</code> as its parameter, but then creates the actual thunk function so that it can use the <code>text</code> value to make the API call. Our outer function should then return the thunk function so that we can pass to <code>dispatch</code> in our component.</p>
<p><code>js title="src/features/todos/todosSlice.js" // Write a synchronous outer function that receives the `text` parameter: export function saveNewTodo(text) {   // And then creates and returns the async thunk function:   return async function saveNewTodoThunk(dispatch, getState) {     // ✅ Now we can use the text value and send it to the server     const initialTodo = { text };     const response = await client.post("/fakeApi/todos", { todo: initialTodo });     dispatch({ type: "todos/todoAdded", payload: response.todo });   }; }</code></p>
<p>Now we can use this in our <code>&lt;Header&gt;</code> component:</p>
<p>```js title=“src/features/header/Header.js” import React, { useState } from “react”; import { useDispatch } from “react-redux”;</p>
<p>// highlight-next-line import { saveNewTodo } from “../todos/todosSlice”;</p>
<p>const Header = () =&gt; { const [text, setText] = useState(""); const dispatch = useDispatch();</p>
<p>const handleChange = (e) =&gt; setText(e.target.value);</p>
<p>const handleKeyDown = (e) =&gt; { // If the user pressed the Enter key: const trimmedText = text.trim(); if (e.which === 13 &amp;&amp; trimmedText) { // highlight-start // Create the thunk function with the text the user wrote const saveNewTodoThunk = saveNewTodo(trimmedText); // Then dispatch the thunk function itself dispatch(saveNewTodoThunk); // highlight-end setText(""); } };</p>
<p>// omit rendering output }; ```</p>
<p>Since we know we’re going to immediately pass the thunk function to <code>dispatch</code> in the component, we can skip creating the temporary variable. Instead, we can call <code>saveNewTodo(text)</code>, and pass the resulting thunk function straight to <code>dispatch</code>:</p>
<p><code>js title="src/features/header/Header.js" const handleKeyDown = (e) =&gt; {   // If the user pressed the Enter key:   const trimmedText = text.trim();   if (e.which === 13 &amp;&amp; trimmedText) {     // highlight-start     // Create the thunk function and immediately dispatch it     dispatch(saveNewTodo(trimmedText));     // highlight-end     setText("");   } };</code></p>
<p>Now the component doesn’t actually know that it’s even dispatching a thunk function - the <code>saveNewTodo</code> function is encapsulating what’s actually happening. The <code>&lt;Header&gt;</code> component only knows that it needs to dispatch <em>some value</em> when the user presses enter.</p>
<p>This pattern of writing a function to prepare something that will get passed to <code>dispatch</code> is called <strong>the “action creator” pattern</strong>, and we’ll talk about that more in <a href="./part-7-standard-patterns.md">the next section</a>.</p>
<p>We can now see the updated <code>'todos/todoAdded'</code> action being dispatched:</p>
<figure>
<img src="/img/tutorials/fundamentals/devtools-async-todoAdded-action.png" alt="Devtools - async todoAdded action contents" /><figcaption>Devtools - async todoAdded action contents</figcaption>
</figure>
<p>The last thing we need to change here is updating our todos reducer. When we make a POST request to <code>/fakeApi/todos</code>, the server will return a completely new todo object (including a new ID value). That means our reducer doesn’t have to calculate a new ID, or fill out the other fields - it only needs to create a new <code>state</code> array that includes the new todo item:</p>
<p>```js title=“src/features/todos/todosSlice.js” const initialState = [];</p>
<p>export default function todosReducer(state = initialState, action) { switch (action.type) { // highlight-start case “todos/todoAdded”: { // Return a new todos state array with the new todo item at the end return […state, action.payload]; } // highlight-end // omit other cases default: return state; } } ```</p>
<p>And now adding a new todo will work correctly:</p>
<figure>
<img src="/img/tutorials/fundamentals/devtools-async-todoAdded-diff.png" alt="Devtools - async todoAdded state diff" /><figcaption>Devtools - async todoAdded state diff</figcaption>
</figure>
<div class="tip">
<p>Thunk functions can be used for both asynchronous <em>and</em> synchronous logic. Thunks provide a way to write any reusable logic that needs access to <code>dispatch</code> and <code>getState</code>.</p>
</div>
<h2 id="what-youve-learned-5">What You’ve Learned</h2>
<p>We’ve now succesfully updated our todo app so that we can fetch a list of todo items and save new todo items, using “thunk” functions to make the AJAX calls to our fake server API.</p>
<p>In the process, we saw how Redux middleware are used to let us make async calls and interact with the store by dispatching actions with after the async calls have completed.</p>
<p>Here’s what the current app looks like:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-6-asyncThunks/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux middleware were designed to enable writing logic that has side effects</strong>
<ul>
<li>“Side effects” are code that changes state/behavior outside a function, like AJAX calls, modifying function arguments, or generating random values</li>
</ul></li>
<li><strong>Middleware add an extra step to the standard Redux data flow</strong>
<ul>
<li>Middleware can intercept other values passed to <code>dispatch</code></li>
<li>Middleware have access to <code>dispatch</code> and <code>getState</code>, so they can dispatch more actions as part of async logic</li>
</ul></li>
<li><strong>The Redux “Thunk” middleware lets us pass functions to <code>dispatch</code></strong>
<ul>
<li>“Thunk” functions let us write async logic ahead of time, without knowing what Redux store is being used</li>
<li>A Redux thunk function receives <code>dispatch</code> and <code>getState</code> as arguments, and can dispatch actions like “this data was received from an API response”</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-5">What’s Next?</h2>
<p>We’ve now covered all the core pieces of how to use Redux! You’ve seen how to:</p>
<ul>
<li>Write reducers that update state based on dispatched actions,</li>
<li>Create and configure a Redux store with a reducer, enhancers, and middleware</li>
<li>Use middleware to write async logic that dispatches actions</li>
</ul>
<p>In <a href="./part-7-standard-patterns.md">Part 7: Standard Redux Patterns</a>, we’ll look at several code patterns that are typically used by real-world Redux apps to make our code more consistent and scale better as the application grows.</p>
<hr />
<p>id: part-7-standard-patterns title: ‘Redux Fundamentals, Part 7: Standard Redux Patterns’ sidebar_label: ‘Standard Redux Patterns’ description: ‘The official Fundamentals tutorial for Redux: learn the standard patterns used in real-world Redux apps’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-7-standard-redux-patterns">Redux Fundamentals, Part 7: Standard Redux Patterns</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>Standard patterns used in real-world Redux apps, and why those patterns exist:
<ul>
<li>Action creators for encapsulating action objects</li>
<li>Memoized selectors for improving performance</li>
<li>Tracking request status via loading enums</li>
<li>Normalizing state for managing collections of items</li>
<li>Working with promises and thunks</li>
</ul></li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Understanding the topics in all previous sections</li>
</ul>
<p>:::</p>
<p>In <a href="./part-6-async-logic.md">Part 6: Async Logic and Data Fetching</a>, we saw how to use Redux middleware to write async logic that can talk to the store. In particular, we used the Redux “thunk” middleware to write functions that can contain reusable async logic, without knowing what Redux store they’ll be talking to ahead of time.</p>
<p>So far, we’ve covered the basics of how Redux actually works. However, real world Redux applications use some additional patterns on top of those basics.</p>
<p>It’s important to note that <strong>none of these patterns are <em>required</em> to use Redux!</strong> But, there are very good reasons why each of these patterns exists, and you’ll see some or all of them in almost every Redux codebase.</p>
<p>In this section, we’ll rework our existing todo app code to use some of these patterns, and talk about why they’re commonly used in Redux apps. Then, in <a href="./part-8-modern-redux.md"><strong>Part 8</strong></a>, we’ll talk about “modern Redux”, including <strong>how to use our official <a href="https://redux-toolkit.js.org">Redux Toolkit</a> package to simplify all the Redux logic we’ve written “by hand”</strong> in our app, and why <strong>we recommend using Redux Toolkit as the standard approach for writing Redux apps</strong>.</p>
<h2 id="action-creators-1">Action Creators</h2>
<p>In our app, we’ve been writing action objects directly in the code, where they’re being dispatched:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb243-1" title="1"><span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todoAdded&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> trimmedText <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>However, in practice, well-written Redux apps don’t actually write those action objects inline when we dispatch them. Instead, we use “action creator” functions.</p>
<p>An <strong>action creator</strong> is a function that creates and returns an action object. We typically use these so we don’t have to write the action object by hand every time:</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb244-1" title="1"><span class="kw">const</span> todoAdded <span class="op">=</span> (text) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb244-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb244-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todoAdded&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb244-4" title="4">    <span class="dt">payload</span><span class="op">:</span> text<span class="op">,</span></a>
<a class="sourceLine" id="cb244-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb244-6" title="6"><span class="op">};</span></a></code></pre></div>
<p>We then use them by <strong>calling the action creator</strong>, and then <strong>passing the resulting action object directly to <code>dispatch</code></strong>:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb245-1" title="1"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">todoAdded</span>(<span class="st">&quot;Buy milk&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb245-2" title="2"></a>
<a class="sourceLine" id="cb245-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>().<span class="at">todos</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb245-4" title="4"><span class="co">// [ {id: 0, text: &#39;Buy milk&#39;, completed: false}]</span></a></code></pre></div>
<p><DetailedExplanation title="Detailed Explanation: Why use Action Creators?"></p>
<p>In our small example todo app, writing action objects by hand every time isn’t too difficult. In fact, by switching to using action creators, we’ve added <em>more</em> work - now we have to write a function <em>and</em> the action object.</p>
<p>But, what if we needed to dispatch the same action from many parts of the application? Or what if there’s some additional logic that we have to do every time we dispatch an action, like creating a unique ID? We’d end up having to copy-paste the additional setup logic every time we need to dispatch that action.</p>
<p>Action creators have two primary purposes:</p>
<ul>
<li>They prepare and format the contents of action objects</li>
<li>They encapsulate any additional work needed whenever we create those actions</li>
</ul>
<p>That way, we have a consistent approach for creating actions, whether or not there’s any extra work that needs to be done. The same goes for thunks as well.</p>
<p></DetailedExplanation></p>
<h3 id="using-action-creators">Using Action Creators</h3>
<p>Let’s update our todos slice file to use action creators for a couple of our action types.</p>
<p>We’ll start with the two main actions we’ve been using so far: loading the list of todos from the server, and adding a new todo after saving it to the server.</p>
<p>Right now, <code>todosSlice.js</code> is dispatching an action object directly, like this:</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb246-1" title="1"><span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todosLoaded&quot;</span><span class="op">,</span> <span class="dt">payload</span><span class="op">:</span> <span class="va">response</span>.<span class="at">todos</span> <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>We’ll create a function that creates and returns that same kind of action object, but accepts the array of todos as its argument and puts it into the action as <code>action.payload</code>. Then, we can dispatch the action using that new action creator inside of our <code>fetchTodos</code> thunk:</p>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-start export const todosLoaded = (todos) =&gt; { return { type: “todos/todosLoaded”, payload: todos, }; }; // highlight-end</p>
<p>export async function fetchTodos(dispatch, getState) { const response = await client.get(“/fakeApi/todos”); // highlight-next-line dispatch(todosLoaded(response.todos)); } ```</p>
<p>We can also do the same thing for the “todo added” action:</p>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-start export const todoAdded = (todo) =&gt; { return { type: “todos/todoAdded”, payload: todo, }; }; // highlight-end</p>
<p>export function saveNewTodo(text) { return async function saveNewTodoThunk(dispatch, getState) { const initialTodo = { text }; const response = await client.post(“/fakeApi/todos”, { todo: initialTodo }); // highlight-next-line dispatch(todoAdded(response.todo)); }; } ```</p>
<p>While we’re at it, let’s do the same thing for the “color filter changed” action:</p>
<p><code>js title="src/features/filters/filtersSlice.js" // highlight-start export const colorFilterChanged = (color, changeType) =&gt; {   return {     type: "filters/colorFilterChanged",     payload: { color, changeType },   }; }; // highlight-end</code></p>
<p>And since this action was being dispatched from the <code>&lt;Footer&gt;</code> component, we’ll need to import the <code>colorFilterChanged</code> action creator over there and use it:</p>
<p>```js title=“src/features/footer/Footer.js” import React from “react”; import { useSelector, useDispatch } from “react-redux”;</p>
<p>import { availableColors, capitalize } from “../filters/colors”; // highlight-next-line import { StatusFilters, colorFilterChanged } from “../filters/filtersSlice”;</p>
<p>// omit child components</p>
<p>const Footer = () =&gt; { const dispatch = useDispatch();</p>
<p>const todosRemaining = useSelector((state) =&gt; { const uncompletedTodos = state.todos.filter((todo) =&gt; !todo.completed); return uncompletedTodos.length; });</p>
<p>const { status, colors } = useSelector((state) =&gt; state.filters);</p>
<p>const onMarkCompletedClicked = () =&gt; dispatch({ type: “todos/allCompleted” }); const onClearCompletedClicked = () =&gt; dispatch({ type: “todos/completedCleared” });</p>
<p>// highlight-start const onColorChange = (color, changeType) =&gt; dispatch(colorFilterChanged(color, changeType)); // highlight-end</p>
<p>const onStatusChange = (status) =&gt; dispatch({ type: “filters/statusFilterChanged”, payload: status });</p>
<p>// omit rendering output };</p>
<p>export default Footer; ```</p>
<p>Notice that the <code>colorFilterChanged</code> action creator actually accepts two different arguments, and then combines them together to form the right <code>action.payload</code> field.</p>
<p>This doesn’t change anything about how the application works, or how the Redux data flow behaves - we’re still creating action objects, and dispatching them. But, instead of writing action objects directly in our code all the time, we’re now using action creators to prepare those action objects before they’re dispatched.</p>
<p>We can also use action creators with thunk functions, and in fact <a href="./part-6-async-logic.md#saving-todo-items">we wrapped a thunk in an action creator in the previous section</a> . We specifically wrapped <code>saveNewTodo</code> in a “thunk action creator” function so that we could pass in a <code>text</code> parameter. While <code>fetchTodos</code> doesn’t take any parameters, we could still wrap it in an action creator as well:</p>
<p><code>js title="src/features/todos/todosSlice.js" // highlight-next-line export function fetchTodos() {   return async function fetchTodosThunk(dispatch, getState) {     const response = await client.get("/fakeApi/todos");     dispatch(todosLoaded(response.todos));   }; }</code></p>
<p>And that means we have to change the place it’s dispatched in <code>index.js</code> to call the outer thunk action creator function, and pass the returned inner thunk function to <code>dispatch</code>:</p>
<p>```js title=“src/index.js” import store from “./store”; import { fetchTodos } from “./features/todos/todosSlice”;</p>
<p>// highlight-next-line store.dispatch(fetchTodos()); ```</p>
<p>We’ve written thunks using the <code>function</code> keyword so far to make it clear what they’re doing. However, we can also write them using arrow function syntax instead. Using implicit returns can shorten the code, although it may make it a bit harder to read as well if you’re not familiar with arrow functions:</p>
<p><code>js title="src/features/todos/todosSlice.js" // Same thing as the above example! // highlight-next-line export const fetchTodos = () =&gt; async (dispatch) =&gt; {   const response = await client.get("/fakeApi/todos");   dispatch(todosLoaded(response.todos)); };</code></p>
<p>Similarly, we <em>could</em> shorten the plain action creators if we wanted to:</p>
<p><code>js title="src/features/todos/todosSlice.js" // highlight-next-line export const todoAdded = (todo) =&gt; ({ type: "todos/todoAdded", payload: todo });</code></p>
<p>It’s up to you to decide whether using arrow functions this way is better or not.</p>
<div class="info">
<p>For more details on why action creators are useful, see:</p>
<ul>
<li><a href="https://blog.isquaredsoftware.com/2016/10/idiomatic-redux-why-use-action-creators/">Idiomatic Redux: Why Use Action Creators?</a></li>
</ul>
</div>
<h2 id="memoized-selectors">Memoized Selectors</h2>
<p>We’ve already seen that we can write “selector” functions, which accept the Redux <code>state</code> object as an argument, and return a value:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb247-1" title="1"><span class="kw">const</span> selectTodos <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">todos</span><span class="op">;</span></a></code></pre></div>
<p>What if we need to <em>derive</em> some data? For example, maybe we want to have an array of only the todo IDs:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb248-1" title="1"><span class="kw">const</span> selectTodoIds <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="at">map</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">id</span>)<span class="op">;</span></a></code></pre></div>
<p>However, <code>array.map()</code> always returns a new array reference. We know that the React-Redux <code>useSelector</code> hook will re-run its selector function after <em>every</em> dispatched action, and if the selector result changes, it will force the component to re-render.</p>
<p>In this example, <strong>calling <code>useSelector(selectTodoIds)</code> will <em>always</em> cause the component to re-render after <em>every</em> action, because it’s returning a new array reference!</strong></p>
<p>In Part 5, we saw that <a href="./part-5-ui-and-react.md#selecting-data-in-list-items-by-id">we can pass <code>shallowEqual</code> as an argument to <code>useSelector</code></a>. There’s another option here, though: we could use “memoized” selectors.</p>
<p><strong>Memoization</strong> is a kind of caching - specifically, saving the results of an expensive calculation, and reusing those results if we see the same inputs later.</p>
<p><strong>Memoized selector functions</strong> are selectors that save the most recent result value, and if you call them multiple times with the same inputs, will return the same result value. If you call them with <em>different</em> inputs than last time, they will recalculate a new result value, cache it, and return the new result.</p>
<h3 id="memoizing-selectors-with-createselector">Memoizing Selectors with <code>createSelector</code></h3>
<p>The <strong><a href="https://github.com/reduxjs/reselect">Reselect library</a> provides a <code>createSelector</code> API that will generate memoized selector functions</strong>. <code>createSelector</code> accepts one or more “input selector” functions as arguments, plus an “output selector”, and returns the new selector function. Every time you call the selector:</p>
<ul>
<li>All “input selectors” are called with all of the arguments</li>
<li>If any of the input selector return values have changed, the “output selector” will re-run</li>
<li>All of the input selector results become arguments to the output selector</li>
<li>The final result of the output selector is cached for next time</li>
</ul>
<p>Let’s create a memoized version of <code>selectTodoIds</code> and use that with our <code>&lt;TodoList&gt;</code>.</p>
<p>First, we need to install Reselect:</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb249-1" title="1"><span class="ex">npm</span> install reselect</a></code></pre></div>
<p>Then, we can import and call <code>createSelector</code>. Our original <code>selectTodoIds</code> function was defined over in <code>TodoList.js</code>, but it’s more common for selector functions to be written in the relevant slice file. So, let’s add this to the todos slice:</p>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-next-line import { createSelector } from “reselect”;</p>
<p>// omit reducer</p>
<p>// omit action creators</p>
<p>// highlight-start export const selectTodoIds = createSelector( // First, pass one or more “input selector” functions: (state) =&gt; state.todos, // Then, an “output selector” that receives all the input results as arguments // and returns a final result value (todos) =&gt; todos.map((todo) =&gt; todo.id) ); // highlight-end ```</p>
<p>Then, let’s use it in <code>&lt;TodoList&gt;</code>:</p>
<p>```js title=“src/features/todos/TodoList.js” import React from “react”; import { useSelector, shallowEqual } from “react-redux”;</p>
<p>// highlight-next-line import { selectTodoIds } from “./todosSlice”; import TodoListItem from “./TodoListItem”;</p>
<p>const TodoList = () =&gt; { // highlight-next-line const todoIds = useSelector(selectTodoIds);</p>
<p>const renderedListItems = todoIds.map((todoId) =&gt; { return <TodoListItem key={todoId} id={todoId} />; });</p>
return
<ul className="todo-list">
{renderedListItems}
</ul>
<p>; }; ```</p>
<p>This actually behaves a bit differently than the <code>shallowEqual</code> comparison function does. Any time the <code>state.todos</code> array changes, we’re going to create a new todo IDs array as a result. That includes any immutable updates to todo items like toggling their <code>completed</code> field, since we have to create a new array for the immutable update.</p>
<div class="tip">
<p>Memoized selectors are only helpful when you actually derive additional values from the original data. If you are only looking up and returning an existing value, you can keep the selector as a plain function.</p>
</div>
<h3 id="selectors-with-multiple-arguments">Selectors with Multiple Arguments</h3>
<p>Our todo app is supposed to have the ability to filter the visible todos based on their completed status. Let’s write a memoized selector that returns that filtered list of todos.</p>
<p>We know we need the entire <code>todos</code> array as one argument to our output selector. We also need to pass in the current completion status filter value as well. We’ll add a separate “input selector” to extract each value, and pass the results to the “output selector”.</p>
<p>```js title=“src/features/todos/todosSlice.js” import { createSelector } from “reselect”; import { StatusFilters } from “../filters/filtersSlice”;</p>
<p>// omit other code</p>
<p>// highlight-start export const selectFilteredTodos = createSelector( // First input selector: all todos (state) =&gt; state.todos, // Second input selector: current status filter (state) =&gt; state.filters.status, // Output selector: receives both values (todos, status) =&gt; { if (status === StatusFilters.All) { return todos; }</p>
<p>const completedStatus = status === StatusFilters.Completed; // Return either active or completed todos based on filter return todos.filter((todo) =&gt; todo.completed === completedStatus); } ); // highlight-end ```</p>
<div class="caution">
<p>Note that we’ve now added an import dependency between two slices - the <code>todosSlice</code> is importing a value from the <code>filtersSlice</code>. This is legal, but be careful. <strong>If two slices <em>both</em> try to import something from each other, you can end up with a “cyclic import dependency” problem that can cause your code to crash</strong>. If that happens, try moving some common code to its own file and import from that file instead.</p>
</div>
<p>Now we can use this new “filtered todos” selector as an input to another selector that returns the IDs of those todos:</p>
<p><code>js title="src/features/todos/todosSlice.js" export const selectFilteredTodoIds = createSelector(   // Pass our other memoized selector as an input   selectFilteredTodos,   // And derive data in the output selector   (filteredTodos) =&gt; filteredTodos.map((todo) =&gt; todo.id) );</code></p>
<p>If we switch <code>&lt;TodoList&gt;</code> to use <code>selectFilteredTodoIds</code>, we should then be able to mark a couple todo items as completed:</p>
<figure>
<img src="/img/tutorials/fundamentals/todos-app-markedCompleted.png" alt="Todo app - todos marked completed" /><figcaption>Todo app - todos marked completed</figcaption>
</figure>
<p>and then filter the list to <em>only</em> show completed todos:</p>
<figure>
<img src="/img/tutorials/fundamentals/todos-app-showCompleted.png" alt="Todo app - todos marked completed" /><figcaption>Todo app - todos marked completed</figcaption>
</figure>
<p>We can then expand our <code>selectFilteredTodos</code> to also include color filtering in the selection as well:</p>
<p>```js title=“src/features/todos/todosSlice.js” export const selectFilteredTodos = createSelector( // First input selector: all todos selectTodos, // Second input selector: all filter values // highlight-next-line (state) =&gt; state.filters, // Output selector: receives both values (todos, filters) =&gt; { // highlight-start const { status, colors } = filters; const showAllCompletions = status === StatusFilters.All; if (showAllCompletions &amp;&amp; colors.length === 0) { // highlight-end return todos; }</p>
<p>// highlight-next-line const completedStatus = status === StatusFilters.Completed; // Return either active or completed todos based on filter return todos.filter((todo) =&gt; { // highlight-start const statusMatches = showAllCompletions || todo.completed === completedStatus; const colorMatches = colors.length === 0 || colors.includes(todo.color); return statusMatches &amp;&amp; colorMatches; // highlight-end }); } ); ```</p>
<p>Notice that by encapsulating the logic in this selector, our component never needed to change, even as we changed the filtering behavior. Now we can filter by both status and color at once:</p>
<figure>
<img src="/img/tutorials/fundamentals/todos-app-selectorFilters.png" alt="Todo app - status and color filters" /><figcaption>Todo app - status and color filters</figcaption>
</figure>
<p>Finally, we’ve got several places where our code is looking up <code>state.todos</code>. We’re going to be making some changes to how that state is designed as we go through the rest of this section, so we’ll extract a single <code>selectTodos</code> selector and use that everywhere. We can also move <code>selectTodoById</code> over into the <code>todosSlice</code>:</p>
<p>```js title=“src/features/todos/todosSlice.js” export const selectTodos = (state) =&gt; state.todos;</p>
<p>export const selectTodoById = (state, todoId) =&gt; { return selectTodos(state).find((todo) =&gt; todo.id === todoId); }; ```</p>
<div class="info">
<p>For more details on why we use selector functions and how to write memoized selectors with Reselect, see:</p>
<ul>
<li><a href="../../usage/deriving-data-selectors.md">Using Redux: Deriving Data with Selectors</a></li>
</ul>
</div>
<h2 id="async-request-status">Async Request Status</h2>
<p>We’re using an async thunk to fetch the initial list of todos from the server. Since we’re using a fake server API, that response comes back immediately. In a real app, the API call might take a while to resolve. In that case, it’s common to show some kind of a loading spinner while we wait for the response to complete.</p>
<p>This is usually handled in Redux apps by:</p>
<ul>
<li>Having some kind of “loading state” value to indicate the current status of a request</li>
<li>Dispatching a “request started” action <em>before</em> making the API call, which is handled by changing the loading state value</li>
<li>Updating the loading state value again when the request completes to indicate that the call is done</li>
</ul>
<p>The UI layer then shows a loading spinner while the request is in progress, and switches to showing the actual data when the request is complete.</p>
<p>We’re going to update our todos slice to track a loading state value, and dispatch an additional <code>'todos/todosLoading'</code> action as part of the <code>fetchTodos</code> thunk.</p>
<p>Right now, the <code>state</code> of our todos reducer is only the array of todos itself. If we want to track the loading state inside the todos slice, we’ll need to reorganize the todos state to be an object that has the todos array <em>and</em> the loading state value. That also means rewriting the reducer logic to handle the additional nesting:</p>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-start const initialState = { status: “idle”, entities: [], }; // highlight-end</p>
<p>export default function todosReducer(state = initialState, action) { switch (action.type) { case “todos/todoAdded”: { // highlight-start return { …state, entities: […state.entities, action.payload], }; // highlight-end } case “todos/todoToggled”: { // highlight-start return { …state, entities: state.entities.map((todo) =&gt; { if (todo.id !== action.payload) { return todo; }</p>
<pre><code>return {
        ...todo,
        completed: !todo.completed,
      };
    }),
  };
  // highlight-end
}
// omit other cases
default:
  return state;</code></pre>
<p>} }</p>
<p>// omit action creators</p>
<p>// highlight-next-line export const selectTodos = (state) =&gt; state.todos.entities; ```</p>
<p>There’s a few important things to note here:</p>
<ul>
<li>The todos array is now nested as <code>state.entities</code> in the <code>todosReducer</code> state object. The word “entities” is a term that means “unique items with an ID”, which does describe our todo objects.</li>
<li>That also means the array is nested in the <em>entire</em> Redux state object as <code>state.todos.entities</code></li>
<li>We now have to do extra steps in the reducer to copy the additional level of nesting for correct immutable updates, such as <code>state</code> object -&gt; <code>entities</code> array -&gt; <code>todo</code> object</li>
<li>Because the rest of our code is <em>only</em> accessing the todos state via selectors, <strong>we only need to update the <code>selectTodos</code> selector</strong> - the rest of the UI will continue to work as expected even though we reshaped our state considerably.</li>
</ul>
<h3 id="loading-state-enum-values">Loading State Enum Values</h3>
<p>You’ll also notice that we’ve defined the loading state field as a string enum:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb251-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb251-2" title="2">  <span class="dt">status</span><span class="op">:</span> <span class="st">&quot;idle&quot;</span><span class="op">;</span> <span class="co">// or: &#39;loading&#39;, &#39;succeeded&#39;, &#39;failed&#39;</span></a>
<a class="sourceLine" id="cb251-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>instead of an <code>isLoading</code> boolean.</p>
<p>A boolean limits us to two possibilities: “loading” or “not loading”. In reality, <strong>it’s possible for a request to actually be in <em>many</em> different states</strong>, such as:</p>
<ul>
<li>Hasn’t started at all</li>
<li>In progress</li>
<li>Succeeded</li>
<li>Failed</li>
<li>Succeeded, but now back in a situation where we might want to refetch</li>
</ul>
<p>It’s also possible that the app logic should only transition between specific states based on certain actions, and this is harder to implement using booleans.</p>
<p>Because of this, we recommend <strong>storing loading state as a string enum value instead of boolean flags</strong>.</p>
<div class="info">
<p>For a detailed explanation of why loading states should be enums, see:</p>
<ul>
<li><a href="../../style-guide/style-guide.md#treat-reducers-as-state-machines">Redux Style Guide: treat reducers as state machines</a></li>
</ul>
</div>
<p>Based on that, we’ll add a new “loading” action that will set our status to <code>'loading'</code>, and update the “loaded” action to reset the state flag to <code>'idle'</code>:</p>
<p>```js title=“src/features/todos/todosSlice.js” const initialState = { status: “idle”, entities: [], };</p>
<p>export default function todosReducer(state = initialState, action) { switch (action.type) { // omit other cases // highlight-start case “todos/todosLoading”: { return { …state, status: “loading”, }; } // highlight-end case “todos/todosLoaded”: { return { …state, // highlight-next-line status: “idle”, entities: action.payload, }; } default: return state; } }</p>
<p>// omit action creators</p>
<p>// Thunk function export const fetchTodos = () =&gt; async (dispatch) =&gt; { // highlight-next-line dispatch(todosLoading()); const response = await client.get(“/fakeApi/todos”); dispatch(todosLoaded(response.todos)); }; ```</p>
<p>However, before we try to show this in the UI, we need to modify the fake server API to add an artificial delay to our API calls. Open up <code>src/api/server.js</code>, and look for this commented-out line around line 63:</p>
<p>```js title=“src/api/server.js” new Server({ routes() { this.namespace = “fakeApi”; // highlight-next-line // this.timing = 2000</p>
<p>// omit other code }, }); ```</p>
<p>If you uncomment that line, the fake server will add a 2-second delay to every API call our app makes, which gives us enough time to actually see a loading spinner being displayed.</p>
<p>Now, we can read the loading state value in our <code>&lt;TodoList&gt;</code> component, and show a loading spinner instead based on that value.</p>
<p>```js title=“src/features/todos/TodoList.js” // omit imports</p>
<p>const TodoList = () =&gt; { const todoIds = useSelector(selectFilteredTodoIds); // highlight-start const loadingStatus = useSelector((state) =&gt; state.todos.status);</p>
if (loadingStatus === “loading”) { return (
<div className="todo-list">
<pre><code>    &lt;div className=&quot;loader&quot; /&gt;
  &lt;/div&gt;
);</code></pre>
<p>} // highlight-end</p>
<p>const renderedListItems = todoIds.map((todoId) =&gt; { return <TodoListItem key={todoId} id={todoId} />; });</p>
return
<ul className="todo-list">
{renderedListItems}
</ul>
<p>; }; ```</p>
<p>In a real app, we’d also want to handle API failure errors and other potential cases.</p>
<p>Here’s what the app looks like with that loading status enabled (to see the spinner again, reload the app preview or open it in a new tab):</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-7-asyncLoading/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<h2 id="flux-standard-actions">Flux Standard Actions</h2>
<p>The Redux store itself does not actually care what fields you put into your action object. It only cares that <code>action.type</code> exists and has a value, and normal Redux actions always use a string for <code>action.type</code>. That means that you <em>could</em> put any other fields into the action that you want. Maybe we could have <code>action.todo</code> for a “todo added” action, or <code>action.color</code>, and so on.</p>
<p>However, if every action uses different field names for its data fields, it can be hard to know ahead of time what fields you need to handle in each reducer.</p>
<p>That’s why the Redux community came up with <a href="https://github.com/redux-utilities/flux-standard-action#motivation">the “Flux Standard Actions” convention</a>, or “FSA”. This is a suggested approach for how to organize fields inside of action objects, so that developers always know what fields contain what kind of data. The FSA pattern is widely used in the Redux community, and in fact you’ve already been using it throughout this whole tutorial.</p>
<p>The FSA convention says that:</p>
<ul>
<li>If your action object has any actual data, that “data” value of your action should always go in <code>action.payload</code></li>
<li>An action may also have an <code>action.meta</code> field with extra descriptive data</li>
<li>An action may have an <code>action.error</code> field with error information</li>
</ul>
<p>So, <em>all</em> Redux actions MUST:</p>
<ul>
<li>be a plain JavaScript object</li>
<li>have a <code>type</code> field</li>
</ul>
<p>And if you write your actions using the FSA pattern, an action MAY</p>
<ul>
<li>have a <code>payload</code> field</li>
<li>have an <code>error</code> field</li>
<li>have a <code>meta</code> field</li>
</ul>
<p><DetailedExplanation title="Detailed Explanation: FSAs and Errors"></p>
<p>The FSA specification says that:</p>
<blockquote>
<p>The optional <code>error</code> property MAY be set to <code>true</code> if the action represents an error. An action whose <code>error</code> is true is analogous to a rejected Promise. By convention, the <code>payload</code> SHOULD be an error object. If <code>error</code> has any other value besides <code>true</code>, including <code>undefined</code> and <code>null</code>, the action MUST NOT be interpreted as an error.</p>
</blockquote>
<p>The FSA specs also argue against having specific action types for things like “loading succeeded” and “loading failed”.</p>
<p>However, in practice, the Redux community has ignored the idea of using <code>action.error</code> as a boolean flag, and instead settled on separate action types, like <code>'todos/todosLoadingSucceeded'</code> and <code>'todos/todosLoadingFailed'</code>. This is because it’s much easier to check for those action types than it is to first handle <code>'todos/todosLoaded'</code> and <em>then</em> check <code>if (action.error)</code>.</p>
<p>You can do whichever approach works better for you, but most apps use separate action types for success and failure.</p>
<p></DetailedExplanation></p>
<h2 id="normalized-state">Normalized State</h2>
<p>So far, we’ve kept our todos in an array. This is reasonable, because we received the data from the server as an array, and we also need to loop over the todos to show them as a list in the UI.</p>
<p>However, in larger Redux apps, it is common to store data in a <strong>normalized state structure</strong>. “Normalization” means:</p>
<ul>
<li>Making sure there is only one copy of each piece of data</li>
<li>Storing items in a way that allows directly finding items by ID</li>
<li>Referring to other items based on IDs, instead of copying the entire item</li>
</ul>
<p>For example, in a blogging application, you might have <code>Post</code> objects that point to <code>User</code> and <code>Comment</code> objects. There might be many posts by the same person, so if every <code>Post</code> object includes an entire <code>User</code>, we would have many copies of the same <code>User</code> object. Instead, a <code>Post</code> object would have a user ID value as <code>post.user</code>, and then we could look up <code>User</code> objects by ID as <code>state.users[post.user]</code>.</p>
<p>This means we typically organize our data as objects instead of arrays, where the item IDs are the keys and the items themselves are the values, like this:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb253-1" title="1"><span class="kw">const</span> rootState <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb253-2" title="2">  <span class="dt">todos</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb253-3" title="3">    <span class="dt">status</span><span class="op">:</span> <span class="st">&quot;idle&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb253-4" title="4">    <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb253-5" title="5">    <span class="dt">entities</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb253-6" title="6">      <span class="dv">2</span><span class="op">:</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Buy milk&quot;</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">false</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb253-7" title="7">      <span class="dv">7</span><span class="op">:</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">7</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&quot;Clean room&quot;</span><span class="op">,</span> <span class="dt">completed</span><span class="op">:</span> <span class="kw">true</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb253-8" title="8">    <span class="op">},</span></a>
<a class="sourceLine" id="cb253-9" title="9">    <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb253-10" title="10">  <span class="op">},</span></a>
<a class="sourceLine" id="cb253-11" title="11"><span class="op">};</span></a></code></pre></div>
<p>Let’s convert our todos slice to store the todos in a normalized form. This will require some significant changes to our reducer logic, as well as updating the selectors:</p>
<p>```js title=“src/features/todos/todosSlice” const initialState = { status: “idle”, // highlight-next-line entities: {}, };</p>
<p>export default function todosReducer(state = initialState, action) { switch (action.type) { case “todos/todoAdded”: { const todo = action.payload; // highlight-start return { …state, entities: { …state.entities, [todo.id]: todo, }, }; // highlight-end } case “todos/todoToggled”: { // highlight-start const todoId = action.payload; const todo = state.entities[todoId]; return { …state, entities: { …state.entities, [todoId]: { …todo, completed: !todo.completed, }, }, }; // highlight-end } case “todos/colorSelected”: { // highlight-start const { color, todoId } = action.payload; const todo = state.entities[todoId]; return { …state, entities: { …state.entities, [todoId]: { …todo, color, }, }, }; // highlight-end } case “todos/todoDeleted”: { // highlight-start const newEntities = { …state.entities }; delete newEntities[action.payload]; return { …state, entities: newEntities, }; // highlight-end } case “todos/allCompleted”: { // highlight-start const newEntities = { …state.entities }; Object.values(newEntities).forEach((todo) =&gt; { newEntities[todo.id] = { …todo, completed: true, }; }); return { …state, entities: newEntities, }; // highlight-end } case “todos/completedCleared”: { // highlight-start const newEntities = { …state.entities }; Object.values(newEntities).forEach((todo) =&gt; { if (todo.completed) { delete newEntities[todo.id]; } }); return { …state, entities: newEntities, }; // highlight-end } case “todos/todosLoading”: { return { …state, status: “loading”, }; } case “todos/todosLoaded”: { // highlight-start const newEntities = {}; action.payload.forEach((todo) =&gt; { newEntities[todo.id] = todo; }); return { …state, status: “idle”, entities: newEntities, }; // highlight-end } default: return state; } }</p>
<p>// omit action creators</p>
<p>// highlight-start const selectTodoEntities = (state) =&gt; state.todos.entities;</p>
<p>export const selectTodos = createSelector(selectTodoEntities, (entities) =&gt; Object.values(entities) );</p>
<p>export const selectTodoById = (state, todoId) =&gt; { return selectTodoEntities(state)[todoId]; }; // highlight-end ```</p>
<p>Because our <code>state.entities</code> field is now an object instead of an array, we have to use nested object spread operators to update the data instead of array operations. Also, we can’t loop over objects the way we loop over arrays, so there’s several places where we have to use <code>Object.values(entities)</code> to get an array of the todo items so that we can loop over them.</p>
<p>The good news is that because we’re using selectors to encapsulate the state lookups, our UI still doesn’t have to change. The bad news is that the reducer code is actually longer and more complicated.</p>
<p>Part of the issue here is that <strong>this todo app example is not a large real-world application</strong>. So, normalizing state is not as useful in this particular app, and it’s harder to see the potential benefits.</p>
<p>Fortunately, in <a href="part-8-modern-redux.md">Part 8: Modern Redux with Redux Toolkit</a> we’ll see some ways to drastically shorten the reducer logic for managing our normalized state.</p>
<p>For now, the important things to understand are:</p>
<ul>
<li>Normalization <em>is</em> commonly used in Redux apps</li>
<li>The primary benefits are being able to look up individual items by ID and ensure that only one copy of an item exists in the state</li>
</ul>
<div class="info">
<p>For more details on why normalization is useful with Redux, see:</p>
<ul>
<li><a href="../../usage/structuring-reducers/NormalizingStateShape.md">Structuring Reducers: Normalizing State Shape</a></li>
</ul>
</div>
<h2 id="thunks-and-promises">Thunks and Promises</h2>
<p>We have one last pattern to look at for this section. We’ve already seen how to handle loading state in the Redux store based on dispatched actions. What if we need to look at the results of a thunk in our components?</p>
<p>Whenever you call <code>store.dispatch(action)</code>, <code>dispatch</code> will actually return the <code>action</code> as its result. Middleware can then modify that behavior and return some other value instead.</p>
<p>We’ve already seen that the Redux Thunk middleware lets us pass a function to <code>dispatch</code>, calls the function, and then returns the result:</p>
<p>``<code>js title="reduxThunkMiddleware.js" const reduxThunkMiddleware = (storeAPI) =&gt; (next) =&gt; (action) =&gt; {   // If the "action" is actually a function instead...   if (typeof action === "function") {     // then call the function and pass</code>dispatch<code>and</code>getState` as arguments // Also, return whatever the thunk function returns return action(storeAPI.dispatch, storeAPI.getState); }</p>
<p>// Otherwise, it’s a normal action - send it onwards return next(action); }; ```</p>
<p>This means that <strong>we can write thunk functions that return a promise, and wait on that promise in our components</strong>.</p>
<p>We already have our <code>&lt;Header&gt;</code> component dispatching a thunk to save new todo entries to the server. Let’s add some loading state inside the <code>&lt;Header&gt;</code> component, then disable the text input and show another loading spinner while we’re waiting for the server:</p>
<p>```js title=“src/features/header/Header.js” const Header = () =&gt; { const [text, setText] = useState("“); // highlight-next-line const [status, setStatus] = useState(”idle"); const dispatch = useDispatch();</p>
<p>const handleChange = (e) =&gt; setText(e.target.value);</p>
<p>// highlight-start const handleKeyDown = async (e) =&gt; { // If the user pressed the Enter key: const trimmedText = text.trim(); if (e.which === 13 &amp;&amp; trimmedText) { // Create and dispatch the thunk function itself setStatus(“loading”); // Wait for the promise returned by saveNewTodo await dispatch(saveNewTodo(trimmedText)); // And clear out the text input setText("“); setStatus(”idle"); } };</p>
let isLoading = status === “loading”; let placeholder = isLoading ? "" : “What needs to be done?”; let loader = isLoading ?
<div className="loader" />
<p>: null; // highlight-end</p>
return (
<header className="header">
<input
        className="new-todo"
        placeholder={placeholder}
        autoFocus={true}
        value={text}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        // highlight-next-line
        disabled={isLoading}
      /> // highlight-next-line {loader}
</header>
<p>); };</p>
<p>export default Header; ```</p>
<p>Now, if we add a todo, we’ll see a spinner in the header:</p>
<figure>
<img src="/img/tutorials/fundamentals/todos-app-headerLoading.png" alt="Todo app - component loading spinner" /><figcaption>Todo app - component loading spinner</figcaption>
</figure>
<h2 id="what-youve-learned-6">What You’ve Learned</h2>
<p>As you’ve seen, there’s several additional patterns that are widely used in Redux apps. These patterns are not required, and may involve writing more code initially, but they provide benefits like making logic reusable, encapsulating implementation details, improving app performance, and making it easier to look up data.</p>
<div class="info">
<p>For more details on why these patterns exist and how Redux is meant to be used, see:</p>
<ul>
<li><a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/">Idiomatic Redux: The Tao of Redux, Part 1 - Implementation and Intent</a></li>
<li><a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/">Idiomatic Redux: The Tao of Redux, Part 2 - Practice and Philosophy</a></li>
</ul>
</div>
<p>Here’s how our app looks after it’s been fully converted to use these patterns:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-8-normalizedState/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>:::tip Summary</p>
<ul>
<li><strong>Action creator functions encapsulate preparing action objects and thunks</strong>
<ul>
<li>Action creators can accept arguments and contain setup logic, and return the final action object or thunk function</li>
</ul></li>
<li><strong>Memoized selectors help improve Redux app performance</strong>
<ul>
<li>Reselect has a <code>createSelector</code> API that generates memoized selectors</li>
<li>Memoized selectors return the same result reference if given the same inputs</li>
</ul></li>
<li><strong>Request status should be stored as an enum, not booleans</strong>
<ul>
<li>Using enums like <code>'idle'</code> and <code>'loading'</code> helps track status consistently</li>
</ul></li>
<li><strong>“Flux Standard Actions” are the common convention for organizing action objects</strong>
<ul>
<li>Actions use <code>payload</code> for data, <code>meta</code> for extra descriptions, and <code>error</code> for errors</li>
</ul></li>
<li><strong>Normalized state makes it easier to find items by ID</strong>
<ul>
<li>Normalized data is stored in objects instead of arrays, with item IDs as keys</li>
</ul></li>
<li><strong>Thunks can return promises from <code>dispatch</code></strong>
<ul>
<li>Components can wait for async thunks to complete, then do more work</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-6">What’s Next?</h2>
<p>Writing all this code “by hand” can be time-consuming and difficult. <strong>That’s why we recommend that you use our official <a href="https://redux-toolkit.js.org">Redux Toolkit</a> package to write your Redux logic instead</strong>.</p>
<p>Redux Toolkit includes APIs that <strong>help you write all the typical Redux usage patterns, but with less code</strong>. It also helps <strong>prevent common mistakes</strong> like accidentally mutating state.</p>
<p>In <a href="./part-8-modern-redux.md">Part 8: Modern Redux</a>, we’ll cover how to use Redux Toolkit to simplify all the code we’ve written so far.</p>
<hr />
<p>id: part-8-modern-redux title: ‘Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit’ sidebar_label: ‘Modern Redux with Redux Toolkit’ description: ‘The official Fundamentals tutorial for Redux: learn the modern way to write Redux logic’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<h1 id="redux-fundamentals-part-8-modern-redux-with-redux-toolkit">Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit</h1>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to simplify your Redux logic using Redux Toolkit</li>
<li>Next steps for learning and using Redux</li>
</ul>
<p>:::</p>
<p>Congratulations, you’ve made it to the last section of this tutorial! We’ve got one more topic to cover before we’re done.</p>
<p>If you’d like a reminder of what we’ve covered so far, take a look at this summary:</p>
<div class="info">
<p><DetailedExplanation title="Recap: What You've Learned"></p>
<ul>
<li><a href="./part-1-overview.md">Part 1: Overview</a>:
<ul>
<li>what Redux is, when/why to use it, and the basic pieces of a Redux app</li>
</ul></li>
<li><a href="./part-2-concepts-data-flow.md">Part 2: Concepts and Data Flow</a>:
<ul>
<li>How Redux uses a “one-way data flow” pattern</li>
</ul></li>
<li><a href="./part-3-state-actions-reducers.md">Part 3: State, Actions, and Reducers</a>:
<ul>
<li>Redux state is made of plain JS data</li>
<li>Actions are objects that describe “what happened” events in an app</li>
<li>Reducers take current state and an action, and calculate a new state</li>
<li>Reducers must follow rules like “immutable updates” and “no side effects”</li>
</ul></li>
<li><a href="./part-4-store.md">Part 4: Store</a>:
<ul>
<li>The <code>createStore</code> API creates a Redux store with a root reducer function</li>
<li>Stores can be customized using “enhancers” and “middleware”</li>
<li>The Redux DevTools extension lets you see how your state changes over time</li>
</ul></li>
<li><a href="./part-5-ui-and-react.md">Part 5: UI and React</a>:
<ul>
<li>Redux is separate from any UI, but frequently used with React</li>
<li>React-Redux provides APIs to let React components talk to Redux stores</li>
<li><code>useSelector</code> reads values from Redux state and subscribes to updates</li>
<li><code>useDispatch</code> lets components dispatch actions</li>
<li><code>&lt;Provider&gt;</code> wraps your app and lets components access the store</li>
</ul></li>
<li><a href="./part-6-async-logic.md">Part 6: Async Logic and Data Fetching</a>:
<ul>
<li>Redux middleware allow writing logic that has side effects</li>
<li>Middleware add an extra step to the Redux data flow, enabling async logic</li>
<li>Redux “thunk” functions are the standard way to write basic async logic</li>
</ul></li>
<li><a href="./part-7-standard-patterns.md">Part 7: Standard Redux Patterns</a>:
<ul>
<li>Action creators encapsulate preparing action objects and thunks</li>
<li>Memoized selectors optimize calculating transformed data</li>
<li>Request status should be tracked with loading state enum values</li>
<li>Normalized state makes it easier to look up items by IDs</li>
</ul></li>
</ul>
<p></DetailedExplanation></p>
</div>
<p>As you’ve seen, many aspects of Redux involve writing some code that can be verbose, such as immutable updates, action types and action creators, and normalizing state. There’s good reasons why these patterns exist, but writing that code “by hand” can be difficult. In addition, the process for setting up a Redux store takes several steps, and we’ve had to come up with our own logic for things like dispatching “loading” actions in thunks or processing normalized data. Finally, many times users aren’t sure what “the right way” is to write Redux logic.</p>
<p>That’s why the Redux team created <a href="https://redux-toolkit.js.org"><strong>Redux Toolkit</strong>: our official, opinionated, “batteries included” toolset for efficient Redux development</a>.</p>
<p>Redux Toolkit contains packages and functions that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications.</p>
<p>Because of this, <strong>Redux Toolkit is the standard way to write Redux application logic</strong>. The “hand-written” Redux logic you’ve written so far in this tutorial is actual working code, but <strong>you shouldn’t write Redux logic by hand</strong> - we’ve covered those approaches in this tutorial so that you understand <em>how</em> Redux works. However, <strong>for real applications, you should use Redux Toolkit to write your Redux logic.</strong></p>
<p>When you use Redux Toolkit, all the concepts that we’ve covered so far (actions, reducers, store setup, action creators, thunks, etc) still exist, but <strong>Redux Toolkit provides easier ways to write that code</strong>.</p>
<div class="tip">
<p>Redux Toolkit <em>only</em> covers the Redux logic - we still use React-Redux to let our React components talk to the Redux store, including <code>useSelector</code> and <code>useDispatch</code>.</p>
</div>
<p>So, let’s see how we can use Redux Toolkit to simplify the code we’ve already written in our example todo application. We’ll primarily be rewriting our “slice” files, but we should be able to keep all the UI code the same.</p>
<p>Before we continue, <strong>add the Redux Toolkit package to your app</strong>:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb254-1" title="1"><span class="ex">npm</span> install @reduxjs/toolkit</a></code></pre></div>
<h2 id="store-setup">Store Setup</h2>
<p>We’ve gone through a few iterations of setup logic for our Redux store. Currently, it looks like this:</p>
<p>```js title=“src/rootReducer.js” import { combineReducers } from “redux”;</p>
<p>import todosReducer from “./features/todos/todosSlice”; import filtersReducer from “./features/filters/filtersSlice”;</p>
<p>const rootReducer = combineReducers({ // Define a top-level state field named <code>todos</code>, handled by <code>todosReducer</code> todos: todosReducer, filters: filtersReducer, });</p>
<p>export default rootReducer; ```</p>
<p>```js title=“src/store.js” import { createStore, applyMiddleware } from “redux”; import thunkMiddleware from “redux-thunk”; import { composeWithDevTools } from “redux-devtools-extension”; import rootReducer from “./reducer”;</p>
<p>const composedEnhancer = composeWithDevTools(applyMiddleware(thunkMiddleware));</p>
<p>const store = createStore(rootReducer, composedEnhancer); export default store; ```</p>
<p>Notice that the setup process takes several steps. We have to:</p>
<ul>
<li>Combine the slice reducers together to form the root reducer</li>
<li>Import the root reducer into the store file</li>
<li>Import the thunk middleware, <code>applyMiddleware</code>, and <code>composeWithDevTools</code> APIs</li>
<li>Create a store enhancer with the middleware and devtools</li>
<li>Create the store with the root reducer</li>
</ul>
<p>It would be nice if we could cut down the number of steps here.</p>
<h3 id="using-configurestore">Using <code>configureStore</code></h3>
<p><strong>Redux Toolkit has a <code>configureStore</code> API that simplifies the store setup process</strong>. <code>configureStore</code> wraps around the Redux core <code>createStore</code> API, and handles most of the store setup for us automatically. In fact, we can cut it down to effectively one step:</p>
<p>```js title=“src/store.js” // highlight-next-line import { configureStore } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import todosReducer from “./features/todos/todosSlice”; import filtersReducer from “./features/filters/filtersSlice”;</p>
<p>// highlight-start const store = configureStore({ reducer: { // Define a top-level state field named <code>todos</code>, handled by <code>todosReducer</code> todos: todosReducer, filters: filtersReducer, }, }); // highlight-end</p>
<p>export default store; ```</p>
<p>That one call to <code>configureStore</code> did all the work for us:</p>
<ul>
<li>It combined <code>todosReducer</code> and <code>filtersReducer</code> into the root reducer function, which will handle a root state that looks like <code>{todos, filters}</code></li>
<li>It created a Redux store using that root reducer</li>
<li>It automatically added the <code>thunk</code> middleware</li>
<li>It automatically added more middleware to check for common mistakes like accidentally mutating the state</li>
<li>It automatically set up the Redux DevTools Extension connection</li>
</ul>
<p>We can confirm this works by opening up our example todo application and using it. All of our existing feature code works fine! Since we’re dispatching actions, dispatching thunks, reading state in the UI, and looking at the action history in the DevTools, all those pieces must be working correctly. All we’ve done is switched out the store setup code.</p>
<p>Let’s see what happens now if we accidentally mutate some of the state. What if we change the “todos loading” reducer so that it directly changes the state field, instead of immutably making a copy?</p>
<p><code>js title="src/features/todos/todosSlice" export default function todosReducer(state = initialState, action) {   switch (action.type) {     // omit other cases     case "todos/todosLoading": {       // ❌ WARNING: example only - don't do this in a normal reducer!       state.status = "loading";       return state;     }     default:       return state;   } }</code></p>
<p>Uh-oh. Our whole app just crashed! What happened?</p>
<figure>
<img src="/img/tutorials/fundamentals/immutable-error.png" alt="Immutability check middleware error" /><figcaption>Immutability check middleware error</figcaption>
</figure>
<p><strong>This error message is a <em>good</em> thing - we caught a bug in our app!</strong> <code>configureStore</code> specifically added an extra middleware that automatically throws an error whenever it sees an accidental mutation of our state (in development mode only). That helps catch mistakes we might make while writing our code.</p>
<h3 id="package-cleanup">Package Cleanup</h3>
<p>Redux Toolkit already includes several of the packages we’re using, like <code>redux</code>, <code>redux-thunk</code>, and <code>reselect</code>, and re-exports those APIs. So, we can clean up our project a bit.</p>
<p>First, we can switch our <code>createSelector</code> import to be from <code>'@reduxjs/toolkit'</code> instead of <code>'reselect'</code>. Then, we can remove the separate packages we have listed in our <code>package.json</code>:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb255-1" title="1">npm uninstall redux redux<span class="op">-</span>thunk reselect</a></code></pre></div>
<p>To be clear, <strong>we’re still using these packages and need to have them installed</strong>. However, because Redux Toolkit depends on them, they’ll be installed automatically when we install <code>@reduxjs/toolkit</code>, so we don’t need to have the other packages specifically listed in our <code>package.json</code> file.</p>
<h2 id="writing-slices">Writing Slices</h2>
<p>As we’ve added new features to our app, the slice files have gotten bigger and more complicated. In particular, the <code>todosReducer</code> has gotten harder to read because of all the nested object spreads for immutable updates, and we’ve written multiple action creator functions.</p>
<p><strong>Redux Toolkit has a <code>createSlice</code> API that will help us simplify our Redux reducer logic and actions</strong>. <code>createSlice</code> does several important things for us:</p>
<ul>
<li>We can write the case reducers as functions inside of an object, instead of having to write a <code>switch/case</code> statement</li>
<li>The reducers will be able to write shorter immutable update logic</li>
<li>All the action creators will be generated automatically based on the reducer functions we’ve provided</li>
</ul>
<h3 id="using-createslice">Using <code>createSlice</code></h3>
<p><code>createSlice</code> takes an object with three main options fields:</p>
<ul>
<li><code>name</code>: a string that will be used as the prefix for generated action types</li>
<li><code>initialState</code>: the initial state of the reducer</li>
<li><code>reducers</code>: an object where the keys are strings, and the values are “case reducer” functions that will handle specific actions</li>
</ul>
<p>Let’s look at a small standalone example first.</p>
<p>```js title=“createSlice example” import { createSlice } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>const initialState = [];</p>
<p>const todosSlice = createSlice({ name: “todos”, initialState, reducers: { todoAdded(state, action) { // ✅ This “mutating” code is okay inside of createSlice! state.push(action.payload); }, todoToggled(state, action) { const todo = state.find((todo) =&gt; todo.id === action.payload); todo.completed = !todo.completed; }, todosLoading(state, action) { return { …state, status: “loading”, }; }, }, });</p>
<p>export const { todoAdded, todoToggled, todosLoading } = todosSlice.actions;</p>
<p>export default todosSlice.reducer; ```</p>
<p>There’s several things to see in this example:</p>
<ul>
<li>We write case reducer functions inside the <code>reducers</code> object, and give them readable names</li>
<li><strong><code>createSlice</code> will automatically generate action creators</strong> that correspond to each case reducer function we provide</li>
<li>createSlice automatically returns the existing state in the default case</li>
<li><strong><code>createSlice</code> allows us to safely “mutate” our state!</strong></li>
<li>But, we can also make immutable copies like before if we want to</li>
</ul>
<p>The generated action creators will be available as <code>slice.actions.todoAdded</code>, and we typically destructure and export those individually like we did with the action creators we wrote earlier. The complete reducer function is available as <code>slice.reducer</code>, and we typically <code>export default slice.reducer</code>, again the same as before.</p>
<p>So what do these auto-generated action objects look like? Let’s try calling one of them and logging the action to see:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb256-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="at">todoToggled</span>(<span class="dv">42</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb256-2" title="2"><span class="co">// {type: &#39;todos/todoToggled&#39;, payload: 42}</span></a></code></pre></div>
<p><code>createSlice</code> generated the action type string for us, by combining the slice’s <code>name</code> field with the <code>todoToggled</code> name of the reducer function we wrote. By default, the action creator accepts one argument, which it puts into the action object as <code>action.payload</code>.</p>
<p>Inside of the generated reducer function, <code>createSlice</code> will check to see if a dispatched action’s <code>action.type</code> matches one of the names it generated. If so, it will run that case reducer function. This is exactly the same pattern that we wrote ourselves using a <code>switch/case</code> statement, but <code>createSlice</code> does it for us automatically.</p>
<p>It’s also worth talking about the “mutation” aspect in more detail.</p>
<h3 id="immutable-updates-with-immer">Immutable Updates with Immer</h3>
<p>Earlier, we talked about “mutation” (modifying existing object/array values) and “immutability” (treating values as something that cannot be changed).</p>
<div class="warning">
<p>In Redux, <strong>our reducers are <em>never</em> allowed to mutate the original / current state values!</strong></p>
<div class="sourceCode" id="cb257"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb257-1" title="1"><span class="co">// ❌ Illegal - by default, this will mutate the state!</span></a>
<a class="sourceLine" id="cb257-2" title="2"><span class="va">state</span>.<span class="at">value</span> <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></a></code></pre></div>
</div>
<p>So if we can’t change the originals, how do we return an updated state?</p>
<div class="tip">
<p><strong>Reducers can only make <em>copies</em> of the original values, and then they can mutate the copies.</strong></p>
<div class="sourceCode" id="cb258"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb258-1" title="1"><span class="co">// This is safe, because we made a copy</span></a>
<a class="sourceLine" id="cb258-2" title="2"><span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb258-3" title="3">  ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb258-4" title="4">  <span class="dt">value</span><span class="op">:</span> <span class="dv">123</span><span class="op">,</span></a>
<a class="sourceLine" id="cb258-5" title="5"><span class="op">};</span></a></code></pre></div>
</div>
<p>As you’ve seen throughout this tutorial, we can write immutable updates by hand by using JavaScript’s array / object spread operators and other functions that return copies of the original values. However, writing immutable update logic by hand <em>is</em> hard, and accidentally mutating state in reducers is the single most common mistake Redux users make.</p>
<p><strong>That’s why Redux Toolkit’s <code>createSlice</code> function lets you write immutable updates an easier way!</strong></p>
<p><code>createSlice</code> uses a library called <a href="https://immerjs.github.io/immer/">Immer</a> inside. Immer uses a special JS tool called a <code>Proxy</code> to wrap the data you provide, and lets you write code that “mutates” that wrapped data. But, <strong>Immer tracks all the changes you’ve tried to make, and then uses that list of changes to return a safely immutably updated value</strong>, as if you’d written all the immutable update logic by hand.</p>
<p>So, instead of this:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb259-1" title="1"><span class="kw">function</span> <span class="at">handwrittenReducer</span>(state<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb259-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb259-3" title="3">    ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb259-4" title="4">    <span class="dt">first</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb259-5" title="5">      ...<span class="va">state</span>.<span class="at">first</span><span class="op">,</span></a>
<a class="sourceLine" id="cb259-6" title="6">      <span class="dt">second</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb259-7" title="7">        ...<span class="va">state</span>.<span class="va">first</span>.<span class="at">second</span><span class="op">,</span></a>
<a class="sourceLine" id="cb259-8" title="8">        [<span class="va">action</span>.<span class="at">someId</span>]<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb259-9" title="9">          ...<span class="va">state</span>.<span class="va">first</span>.<span class="at">second</span>[<span class="va">action</span>.<span class="at">someId</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb259-10" title="10">          <span class="dt">fourth</span><span class="op">:</span> <span class="va">action</span>.<span class="at">someValue</span><span class="op">,</span></a>
<a class="sourceLine" id="cb259-11" title="11">        <span class="op">},</span></a>
<a class="sourceLine" id="cb259-12" title="12">      <span class="op">},</span></a>
<a class="sourceLine" id="cb259-13" title="13">    <span class="op">},</span></a>
<a class="sourceLine" id="cb259-14" title="14">  <span class="op">};</span></a>
<a class="sourceLine" id="cb259-15" title="15"><span class="op">}</span></a></code></pre></div>
<p>You can write code that looks like this:</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb260-1" title="1"><span class="kw">function</span> <span class="at">reducerWithImmer</span>(state<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb260-2" title="2">  <span class="va">state</span>.<span class="va">first</span>.<span class="at">second</span>[<span class="va">action</span>.<span class="at">someId</span>].<span class="at">fourth</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">someValue</span><span class="op">;</span></a>
<a class="sourceLine" id="cb260-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>That’s a lot easier to read!</p>
<p>But, here’s something <em>very</em> important to remember:</p>
<div class="warning">
<p><strong>You can <em>only</em> write “mutating” logic in Redux Toolkit’s <code>createSlice</code> and <code>createReducer</code> because they use Immer inside! If you write mutating logic in reducers without Immer, it <em>will</em> mutate the state and cause bugs!</strong></p>
</div>
<p>Immer still lets us write immutable updates by hand and return the new value ourselves if we want to. You can even mix and match. For example, removing an item from an array is often easier to do with <code>array.filter()</code>, so you could call that and then assign the result to <code>state</code> to “mutate” it:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb261-1" title="1"><span class="co">// can mix &quot;mutating&quot; and &quot;immutable&quot; code inside of Immer:</span></a>
<a class="sourceLine" id="cb261-2" title="2"><span class="va">state</span>.<span class="at">todos</span> <span class="op">=</span> <span class="va">state</span>.<span class="va">todos</span>.<span class="at">filter</span>((todo) <span class="kw">=&gt;</span> <span class="va">todo</span>.<span class="at">id</span> <span class="op">!==</span> <span class="va">action</span>.<span class="at">payload</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="converting-the-todos-reducer">Converting the Todos Reducer</h3>
<p>Let’s start converting our todos slice file to use <code>createSlice</code> instead. We’ll pick a couple specific cases from our switch statement first to show how the process works.</p>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-next-line import { createSlice } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>const initialState = { status: “idle”, entities: {}, };</p>
<p>// highlight-start const todosSlice = createSlice({ name: “todos”, initialState, reducers: { todoAdded(state, action) { const todo = action.payload; state.entities[todo.id] = todo; }, todoToggled(state, action) { const todoId = action.payload; const todo = state.entities[todoId]; todo.completed = !todo.completed; }, }, });</p>
<p>export const { todoAdded, todoToggled } = todosSlice.actions;</p>
<p>export default todosSlice.reducer; // highlight-end ```</p>
<p>The todos reducer in our example app is still using normalized state that is nested in a parent object, so the code here is a bit different than the miniature <code>createSlice</code> example we just looked at. Remember how we had to <a href="./part-7-standard-patterns.md#normalized-state">write a lot of nested spread operators to toggle that todo earlier</a>? Now that same code is a <em>lot</em> shorter and easier to read.</p>
<p>Let’s add a couple more cases to this reducer.</p>
<p>```js title=“src/features/todos/todosSlice.js” const todosSlice = createSlice({ name: “todos”, initialState, reducers: { todoAdded(state, action) { const todo = action.payload; state.entities[todo.id] = todo; }, todoToggled(state, action) { const todoId = action.payload; const todo = state.entities[todoId]; todo.completed = !todo.completed; }, // highlight-start todoColorSelected: { reducer(state, action) { const { color, todoId } = action.payload; state.entities[todoId].color = color; }, prepare(todoId, color) { return { payload: { todoId, color }, }; }, }, todoDeleted(state, action) { delete state.entities[action.payload]; }, // highlight-end }, });</p>
<p>export const { todoAdded, todoToggled, todoColorSelected, todoDeleted } = todosSlice.actions;</p>
<p>export default todosSlice.reducer; ```</p>
<p>The action creators for <code>todoAdded</code> and <code>todoToggled</code> only need to take a single parameter, like an entire todo object or a todo ID. But, what if we need to pass in multiple parameters, or do some of that “preparation” logic we talked about like generating a unique ID?</p>
<p><code>createSlice</code> lets us handle those situations by adding a “prepare callback” to the reducer. We can pass an object that has functions named <code>reducer</code> and <code>prepare</code>. When we call the generated action creator, the <code>prepare</code> function will be called with whatever parameters were passed in. It should then create and return an object that has a <code>payload</code> field (or, optionally, <code>meta</code> and <code>error</code> fields), matching the <a href="./part-7-standard-patterns.md#flux-standard-actions">Flux Standard Action convention</a>.</p>
<p>Here, we’ve used a prepare callback to let our <code>todoColorSelected</code> action creator accept separate <code>todoId</code> and <code>color</code> arguments, and put them together as an object in <code>action.payload</code>.</p>
<p>Meanwhile, in the <code>todoDeleted</code> reducer, we can use the JS <code>delete</code> operator to remove items from our normalized state.</p>
<p>We can use these same patterns to go rewrite the rest of our reducers in <code>todosSlice.js</code> and <code>filtersSlice.js</code>.</p>
<p>Here’s how our code looks with all the slices converted:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-9-createSlice/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;module=%2Fsrc%2Ffeatures%2Ftodos%2FtodosSlice.js&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<h2 id="writing-thunks">Writing Thunks</h2>
<p>We’ve seen how we can <a href="./part-7-standard-patterns.md#loading-state-enum-values">write thunks that dispatch “loading”, “request succeeded”, and “request failed” actions</a>. We had to write action creators, action types, <em>and</em> reducers to handle those cases.</p>
<p>Because this pattern is so common, <strong>Redux Toolkit has a <code>createAsyncThunk</code> API that will generate these thunks for us</strong>. It also generates the action types and action creators for those different request status actions, and dispatches those actions automatically based on the resulting <code>Promise</code>.</p>
<div class="tip">
<p>Redux Toolkit has a new <a href="https://redux-toolkit.js.org/rtk-query/overview"><strong>RTK Query data fetching API</strong></a>. RTK Query is a purpose built data fetching and caching solution for Redux apps, and <strong>can eliminate the need to write <em>any</em> thunks or reducers to manage data fetching</strong>. We encourage you to try it out and see if it can help simplify the data fetching code in your own apps!</p>
<p>We’ll be updating the Redux tutorials soon to include sections on using RTK Query. Until then, see <a href="https://redux-toolkit.js.org/rtk-query/overview">the RTK Query section in the Redux Toolkit docs</a>.</p>
</div>
<h3 id="using-createasyncthunk">Using <code>createAsyncThunk</code></h3>
<p>Let’s replace our <code>fetchTodos</code> thunk by generating a thunk with <code>createAsyncThunk</code>.</p>
<p><code>createAsyncThunk</code> accepts two arguments:</p>
<ul>
<li>A string that will be used as the prefix for the generated action types</li>
<li>A “payload creator” callback function that should return a <code>Promise</code>. This is often written using the <code>async/await</code> syntax, since <code>async</code> functions automatically return a promise.</li>
</ul>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-next-line import { createSlice, createAsyncThunk } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>// omit imports and state</p>
<p>// highlight-start export const fetchTodos = createAsyncThunk(“todos/fetchTodos”, async () =&gt; { const response = await client.get(“/fakeApi/todos”); return response.todos; }); // highlight-end</p>
<p>const todosSlice = createSlice({ name: “todos”, initialState, reducers: { // omit reducer cases }, extraReducers: (builder) =&gt; { builder .addCase(fetchTodos.pending, (state, action) =&gt; { state.status = “loading”; }) .addCase(fetchTodos.fulfilled, (state, action) =&gt; { const newEntities = {}; action.payload.forEach((todo) =&gt; { newEntities[todo.id] = todo; }); state.entities = newEntities; state.status = “idle”; }); }, });</p>
<p>// omit exports ```</p>
<p>We pass <code>'todos/fetchTodos'</code> as the string prefix, and a “payload creator” function that calls our API and returns a promise containing the fetched data. Inside, <code>createAsyncThunk</code> will generate three action creators and action types, plus a thunk function that automatically dispatches those actions when called. In this case, the action creators and their types are:</p>
<ul>
<li><code>fetchTodos.pending</code>: <code>todos/fetchTodos/pending</code></li>
<li><code>fetchTodos.fulfilled</code>: <code>todos/fetchTodos/fulfilled</code></li>
<li><code>fetchTodos.rejected</code>: <code>todos/fetchTodos/rejected</code></li>
</ul>
<p>However, these action creators and types are being defined <em>outside</em> of the <code>createSlice</code> call. We can’t handle those inside of the <code>createSlice.reducers</code> field, because those generate new action types too. We need a way for our <code>createSlice</code> call to listen for <em>other</em> action types that were defined elsewhere.</p>
<p><strong><code>createSlice</code> also accepts an <code>extraReducers</code> option, where we can have the same slice reducer listen for other action types</strong>. This field should be a callback function with a <code>builder</code> parameter, and we can call <code>builder.addCase(actionCreator, caseReducer)</code> to listen for other actions.</p>
<p>So, here we’ve called <code>builder.addCase(fetchTodos.pending, caseReducer)</code>. When that action is dispatched, we’ll run the reducer that sets <code>state.status = 'loading'</code>, same as it did earlier when we wrote that logic in a switch statement. We can do the same thing for <code>fetchTodos.fulfilled</code>, and handle the data we received from the API.</p>
<p>As one more example, let’s convert <code>saveNewTodo</code>. This thunk takes the <code>text</code> of the new todo object as its parameter, and saves it to the server. How do we handle that?</p>
<p>```js title=“src/features/todos/todosSlice.js” // omit imports</p>
<p>export const fetchTodos = createAsyncThunk(“todos/fetchTodos”, async () =&gt; { const response = await client.get(“/fakeApi/todos”); return response.todos; });</p>
<p>// highlight-start export const saveNewTodo = createAsyncThunk( “todos/saveNewTodo”, async (text) =&gt; { const initialTodo = { text }; const response = await client.post(“/fakeApi/todos”, { todo: initialTodo }); return response.todo; } ); // highlight-end</p>
<p>const todosSlice = createSlice({ name: “todos”, initialState, reducers: { // omit case reducers }, extraReducers: (builder) =&gt; { builder .addCase(fetchTodos.pending, (state, action) =&gt; { state.status = “loading”; }) .addCase(fetchTodos.fulfilled, (state, action) =&gt; { const newEntities = {}; action.payload.forEach((todo) =&gt; { newEntities[todo.id] = todo; }); state.entities = newEntities; state.status = “idle”; }) // highlight-start .addCase(saveNewTodo.fulfilled, (state, action) =&gt; { const todo = action.payload; state.entities[todo.id] = todo; }); // highlight-end }, });</p>
<p>// omit exports and selectors ```</p>
<p>The process for <code>saveNewTodo</code> is the same as we saw for <code>fetchTodos</code>. We call <code>createAsyncThunk</code>, and pass in the action prefix and a payload creator. Inside the payload creator, we make an async API call, and return a result value.</p>
<p>In this case, when we call <code>dispatch(saveNewTodo(text))</code>, the <code>text</code> value will be passed in to the payload creator as its first argument.</p>
<p>While we won’t cover <code>createAsyncThunk</code> in more detail here, a few other quick notes for reference:</p>
<ul>
<li>You can only pass one argument to the thunk when you dispatch it. If you need to pass multiple values, pass them in a single object</li>
<li>The payload creator will receive an object as its second argument, which contains <code>{getState, dispatch}</code>, and some other useful values</li>
<li>The thunk dispatches the <code>pending</code> action before running your payload creator, then dispatches either <code>fulfilled</code> or <code>rejected</code> based on whether the <code>Promise</code> you return succeeds or fails</li>
</ul>
<h2 id="normalizing-state">Normalizing State</h2>
<p>We previously saw how to “normalize” state, by keeping items in an object keyed by item IDs. This gives us the ability to look up any item by its ID without having to loop through an entire array. However, writing the logic to update normalized state by hand was long and tedious. Writing “mutating” update code with Immer makes that simpler, but there’s still likely to be a lot of repetition - we might be loading many different types of items in our app, and we’d have to repeat the same reducer logic each time.</p>
<p><strong>Redux Toolkit includes a <code>createEntityAdapter</code> API that has prebuilt reducers for typical data update operations with normalized state</strong>. This includes adding, updating, and removing items from a slice. <strong><code>createEntityAdapter</code> also generates some memoized selectors for reading values from the store</strong>.</p>
<h3 id="using-createentityadapter">Using <code>createEntityAdapter</code></h3>
<p>Let’s replace our normalized entity reducer logic with <code>createEntityAdapter</code>.</p>
<p>Calling <code>createEntityAdapter</code> gives us an “adapter” object that contains several premade reducer functions, including:</p>
<ul>
<li><code>addOne</code> / <code>addMany</code>: add new items to the state</li>
<li><code>upsertOne</code> / <code>upsertMany</code>: add new items or update existing ones</li>
<li><code>updateOne</code> / <code>updateMany</code>: update existing items by supplying partial values</li>
<li><code>removeOne</code> / <code>removeMany</code>: remove items based on IDs</li>
<li><code>setAll</code>: replace all existing items</li>
</ul>
<p>We can use these functions as case reducers, or as “mutating helpers” inside of <code>createSlice</code>.</p>
<p>The adapter also contains:</p>
<ul>
<li><code>getInitialState</code>: returns an object that looks like <code>{ ids: [], entities: {} }</code>, for storing a normalized state of items along with an array of all item IDs</li>
<li><code>getSelectors</code>: generates a standard set of selector functions</li>
</ul>
<p>Let’s see how we can use these in our todos slice:</p>
<p>```js title=“src/features/todos/todosSlice.js” // highlight-start import { createSlice, createAsyncThunk, createEntityAdapter, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; // omit some imports</p>
<p>// highlight-start const todosAdapter = createEntityAdapter();</p>
<p>const initialState = todosAdapter.getInitialState({ status: “idle”, }); // highlight-end</p>
<p>// omit thunks</p>
<p>const todosSlice = createSlice({ name: “todos”, initialState, reducers: { // omit some reducers // highlight-start // Use an adapter reducer function to remove a todo by ID todoDeleted: todosAdapter.removeOne, // highlight-end completedTodosCleared(state, action) { const completedIds = Object.values(state.entities) .filter((todo) =&gt; todo.completed) .map((todo) =&gt; todo.id); // highlight-start // Use an adapter function as a “mutating” update helper todosAdapter.removeMany(state, completedIds); // highlight-end }, }, extraReducers: (builder) =&gt; { builder .addCase(fetchTodos.pending, (state, action) =&gt; { state.status = “loading”; }) .addCase(fetchTodos.fulfilled, (state, action) =&gt; { todosAdapter.setAll(state, action.payload); state.status = “idle”; }) // highlight-start // Use another adapter function as a reducer to add a todo .addCase(saveNewTodo.fulfilled, todosAdapter.addOne); // highlight-end }, });</p>
<p>// omit selectors ```</p>
<p>The different adapter reducer functions take different values depending on the function, all in <code>action.payload</code>. The “add” and “upsert” functions take a single item or an array of items, the “remove” functions take a single ID or array of IDs, and so on.</p>
<p><code>getInitialState</code> allows us to pass in additional state fields that will be included. In this case, we’ve passed in a <code>status</code> field, giving us a final todos slice state of <code>{ids, entities, status}</code>, much like we had before.</p>
<p>We can also replace some of our todos selector functions as well. The <code>getSelectors</code> adapter function will generate selectors like <code>selectAll</code>, which returns an array of all items, and <code>selectById</code>, which returns one item. However, since <code>getSelectors</code> doesn’t know where our data is in the entire Redux state tree, we need to pass in a small selector that returns this slice out of the whole state tree. Let’s switch to using these instead. Since this is the last major change to our code, we’ll include the whole todos slice file this time to see what the final version of the code looks like using Redux Toolkit:</p>
<p>```js title=“src/features/todos/todosSlice.js” import { createSlice, createSelector, createAsyncThunk, createEntityAdapter, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; import { client } from “../../api/client”; import { StatusFilters } from “../filters/filtersSlice”;</p>
<p>const todosAdapter = createEntityAdapter();</p>
<p>const initialState = todosAdapter.getInitialState({ status: “idle”, });</p>
<p>// Thunk functions export const fetchTodos = createAsyncThunk(“todos/fetchTodos”, async () =&gt; { const response = await client.get(“/fakeApi/todos”); return response.todos; });</p>
<p>export const saveNewTodo = createAsyncThunk( “todos/saveNewTodo”, async (text) =&gt; { const initialTodo = { text }; const response = await client.post(“/fakeApi/todos”, { todo: initialTodo }); return response.todo; } );</p>
<p>const todosSlice = createSlice({ name: “todos”, initialState, reducers: { todoToggled(state, action) { const todoId = action.payload; const todo = state.entities[todoId]; todo.completed = !todo.completed; }, todoColorSelected: { reducer(state, action) { const { color, todoId } = action.payload; state.entities[todoId].color = color; }, prepare(todoId, color) { return { payload: { todoId, color }, }; }, }, todoDeleted: todosAdapter.removeOne, allTodosCompleted(state, action) { Object.values(state.entities).forEach((todo) =&gt; { todo.completed = true; }); }, completedTodosCleared(state, action) { const completedIds = Object.values(state.entities) .filter((todo) =&gt; todo.completed) .map((todo) =&gt; todo.id); todosAdapter.removeMany(state, completedIds); }, }, extraReducers: (builder) =&gt; { builder .addCase(fetchTodos.pending, (state, action) =&gt; { state.status = “loading”; }) .addCase(fetchTodos.fulfilled, (state, action) =&gt; { todosAdapter.setAll(state, action.payload); state.status = “idle”; }) .addCase(saveNewTodo.fulfilled, todosAdapter.addOne); }, });</p>
<p>export const { allTodosCompleted, completedTodosCleared, todoAdded, todoColorSelected, todoDeleted, todoToggled, } = todosSlice.actions;</p>
<p>export default todosSlice.reducer;</p>
<p>// highlight-start export const { selectAll: selectTodos, selectById: selectTodoById } = todosAdapter.getSelectors((state) =&gt; state.todos); // highlight-end</p>
<p>export const selectTodoIds = createSelector( // First, pass one or more “input selector” functions: selectTodos, // Then, an “output selector” that receives all the input results as arguments // and returns a final result value (todos) =&gt; todos.map((todo) =&gt; todo.id) );</p>
<p>export const selectFilteredTodos = createSelector( // First input selector: all todos selectTodos, // Second input selector: all filter values (state) =&gt; state.filters, // Output selector: receives both values (todos, filters) =&gt; { const { status, colors } = filters; const showAllCompletions = status === StatusFilters.All; if (showAllCompletions &amp;&amp; colors.length === 0) { return todos; }</p>
<pre><code>const completedStatus = status === StatusFilters.Completed;
// Return either active or completed todos based on filter
return todos.filter((todo) =&gt; {
  const statusMatches =
    showAllCompletions || todo.completed === completedStatus;
  const colorMatches = colors.length === 0 || colors.includes(todo.color);
  return statusMatches &amp;&amp; colorMatches;
});</code></pre>
<p>} );</p>
<p>export const selectFilteredTodoIds = createSelector( // Pass our other memoized selector as an input selectFilteredTodos, // And derive data in the output selector (filteredTodos) =&gt; filteredTodos.map((todo) =&gt; todo.id) ); ```</p>
<p>We call <code>todosAdapter.getSelectors</code>, and pass in a <code>state =&gt; state.todos</code> selector that returns this slice of state. From there, the adapter generates a <code>selectAll</code> selector that takes the <em>entire</em> Redux state tree, as usual, and loops over <code>state.todos.entities</code> and <code>state.todos.ids</code> to give us the complete array of todo objects. Since <code>selectAll</code> doesn’t tell us <em>what</em> we’re selecting, we can use ES6 destructuring syntax to rename the function to <code>selectTodos</code>. Similarly, we can rename <code>selectById</code> to <code>selectTodoById</code>.</p>
<p>Notice that our other selectors still use <code>selectTodos</code> as an input. That’s because it’s still returning an array of todo objects this whole time, no matter whether we were keeping the array as the entire <code>state.todos</code>, keeping it as a nested array, or storing it as a normalized object and converting to an array. Even as we’ve made all these changes to how we stored our data, the use of selectors allowed us to keep the rest of our code the same, and the use of memoized selectors has helped the UI perform better by avoiding unnecessary rerenders.</p>
<h2 id="what-youve-learned-7">What You’ve Learned</h2>
<p><strong>Congratulations! You’ve completed the “Redux Fundamentals” tutorial!</strong></p>
<p>You should now have a solid understanding of what Redux is, how it works, and how to use it correctly:</p>
<ul>
<li>Managing global app state</li>
<li>Keeping the state of our app as plain JS data</li>
<li>Writing action objects that describe “what happened” in the app</li>
<li>Using reducer functions that look at the current state and an action, and create a new state immutably in response</li>
<li>Reading the Redux state in our React components with <code>useSelector</code></li>
<li>Dispatching actions from React components with <code>useDispatch</code></li>
</ul>
<p>In addition, you’ve seen how <strong>Redux Toolkit simplifies writing Redux logic</strong>, and why <strong>Redux Toolkit is the standard approach for writing real Redux applications</strong>. By seeing how to write Redux code “by hand” first, it should be clear what the Redux Toolkit APIs like <code>createSlice</code> are doing for you, so that you don’t have to write that code yourself.</p>
<div class="info">
<p>For more info on Redux Toolkit, including usage guides and API references, see:</p>
<ul>
<li>The Redux Toolkit docs at <strong><a href="https://redux-toolkit.js.org" class="uri">https://redux-toolkit.js.org</a></strong></li>
</ul>
</div>
<p>Let’s take one final look at the completed todo application, including all the code that’s been converted to use Redux Toolkit:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-10-finalCode/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;module=%2Fsrc%2Ffeatures%2Ftodos%2FtodosSlice.js&amp;runonclick=1" title="redux-fundamentals-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>And we’ll do a final recap of the key points you learned in this section:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux Toolkit (RTK) is the standard way to write Redux logic</strong>
<ul>
<li>RTK includes APIs that simplify most Redux code</li>
<li>RTK wraps around the Redux core, and includes other useful packages</li>
</ul></li>
<li><strong><code>configureStore</code> sets up a Redux store with good defaults</strong>
<ul>
<li>Automatically combines slice reducers to create the root reducer</li>
<li>Automatically sets up the Redux DevTools Extension and debugging middleware</li>
</ul></li>
<li><strong><code>createSlice</code> simplifies writing Redux actions and reducers</strong>
<ul>
<li>Automatically generates action creators based on slice/reducer names</li>
<li>Reducers can “mutate” state inside <code>createSlice</code> using Immer</li>
</ul></li>
<li><strong><code>createAsyncThunk</code> generates thunks for async calls</strong>
<ul>
<li>Automatically generates a thunk + <code>pending/fulfilled/rejected</code> action creators</li>
<li>Dispatching the thunk runs your payload creator and dispatches the actions</li>
<li>Thunk actions can be handled in <code>createSlice.extraReducers</code></li>
</ul></li>
<li><strong><code>createEntityAdapter</code> provides reducers + selectors for normalized state</strong>
<ul>
<li>Includes reducer functions for common tasks like adding/updating/removing items</li>
<li>Generates memoized selectors for <code>selectAll</code> and <code>selectById</code></li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="next-steps-for-learning-and-using-redux">Next Steps for Learning and Using Redux</h2>
<p>Now that you’ve completed this tutorial, we have several suggestions for what you should try next to learn more about Redux.</p>
<p>This “Fundamentals” tutorial focused on the low-level aspects of Redux: writing action types and immutable updates by hand, how a Redux store and middleware work, and why we use patterns like action creators and normalized state. In addition, our todo example app is fairly small, and not meant as a realistic example of building a full app.</p>
<p>However, our <a href="../essentials/part-1-overview-concepts.md"><strong>“Redux Essentials” tutorial</strong></a> specifically teaches you <strong>how to build a “real-world” type application</strong>. It focuses on “how to use Redux the right way” using Redux Toolkit, and talks about more realistic patterns that you’ll see in larger apps. It covers many of the same topics as this “Fundamentals” tutorial, such as why reducers need to use immutable updates, but with a focus on building a real working application. <strong>We strongly recommend reading through the “Redux Essentials” tutorial as your next step.</strong></p>
<p>At the same time, the concepts we’ve covered in this tutorial should be enough to get you started building your own applications using React and Redux. Now’s a great time to try working on a project yourself to solidify these concepts and see how they work in practice. If you’re not sure what kind of a project to build, see <a href="https://github.com/florinpop17/app-ideas">this list of app project ideas</a> for some inspiration.</p>
<p>The <a href="../../usage/index.md">Using Redux</a> section has information on a number of important concepts, like <a href="../../usage/structuring-reducers/StructuringReducers.md">how to structure your reducers</a>, and <a href="../../style-guide/style-guide"><strong>our Style Guide page</strong></a> has important information on our recommended patterns and best practices.</p>
<p>If you’d like to know more about <em>why</em> Redux exists, what problems it tries to solve, and how it’s meant to be used, see Redux maintainer Mark Erikson’s posts on <a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/">The Tao of Redux, Part 1: Implementation and Intent</a> and <a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/">The Tao of Redux, Part 2: Practice and Philosophy</a>.</p>
<p>If you’re looking for help with Redux questions, come join <a href="https://www.reactiflux.com">the <code>#redux</code> channel in the Reactiflux server on Discord</a>.</p>
<p><strong>Thanks for reading through this tutorial, and we hope you enjoy building applications with Redux!</strong></p>
<hr />
<p>id: part-1-overview-concepts title: ‘Redux Essentials, Part 1: Redux Overview and Concepts’ sidebar_label: ‘Redux Overview and Concepts’ description: ‘The official Essentials tutorial for Redux: learn how to use Redux, the right way’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>What Redux is and why you might want to use it</li>
<li>Key Redux terms and concepts</li>
<li>How data flows through a Redux app</li>
</ul>
<p>:::</p>
<h2 id="introduction-7">Introduction</h2>
<p>Welcome to the Redux Essentials tutorial! <strong>This tutorial will introduce you to Redux and teach you how to use it the right way, using our latest recommended tools and best practices</strong>. By the time you finish, you should be able to start building your own Redux applications using the tools and patterns you’ve learned here.</p>
<p>In Part 1 of this tutorial, we’ll cover the key concepts and terms you need to know to use Redux, and in <a href="./part-2-app-structure.md">Part 2: Redux App Structure</a> we’ll examine a basic React + Redux app to see how the pieces fit together.</p>
<p>Starting in <a href="./part-3-data-flow.md">Part 3: Basic Redux Data Flow</a>, we’ll use that knowledge to build a small social media feed app with some real-world features, see how those pieces actually work in practice, and talk about some important patterns and guidelines for using Redux.</p>
<h3 id="how-to-read-this-tutorial-1">How to Read This Tutorial</h3>
<p>This page will focus on showing you <em>how</em> to use Redux the right way, and explain just enough of the concepts so that you can understand how to build Redux apps correctly.</p>
<p>We’ve tried to keep these explanations beginner-friendly, but we do need to make some assumptions about what you know already:</p>
<p>:::important Prerequisites</p>
<ul>
<li>Familiarity with <a href="https://internetingishard.com/">HTML &amp; CSS</a>.</li>
<li>Familiarity with <a href="https://www.taniarascia.com/es6-syntax-and-feature-overview/">ES6 syntax and features</a></li>
<li>Knowledge of React terminology: <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>, <a href="https://reactjs.org/docs/state-and-lifecycle.html">State</a>, <a href="https://reactjs.org/docs/components-and-props.html">Function Components, Props</a>, and <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a></li>
<li>Knowledge of <a href="https://javascript.info/promise-basics">asynchronous JavaScript</a> and <a href="https://javascript.info/fetch">making AJAX requests</a></li>
</ul>
<p>:::</p>
<p><strong>If you’re not already comfortable with those topics, we encourage you to take some time to become comfortable with them first, and then come back to learn about Redux</strong>. We’ll be here when you’re ready!</p>
<p>You should make sure that you have the React and Redux DevTools extensions installed in your browser:</p>
<ul>
<li>React DevTools Extension:
<ul>
<li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">React DevTools Extension for Chrome</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">React DevTools Extension for Firefox</a></li>
</ul></li>
<li>Redux DevTools Extension:
<ul>
<li><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en">Redux DevTools Extension for Chrome</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/">Redux DevTools Extension for Firefox</a></li>
</ul></li>
</ul>
<h2 id="what-is-redux-1">What is Redux?</h2>
<p>It helps to understand what this “Redux” thing is in the first place. What does it do? What problems does it help me solve? Why would I want to use it?</p>
<p><strong>Redux is a pattern and library for managing and updating application state, using events called “actions”.</strong> It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.</p>
<h3 id="why-should-i-use-redux-1">Why Should I Use Redux?</h3>
<p>Redux helps you manage “global” state - state that is needed across many parts of your application.</p>
<p><strong>The patterns and tools provided by Redux make it easier to understand when, where, why, and how the state in your application is being updated, and how your application logic will behave when those changes occur</strong>. Redux guides you towards writing code that is predictable and testable, which helps give you confidence that your application will work as expected.</p>
<h3 id="when-should-i-use-redux-1">When Should I Use Redux?</h3>
<p>Redux helps you deal with shared state management, but like any tool, it has tradeoffs. There are more concepts to learn, and more code to write. It also adds some indirection to your code, and asks you to follow certain restrictions. It’s a trade-off between short term and long term productivity.</p>
<p>Redux is more useful when:</p>
<ul>
<li>You have large amounts of application state that are needed in many places in the app</li>
<li>The app state is updated frequently over time</li>
<li>The logic to update that state may be complex</li>
<li>The app has a medium or large-sized codebase, and might be worked on by many people</li>
</ul>
<p><strong>Not all apps need Redux. Take some time to think about the kind of app you’re building, and decide what tools would be best to help solve the problems you’re working on.</strong></p>
<p>:::info Want to Know More?</p>
<p>If you’re not sure whether Redux is a good choice for your app, these resources give some more guidance:</p>
<ul>
<li><strong><a href="https://changelog.com/posts/when-and-when-not-to-reach-for-redux">When (and when not) to reach for Redux</a></strong></li>
<li><strong><a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/">The Tao of Redux, Part 1 - Implementation and Intent</a></strong></li>
<li><strong><a href="../../faq/General.md#when-should-i-use-redux">Redux FAQ: When should I use Redux?</a></strong></li>
<li><strong><a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">You Might Not Need Redux</a></strong></li>
</ul>
<p>:::</p>
<h3 id="redux-libraries-and-tools-1">Redux Libraries and Tools</h3>
<p>Redux is a small standalone JS library. However, it is commonly used with several other packages:</p>
<h4 id="react-redux-1">React-Redux</h4>
<p>Redux can integrate with any UI framework, and is most frequently used with React. <a href="https://react-redux.js.org/"><strong>React-Redux</strong></a> is our official package that lets your React components interact with a Redux store by reading pieces of state and dispatching actions to update the store.</p>
<h4 id="redux-toolkit-3">Redux Toolkit</h4>
<p><a href="https://redux-toolkit.js.org"><strong>Redux Toolkit</strong></a> is our recommended approach for writing Redux logic. It contains packages and functions that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications.</p>
<h4 id="redux-devtools-extension-1">Redux DevTools Extension</h4>
<p>The <a href="https://github.com/zalmoxisus/redux-devtools-extension"><strong>Redux DevTools Extension</strong></a> shows a history of the changes to the state in your Redux store over time. This allows you to debug your applications effectively, including using powerful techniques like “time-travel debugging”.</p>
<h2 id="redux-terms-and-concepts">Redux Terms and Concepts</h2>
<p>Before we dive into some actual code, let’s talk about some of the terms and concepts you’ll need to know to use Redux.</p>
<h3 id="state-management-1">State Management</h3>
<p>Let’s start by looking at a small React counter component. It tracks a number in component state, and increments the number when a button is clicked:</p>
<pre class="jsx"><code>function Counter() {
  // State: a counter value
  const [counter, setCounter] = useState(0);

  // Action: code that causes an update to the state when something happens
  const increment = () =&gt; {
    setCounter((prevCounter) =&gt; prevCounter + 1);
  };

  // View: the UI definition
  return (
    &lt;div&gt;
      Value: {counter} &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>It is a self-contained app with the following parts:</p>
<ul>
<li>The <strong>state</strong>, the source of truth that drives our app;</li>
<li>The <strong>view</strong>, a declarative description of the UI based on the current state</li>
<li>The <strong>actions</strong>, the events that occur in the app based on user input, and trigger updates in the state</li>
</ul>
<p>This is a small example of <strong>“one-way data flow”</strong>:</p>
<ul>
<li>State describes the condition of the app at a specific point in time</li>
<li>The UI is rendered based on that state</li>
<li>When something happens (such as a user clicking a button), the state is updated based on what occurred</li>
<li>The UI re-renders based on the new state</li>
</ul>
<figure>
<img src="/img/tutorials/essentials/one-way-data-flow.png" alt="One-way data flow" /><figcaption>One-way data flow</figcaption>
</figure>
<p>However, the simplicity can break down when we have <strong>multiple components that need to share and use the same state</strong>, especially if those components are located in different parts of the application. Sometimes this can be solved by <a href="https://reactjs.org/docs/lifting-state-up.html">“lifting state up”</a> to parent components, but that doesn’t always help.</p>
<p>One way to solve this is to extract the shared state from the components, and put it into a centralized location outside the component tree. With this, our component tree becomes a big “view”, and any component can access the state or trigger actions, no matter where they are in the tree!</p>
<p>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</p>
<p>This is the basic idea behind Redux: a single centralized place to contain the global state in your application, and specific patterns to follow when updating that state to make the code predictable.</p>
<h3 id="immutability-1">Immutability</h3>
<p>“Mutable” means “changeable”. If something is “immutable”, it can never be changed.</p>
<p>JavaScript objects and arrays are all mutable by default. If I create an object, I can change the contents of its fields. If I create an array, I can change the contents as well:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb264-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">2</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb264-2" title="2"><span class="co">// still the same object outside, but the contents have changed</span></a>
<a class="sourceLine" id="cb264-3" title="3"><span class="va">obj</span>.<span class="at">b</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></a>
<a class="sourceLine" id="cb264-4" title="4"></a>
<a class="sourceLine" id="cb264-5" title="5"><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb264-6" title="6"><span class="co">// In the same way, we can change the contents of this array</span></a>
<a class="sourceLine" id="cb264-7" title="7"><span class="va">arr</span>.<span class="at">push</span>(<span class="st">&quot;c&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb264-8" title="8">arr[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;d&quot;</span><span class="op">;</span></a></code></pre></div>
<p>This is called <em>mutating</em> the object or array. It’s the same object or array reference in memory, but now the contents inside the object have changed.</p>
<p><strong>In order to update values immutably, your code must make <em>copies</em> of existing objects/arrays, and then modify the copies</strong>.</p>
<p>We can do this by hand using JavaScript’s array / object spread operators, as well as array methods that return new copies of the array instead of mutating the original array:</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb265-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb265-2" title="2">  <span class="dt">a</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb265-3" title="3">    <span class="co">// To safely update obj.a.c, we have to copy each piece</span></a>
<a class="sourceLine" id="cb265-4" title="4">    <span class="dt">c</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span></a>
<a class="sourceLine" id="cb265-5" title="5">  <span class="op">},</span></a>
<a class="sourceLine" id="cb265-6" title="6">  <span class="dt">b</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span></a>
<a class="sourceLine" id="cb265-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb265-8" title="8"></a>
<a class="sourceLine" id="cb265-9" title="9"><span class="kw">const</span> obj2 <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb265-10" title="10">  <span class="co">// copy obj</span></a>
<a class="sourceLine" id="cb265-11" title="11">  ...<span class="at">obj</span><span class="op">,</span></a>
<a class="sourceLine" id="cb265-12" title="12">  <span class="co">// overwrite a</span></a>
<a class="sourceLine" id="cb265-13" title="13">  <span class="dt">a</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb265-14" title="14">    <span class="co">// copy obj.a</span></a>
<a class="sourceLine" id="cb265-15" title="15">    ...<span class="va">obj</span>.<span class="at">a</span><span class="op">,</span></a>
<a class="sourceLine" id="cb265-16" title="16">    <span class="co">// overwrite c</span></a>
<a class="sourceLine" id="cb265-17" title="17">    <span class="dt">c</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span></a>
<a class="sourceLine" id="cb265-18" title="18">  <span class="op">},</span></a>
<a class="sourceLine" id="cb265-19" title="19"><span class="op">};</span></a>
<a class="sourceLine" id="cb265-20" title="20"></a>
<a class="sourceLine" id="cb265-21" title="21"><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb265-22" title="22"><span class="co">// Create a new copy of arr, with &quot;c&quot; appended to the end</span></a>
<a class="sourceLine" id="cb265-23" title="23"><span class="kw">const</span> arr2 <span class="op">=</span> <span class="va">arr</span>.<span class="at">concat</span>(<span class="st">&quot;c&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb265-24" title="24"></a>
<a class="sourceLine" id="cb265-25" title="25"><span class="co">// or, we can make a copy of the original array:</span></a>
<a class="sourceLine" id="cb265-26" title="26"><span class="kw">const</span> arr3 <span class="op">=</span> <span class="va">arr</span>.<span class="at">slice</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb265-27" title="27"><span class="co">// and mutate the copy:</span></a>
<a class="sourceLine" id="cb265-28" title="28"><span class="va">arr3</span>.<span class="at">push</span>(<span class="st">&quot;c&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p><strong>Redux expects that all state updates are done immutably</strong>. We’ll look at where and how this is important a bit later, as well as some easier ways to write immutable update logic.</p>
<p>:::info Want to Know More?</p>
<p>For more info on how immutability works in JavaScript, see:</p>
<ul>
<li><a href="https://daveceddia.com/javascript-references/">A Visual Guide to References in JavaScript</a></li>
<li><a href="https://daveceddia.com/react-redux-immutability-guide/">Immutability in React and Redux: The Complete Guide</a></li>
</ul>
<p>:::</p>
<h3 id="terminology">Terminology</h3>
<p>There are some important Redux terms that you’ll need to be familiar with before we continue:</p>
<h4 id="actions-3">Actions</h4>
<p>An <strong>action</strong> is a plain JavaScript object that has a <code>type</code> field. <strong>You can think of an action as an event that describes something that happened in the application</strong>.</p>
<p>The <code>type</code> field should be a string that gives this action a descriptive name, like <code>"todos/todoAdded"</code>. We usually write that type string like <code>"domain/eventName"</code>, where the first part is the feature or category that this action belongs to, and the second part is the specific thing that happened.</p>
<p>An action object can have other fields with additional information about what happened. By convention, we put that information in a field called <code>payload</code>.</p>
<p>A typical action object might look like this:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb266-1" title="1"><span class="kw">const</span> addTodoAction <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb266-2" title="2">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todoAdded&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb266-3" title="3">  <span class="dt">payload</span><span class="op">:</span> <span class="st">&quot;Buy milk&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb266-4" title="4"><span class="op">};</span></a></code></pre></div>
<h4 id="action-creators-2">Action Creators</h4>
<p>An <strong>action creator</strong> is a function that creates and returns an action object. We typically use these so we don’t have to write the action object by hand every time:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb267-1" title="1"><span class="kw">const</span> addTodo <span class="op">=</span> (text) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb267-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb267-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;todos/todoAdded&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb267-4" title="4">    <span class="dt">payload</span><span class="op">:</span> text<span class="op">,</span></a>
<a class="sourceLine" id="cb267-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb267-6" title="6"><span class="op">};</span></a></code></pre></div>
<h4 id="reducers-5">Reducers</h4>
<p>A <strong>reducer</strong> is a function that receives the current <code>state</code> and an <code>action</code> object, decides how to update the state if necessary, and returns the new state: <code>(state, action) =&gt; newState</code>. <strong>You can think of a reducer as an event listener which handles events based on the received action (event) type.</strong></p>
<div class="info">
<p>“Reducer” functions get their name because they’re similar to the kind of callback function you pass to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><code>Array.reduce()</code></a> method.</p>
</div>
<p>Reducers must <em>always</em> follow some specific rules:</p>
<ul>
<li>They should only calculate the new state value based on the <code>state</code> and <code>action</code> arguments</li>
<li>They are not allowed to modify the existing <code>state</code>. Instead, they must make <em>immutable updates</em>, by copying the existing <code>state</code> and making changes to the copied values.</li>
<li>They must not do any asynchronous logic, calculate random values, or cause other “side effects”</li>
</ul>
<p>We’ll talk more about the rules of reducers later, including why they’re important and how to follow them correctly.</p>
<p>The logic inside reducer functions typically follows the same series of steps:</p>
<ul>
<li>Check to see if the reducer cares about this action
<ul>
<li>If so, make a copy of the state, update the copy with new values, and return it</li>
</ul></li>
<li>Otherwise, return the existing state unchanged</li>
</ul>
<p>Here’s a small example of a reducer, showing the steps that each reducer should follow:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb268-1" title="1"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb268-2" title="2"></a>
<a class="sourceLine" id="cb268-3" title="3"><span class="kw">function</span> <span class="at">counterReducer</span>(state <span class="op">=</span> initialState<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb268-4" title="4">  <span class="co">// Check to see if the reducer cares about this action</span></a>
<a class="sourceLine" id="cb268-5" title="5">  <span class="cf">if</span> (<span class="va">action</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&quot;counter/increment&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb268-6" title="6">    <span class="co">// If so, make a copy of `state`</span></a>
<a class="sourceLine" id="cb268-7" title="7">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb268-8" title="8">      ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb268-9" title="9">      <span class="co">// and update the copy with the new value</span></a>
<a class="sourceLine" id="cb268-10" title="10">      <span class="dt">value</span><span class="op">:</span> <span class="va">state</span>.<span class="at">value</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb268-11" title="11">    <span class="op">};</span></a>
<a class="sourceLine" id="cb268-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb268-13" title="13">  <span class="co">// otherwise return the existing state unchanged</span></a>
<a class="sourceLine" id="cb268-14" title="14">  <span class="cf">return</span> state<span class="op">;</span></a>
<a class="sourceLine" id="cb268-15" title="15"><span class="op">}</span></a></code></pre></div>
<p>Reducers can use any kind of logic inside to decide what the new state should be: <code>if/else</code>, <code>switch</code>, loops, and so on.</p>
<p><DetailedExplanation title="Detailed Explanation: Why Are They Called 'Reducers?'" ></p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><code>Array.reduce()</code></a> method lets you take an array of values, process each item in the array one at a time, and return a single final result. You can think of it as “reducing the array down to one value”.</p>
<p><code>Array.reduce()</code> takes a callback function as an argument, which will be called one time for each item in the array. It takes two arguments:</p>
<ul>
<li><code>previousResult</code>, the value that your callback returned last time</li>
<li><code>currentItem</code>, the current item in the array</li>
</ul>
<p>The first time that the callback runs, there isn’t a <code>previousResult</code> available, so we need to also pass in an initial value that will be used as the first <code>previousResult</code>.</p>
<p>If we wanted to add together an array of numbers to find out what the total is, we could write a reduce callback that looks like this:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb269-1" title="1"><span class="kw">const</span> numbers <span class="op">=</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb269-2" title="2"></a>
<a class="sourceLine" id="cb269-3" title="3"><span class="kw">const</span> addNumbers <span class="op">=</span> (previousResult<span class="op">,</span> currentItem) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb269-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="op">{</span> previousResult<span class="op">,</span> currentItem <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb269-5" title="5">  <span class="cf">return</span> previousResult <span class="op">+</span> currentItem<span class="op">;</span></a>
<a class="sourceLine" id="cb269-6" title="6"><span class="op">};</span></a>
<a class="sourceLine" id="cb269-7" title="7"></a>
<a class="sourceLine" id="cb269-8" title="8"><span class="kw">const</span> initialValue <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb269-9" title="9"></a>
<a class="sourceLine" id="cb269-10" title="10"><span class="kw">const</span> total <span class="op">=</span> <span class="va">numbers</span>.<span class="at">reduce</span>(addNumbers<span class="op">,</span> initialValue)<span class="op">;</span></a>
<a class="sourceLine" id="cb269-11" title="11"><span class="co">// {previousResult: 0, currentItem: 2}</span></a>
<a class="sourceLine" id="cb269-12" title="12"><span class="co">// {previousResult: 2, currentItem: 5}</span></a>
<a class="sourceLine" id="cb269-13" title="13"><span class="co">// {previousResult: 7, currentItem: 8}</span></a>
<a class="sourceLine" id="cb269-14" title="14"></a>
<a class="sourceLine" id="cb269-15" title="15"><span class="va">console</span>.<span class="at">log</span>(total)<span class="op">;</span></a>
<a class="sourceLine" id="cb269-16" title="16"><span class="co">// 15</span></a></code></pre></div>
<p>Notice that this <code>addNumbers</code> “reduce callback” function doesn’t need to keep track of anything itself. It takes the <code>previousResult</code> and <code>currentItem</code> arguments, does something with them, and returns a new result value.</p>
<p><strong>A Redux reducer function is exactly the same idea as this “reduce callback” function!</strong> It takes a “previous result” (the <code>state</code>), and the “current item” (the <code>action</code> object), decides a new state value based on those arguments, and returns that new state.</p>
<p>If we were to create an array of Redux actions, call <code>reduce()</code>, and pass in a reducer function, we’d get a final result the same way:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb270-1" title="1"><span class="kw">const</span> actions <span class="op">=</span> [</a>
<a class="sourceLine" id="cb270-2" title="2">  <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/increment&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb270-3" title="3">  <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/increment&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb270-4" title="4">  <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/increment&quot;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb270-5" title="5">]<span class="op">;</span></a>
<a class="sourceLine" id="cb270-6" title="6"></a>
<a class="sourceLine" id="cb270-7" title="7"><span class="kw">const</span> initialState <span class="op">=</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb270-8" title="8"></a>
<a class="sourceLine" id="cb270-9" title="9"><span class="kw">const</span> finalResult <span class="op">=</span> <span class="va">actions</span>.<span class="at">reduce</span>(counterReducer<span class="op">,</span> initialState)<span class="op">;</span></a>
<a class="sourceLine" id="cb270-10" title="10"><span class="va">console</span>.<span class="at">log</span>(finalResult)<span class="op">;</span></a>
<a class="sourceLine" id="cb270-11" title="11"><span class="co">// {value: 3}</span></a></code></pre></div>
<p>We can say that <strong>Redux reducers reduce a set of actions (over time) into a single state</strong>. The difference is that with <code>Array.reduce()</code> it happens all at once, and with Redux, it happens over the lifetime of your running app.</p>
<p></DetailedExplanation></p>
<h4 id="store-3">Store</h4>
<p>The current Redux application state lives in an object called the <strong>store</strong> .</p>
<p>The store is created by passing in a reducer, and has a method called <code>getState</code> that returns the current state value:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb271-1" title="1"><span class="im">import</span> <span class="op">{</span> configureStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb271-2" title="2"></a>
<a class="sourceLine" id="cb271-3" title="3"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span> <span class="dt">reducer</span><span class="op">:</span> counterReducer <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb271-4" title="4"></a>
<a class="sourceLine" id="cb271-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb271-6" title="6"><span class="co">// {value: 0}</span></a></code></pre></div>
<h4 id="dispatch-1">Dispatch</h4>
<p>The Redux store has a method called <code>dispatch</code>. <strong>The only way to update the state is to call <code>store.dispatch()</code> and pass in an action object</strong>. The store will run its reducer function and save the new state value inside, and we can call <code>getState()</code> to retrieve the updated value:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb272-1" title="1"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/increment&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb272-2" title="2"></a>
<a class="sourceLine" id="cb272-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb272-4" title="4"><span class="co">// {value: 1}</span></a></code></pre></div>
<p><strong>You can think of dispatching actions as “triggering an event”</strong> in the application. Something happened, and we want the store to know about it. Reducers act like event listeners, and when they hear an action they are interested in, they update the state in response.</p>
<p>We typically call action creators to dispatch the right action:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb273-1" title="1"><span class="kw">const</span> increment <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb273-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb273-3" title="3">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;counter/increment&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb273-4" title="4">  <span class="op">};</span></a>
<a class="sourceLine" id="cb273-5" title="5"><span class="op">};</span></a>
<a class="sourceLine" id="cb273-6" title="6"></a>
<a class="sourceLine" id="cb273-7" title="7"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">increment</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb273-8" title="8"></a>
<a class="sourceLine" id="cb273-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb273-10" title="10"><span class="co">// {value: 2}</span></a></code></pre></div>
<h4 id="selectors-2">Selectors</h4>
<p><strong>Selectors</strong> are functions that know how to extract specific pieces of information from a store state value. As an application grows bigger, this can help avoid repeating logic as different parts of the app need to read the same data:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb274-1" title="1"><span class="kw">const</span> selectCounterValue <span class="op">=</span> (state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="at">value</span><span class="op">;</span></a>
<a class="sourceLine" id="cb274-2" title="2"></a>
<a class="sourceLine" id="cb274-3" title="3"><span class="kw">const</span> currentValue <span class="op">=</span> <span class="at">selectCounterValue</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb274-4" title="4"><span class="va">console</span>.<span class="at">log</span>(currentValue)<span class="op">;</span></a>
<a class="sourceLine" id="cb274-5" title="5"><span class="co">// 2</span></a></code></pre></div>
<h3 id="redux-application-data-flow-1">Redux Application Data Flow</h3>
<p>Earlier, we talked about “one-way data flow”, which describes this sequence of steps to update the app:</p>
<ul>
<li>State describes the condition of the app at a specific point in time</li>
<li>The UI is rendered based on that state</li>
<li>When something happens (such as a user clicking a button), the state is updated based on what occurred</li>
<li>The UI re-renders based on the new state</li>
</ul>
<p>For Redux specifically, we can break these steps into more detail:</p>
<ul>
<li>Initial setup:
<ul>
<li>A Redux store is created using a root reducer function</li>
<li>The store calls the root reducer once, and saves the return value as its initial <code>state</code></li>
<li>When the UI is first rendered, UI components access the current state of the Redux store, and use that data to decide what to render. They also subscribe to any future store updates so they can know if the state has changed.</li>
</ul></li>
<li>Updates:
<ul>
<li>Something happens in the app, such as a user clicking a button</li>
<li>The app code dispatches an action to the Redux store, like <code>dispatch({type: 'counter/increment'})</code></li>
<li>The store runs the reducer function again with the previous <code>state</code> and the current <code>action</code>, and saves the return value as the new <code>state</code></li>
<li>The store notifies all parts of the UI that are subscribed that the store has been updated</li>
<li>Each UI component that needs data from the store checks to see if the parts of the state they need have changed.</li>
<li>Each component that sees its data has changed forces a re-render with the new data, so it can update what’s shown on the screen</li>
</ul></li>
</ul>
<p>Here’s what that data flow looks like visually:</p>
<figure>
<img src="/img/tutorials/essentials/ReduxDataFlowDiagram.gif" alt="Redux data flow diagram" /><figcaption>Redux data flow diagram</figcaption>
</figure>
<h2 id="what-youve-learned-8">What You’ve Learned</h2>
<p>Redux does have a number of new terms and concepts to remember. As a reminder, here’s what we just covered:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux is a library for managing global application state</strong>
<ul>
<li>Redux is typically used with the React-Redux library for integrating Redux and React together</li>
<li>Redux Toolkit is the recommended way to write Redux logic</li>
</ul></li>
<li><strong>Redux uses a “one-way data flow” app structure</strong>
<ul>
<li>State describes the condition of the app at a point in time, and UI renders based on that state</li>
<li>When something happens in the app:
<ul>
<li>The UI dispatches an action</li>
<li>The store runs the reducers, and the state is updated based on what occurred</li>
<li>The store notifies the UI that the state has changed</li>
</ul></li>
<li>The UI re-renders based on the new state</li>
</ul></li>
<li><strong>Redux uses several types of code</strong>
<ul>
<li><em>Actions</em> are plain objects with a <code>type</code> field, and describe “what happened” in the app</li>
<li><em>Reducers</em> are functions that calculate a new state value based on previous state + an action</li>
<li>A Redux <em>store</em> runs the root reducer whenever an action is <em>dispatched</em></li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-7">What’s Next?</h2>
<p>We’ve seen each of the individual pieces of a Redux app. Next, continue on to <a href="./part-2-app-structure.md">Part 2: Redux App Structure</a>, where we’ll look at a full working example to see how the pieces fit together.</p>
<hr />
<p>id: part-2-app-structure title: ‘Redux Essentials, Part 2: Redux App Structure’ sidebar_label: ‘Redux App Structure’ description: ‘The official Redux Essentials tutorial: learn the structure of a typical React + Redux app’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>The structure of a typical React + Redux app</li>
<li>How to view state changes in the Redux DevTools Extension</li>
</ul>
<p>:::</p>
<h2 id="introduction-8">Introduction</h2>
<p>In <a href="./part-1-overview-concepts.md">Part 1: Redux Overview and Concepts</a>, we looked at why Redux is useful, the terms and concepts used to describe different parts of Redux code, and how data flows through a Redux app.</p>
<p>Now, let’s look at a real working example to see how these pieces fit together.</p>
<h2 id="the-counter-example-app">The Counter Example App</h2>
<p>The sample project we’ll look at is a small counter application that lets us add or subtract from a number as we click buttons. It may not be very exciting, but it shows all the important pieces of a React+Redux application in action.</p>
<p>The project has been created using <a href="https://github.com/reduxjs/cra-template-redux">the official Redux template for Create-React-App</a>. Out of the box, it has already been configured with a standard Redux application structure, using <a href="https://redux-toolkit.js.org">Redux Toolkit</a> to create the Redux store and logic, and <a href="https://react-redux.js.org">React-Redux</a> to connect together the Redux store and the React components.</p>
<p>Here’s the live version of the project. You can play around with it by clicking the buttons in the app preview on the right, and browse through the source files on the left.</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-counter-example/tree/master/?fontsize=14&amp;hidenavigation=1&amp;module=%2Fsrc%2Ffeatures%2Fcounter%2FcounterSlice.js&amp;theme=dark&amp;runonclick=1" title="redux-essentials-example" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>If you’d like to try create this project on your own computer, you can <a href="https://create-react-app.dev/docs/getting-started#selecting-a-template">start a new Create-React-App project</a> using our Redux template:</p>
<pre><code>npx create-react-app redux-essentials-example --template redux</code></pre>
<h3 id="using-the-counter-app">Using the Counter App</h3>
<p>The counter app has already been set up to let us watch what happens inside as we use it.</p>
<p>Open up your browser’s DevTools. Then, choose the “Redux” tab in the DevTools, and click the “State” button in the upper-right toolbar. You should see something that looks like this:</p>
<figure>
<img src="/img/tutorials/essentials/devtools-initial.png" alt="Redux DevTools: initial app state" /><figcaption>Redux DevTools: initial app state</figcaption>
</figure>
<p>On the right, we can see that our Redux store is starting off with an app state value that looks like this:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb276-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb276-2" title="2">  <span class="dt">counter</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb276-3" title="3">    <span class="dt">value</span><span class="op">:</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb276-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb276-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>The DevTools will show us how the store state changes as we use the app.</p>
<p>Let’s play with the app first to see what it does. Click the “+” button in the app, then look at the “Diff” tab in the Redux DevTools:</p>
<figure>
<img src="/img/tutorials/essentials/devtools-first-action.png" alt="Redux DevTools: first dispatched action" /><figcaption>Redux DevTools: first dispatched action</figcaption>
</figure>
<p>We can see two important things here:</p>
<ul>
<li>When we clicked the “+” button, an action with a type of <code>"counter/increment"</code> was dispatched to the store</li>
<li>When that action was dispatched, the <code>state.counter.value</code> field changed from <code>0</code> to <code>1</code></li>
</ul>
<p>Now try these steps:</p>
<ul>
<li>Click the “+” button again. The displayed value should now be 2.</li>
<li>Click the “-” button once. The displayed value should now be 1.</li>
<li>Click the “Add Amount” button. The displayed value should now be 3.</li>
<li>Change the number “2” in the textbox to a “3”</li>
<li>Click the “Add Async” button. You should see a progress bar fill the button, and after a couple seconds, the displayed value should change to 6.</li>
</ul>
<p>Go back to the Redux DevTools. You should see a total of five actions dispatched, one for each time we clicked a button . Now select the last <code>"counter/incrementByAmount"</code> entry from the list on the left, and click the “Action” tab on the right side:</p>
<figure>
<img src="/img/tutorials/essentials/devtools-done-clicking.png" alt="Redux DevTools: done clicking buttons" /><figcaption>Redux DevTools: done clicking buttons</figcaption>
</figure>
<p>We can see that this action object looked like this:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb277-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb277-2" title="2">  <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;counter/incrementByAmount&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb277-3" title="3">  <span class="dt">payload</span><span class="op">:</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb277-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>And if you click the “Diff” tab, you can see that the <code>state.counter.value</code> field changed from a <code>3</code> to a <code>6</code> in response to that action.</p>
<p>The ability to see what is happening inside of our app and how our state is changing over time is very powerful!</p>
<p>The DevTools have several more commands and options to help you debug your app. Try clicking the “Trace” tab in the upper right. You should see a JavaScript function stack trace in the panel, with several sections of source code showing the lines that were executing when the action reached the store. One line in particular should be highlighted: the line of code where we dispatched this action from the <code>&lt;Counter&gt;</code> component:</p>
<figure>
<img src="/img/tutorials/essentials/devtools-action-stacktrace.png" alt="Redux DevTools: action stack traces" /><figcaption>Redux DevTools: action stack traces</figcaption>
</figure>
<p>This makes it easier to trace what part of the code dispatched a specific action.</p>
<h2 id="application-contents">Application Contents</h2>
<p>Now that you know what the app does, let’s look at how it works.</p>
<p>Here are the key files that make up this application:</p>
<ul>
<li><code>/src</code>
<ul>
<li><code>index.js</code>: the starting point for the app</li>
<li><code>App.js</code>: the top-level React component</li>
<li><code>/app</code>
<ul>
<li><code>store.js</code>: creates the Redux store instance</li>
</ul></li>
<li><code>/features</code>
<ul>
<li><code>/counter</code>
<ul>
<li><code>Counter.js</code>: a React component that shows the UI for the counter feature</li>
<li><code>counterSlice.js</code>: the Redux logic for the counter feature</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>Let’s start by looking at how the Redux store is created.</p>
<h3 id="creating-the-redux-store">Creating the Redux Store</h3>
<p>Open up <code>app/store.js</code>, which should look like this:</p>
<p>```js title=“app/store.js” import { configureStore } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; import counterReducer from “../features/counter/counterSlice”;</p>
<p>export default configureStore({ reducer: { counter: counterReducer, }, }); ```</p>
<p>The Redux store is created using the <code>configureStore</code> function from Redux Toolkit. <code>configureStore</code> requires that we pass in a <code>reducer</code> argument.</p>
<p>Our application might be made up of many different features, and each of those features might have its own reducer function. When we call <code>configureStore</code>, we can pass in all of the different reducers in an object. The key names in the object will define the keys in our final state value.</p>
<p>We have a file named <code>features/counter/counterSlice.js</code> that exports a reducer function for the counter logic. We can import that <code>counterReducer</code> function here, and include it when we create the store.</p>
<p>When we pass in an object like <code>{counter: counterReducer}</code>, that says that we want to have a <code>state.counter</code> section of our Redux state object, and that we want the <code>counterReducer</code> function to be in charge of deciding if and how to update the <code>state.counter</code> section whenever an action is dispatched.</p>
<p>Redux allows store setup to be customized with different kinds of plugins (“middleware” and “enhancers”). <code>configureStore</code> automatically adds several middleware to the store setup by default to provide a good developer experience, and also sets up the store so that the Redux DevTools Extension can inspect its contents.</p>
<h4 id="redux-slices">Redux Slices</h4>
<p><strong>A “slice” is a collection of Redux reducer logic and actions for a single feature in your app</strong>, typically defined together in a single file. The name comes from splitting up the root Redux state object into multiple “slices” of state.</p>
<p>For example, in a blogging app, our store setup might look like:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb278-1" title="1"><span class="im">import</span> <span class="op">{</span> configureStore <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;@reduxjs/toolkit&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb278-2" title="2"><span class="im">import</span> usersReducer <span class="im">from</span> <span class="st">&quot;../features/users/usersSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb278-3" title="3"><span class="im">import</span> postsReducer <span class="im">from</span> <span class="st">&quot;../features/posts/postsSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb278-4" title="4"><span class="im">import</span> commentsReducer <span class="im">from</span> <span class="st">&quot;../features/comments/commentsSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb278-5" title="5"></a>
<a class="sourceLine" id="cb278-6" title="6"><span class="im">export</span> <span class="im">default</span> <span class="at">configureStore</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb278-7" title="7">  <span class="dt">reducer</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb278-8" title="8">    <span class="dt">users</span><span class="op">:</span> usersReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb278-9" title="9">    <span class="dt">posts</span><span class="op">:</span> postsReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb278-10" title="10">    <span class="dt">comments</span><span class="op">:</span> commentsReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb278-11" title="11">  <span class="op">},</span></a>
<a class="sourceLine" id="cb278-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>In that example, <code>state.users</code>, <code>state.posts</code>, and <code>state.comments</code> are each a separate “slice” of the Redux state. Since <code>usersReducer</code> is responsible for updating the <code>state.users</code> slice, we refer to it as a “slice reducer” function.</p>
<p><DetailedExplanation title="Detailed Explanation: Reducers and State Structure"></p>
<p>A Redux store needs to have a single “root reducer” function passed in when it’s created. So if we have many different slice reducer functions, how do we get a single root reducer instead, and how does this define the contents of the Redux store state?</p>
<p>If we tried calling all of the slice reducers by hand, it might look like this:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb279-1" title="1"><span class="kw">function</span> <span class="at">rootReducer</span>(state <span class="op">=</span> <span class="op">{},</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb279-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb279-3" title="3">    <span class="dt">users</span><span class="op">:</span> <span class="at">usersReducer</span>(<span class="va">state</span>.<span class="at">users</span><span class="op">,</span> action)<span class="op">,</span></a>
<a class="sourceLine" id="cb279-4" title="4">    <span class="dt">posts</span><span class="op">:</span> <span class="at">postsReducer</span>(<span class="va">state</span>.<span class="at">posts</span><span class="op">,</span> action)<span class="op">,</span></a>
<a class="sourceLine" id="cb279-5" title="5">    <span class="dt">comments</span><span class="op">:</span> <span class="at">commentsReducer</span>(<span class="va">state</span>.<span class="at">comments</span><span class="op">,</span> action)<span class="op">,</span></a>
<a class="sourceLine" id="cb279-6" title="6">  <span class="op">};</span></a>
<a class="sourceLine" id="cb279-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>That calls each slice reducer individually, passes in the specific slice of the Redux state, and includes each return value in the final new Redux state object.</p>
<p>Redux has a function called <a href="../../api/combineReducers.md"><code>combineReducers</code></a> that does this for us automatically. It accepts an object full of slice reducers as its argument, and returns a function that calls each slice reducer whenever an action is dispatched. The result from each slice reducer are all combined together into a single object as the final result. We can do the same thing as the previous example using <code>combineReducers</code>:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb280-1" title="1"><span class="kw">const</span> rootReducer <span class="op">=</span> <span class="at">combineReducers</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb280-2" title="2">  <span class="dt">users</span><span class="op">:</span> usersReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb280-3" title="3">  <span class="dt">posts</span><span class="op">:</span> postsReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb280-4" title="4">  <span class="dt">comments</span><span class="op">:</span> commentsReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb280-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>When we pass an object of slice reducers to <code>configureStore</code>, it passes those to <code>combineReducers</code> for us to generate the root reducer.</p>
<p>As we saw earlier, you can also pass a reducer function directly as the <code>reducer</code> argument:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb281-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb281-2" title="2">  <span class="dt">reducer</span><span class="op">:</span> rootReducer<span class="op">,</span></a>
<a class="sourceLine" id="cb281-3" title="3"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p></DetailedExplanation></p>
<h3 id="creating-slice-reducers-and-actions">Creating Slice Reducers and Actions</h3>
<p>Since we know that the <code>counterReducer</code> function is coming from <code>features/counter/counterSlice.js</code>, let’s see what’s in that file, piece by piece.</p>
<p>```js title=“features/counter/counterSlice.js” import { createSlice } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>export const counterSlice = createSlice({ name: “counter”, initialState: { value: 0, }, reducers: { increment: (state) =&gt; { // Redux Toolkit allows us to write “mutating” logic in reducers. It // doesn’t actually mutate the state because it uses the immer library, // which detects changes to a “draft state” and produces a brand new // immutable state based off those changes state.value += 1; }, decrement: (state) =&gt; { state.value -= 1; }, incrementByAmount: (state, action) =&gt; { state.value += action.payload; }, }, });</p>
<p>export const { increment, decrement, incrementByAmount } = counterSlice.actions;</p>
<p>export default counterSlice.reducer; ```</p>
<p>Earlier, we saw that clicking the different buttons in the UI dispatched three different Redux action types:</p>
<ul>
<li><code>{type: "counter/increment"}</code></li>
<li><code>{type: "counter/decrement"}</code></li>
<li><code>{type: "counter/incrementByAmount"}</code></li>
</ul>
<p>We know that actions are plain objects with a <code>type</code> field, the <code>type</code> field is always a string, and we typically have “action creator” functions that create and return the action objects. So where are those action objects, type strings, and action creators defined?</p>
<p>We <em>could</em> write those all by hand, every time. But, that would be tedious. Besides, what’s <em>really</em> important in Redux is the reducer functions, and the logic they have for calculating new state.</p>
<p>Redux Toolkit has a function called <code>createSlice</code>, which takes care of the work of generating action type strings, action creator functions, and action objects. All you have to do is define a name for this slice, write an object that has some reducer functions in it, and it generates the corresponding action code automatically. The string from the <code>name</code> option is used as the first part of each action type, and the key name of each reducer function is used as the second part. So, the <code>"counter"</code> name + the <code>"increment"</code> reducer function generated an action type of <code>{type: "counter/increment"}</code>. (After all, why write this by hand if the computer can do it for us!)</p>
<p>In addition to the <code>name</code> field, <code>createSlice</code> needs us to pass in the initial state value for the reducers, so that there is a <code>state</code> the first time it gets called. In this case, we’re providing an object with a <code>value</code> field that starts off at 0.</p>
<p>We can see here that there are three reducer functions, and that corresponds to the three different action types that were dispatched by clicking the different buttons.</p>
<p><code>createSlice</code> automatically generates action creators with the same names as the reducer functions we wrote. We can check that by calling one of them and seeing what it returns:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb282-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="va">counterSlice</span>.<span class="va">actions</span>.<span class="at">increment</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb282-2" title="2"><span class="co">// {type: &quot;counter/increment&quot;}</span></a></code></pre></div>
<p>It also generates the slice reducer function that knows how to respond to all these action types:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb283-1" title="1"><span class="kw">const</span> newState <span class="op">=</span> <span class="va">counterSlice</span>.<span class="at">reducer</span>(</a>
<a class="sourceLine" id="cb283-2" title="2">  <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="dv">10</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb283-3" title="3">  <span class="va">counterSlice</span>.<span class="va">actions</span>.<span class="at">increment</span>()</a>
<a class="sourceLine" id="cb283-4" title="4">)<span class="op">;</span></a>
<a class="sourceLine" id="cb283-5" title="5"><span class="va">console</span>.<span class="at">log</span>(newState)<span class="op">;</span></a>
<a class="sourceLine" id="cb283-6" title="6"><span class="co">// {value: 11}</span></a></code></pre></div>
<h3 id="rules-of-reducers-1">Rules of Reducers</h3>
<p>We said earlier that reducers must <strong>always</strong> follow some special rules:</p>
<ul>
<li>They should only calculate the new state value based on the <code>state</code> and <code>action</code> arguments</li>
<li>They are not allowed to modify the existing <code>state</code>. Instead, they must make <em>immutable updates</em>, by copying the existing <code>state</code> and making changes to the copied values.</li>
<li>They must not do any asynchronous logic or other “side effects”</li>
</ul>
<p>But why are these rules important? There’s a few different reasons:</p>
<ul>
<li>One of the goals of Redux is to make your code predictable. When a function’s output is only calculated from the input arguments, it’s easier to understand how that code works, and to test it.</li>
<li>On the other hand, if a function depends on variables outside itself, or behaves randomly, you never know what will happen when you run it.</li>
<li>If a function modifies other values, including its arguments, that can change the way the application works unexpectedly. This can be a common source of bugs, such as “I updated my state, but now my UI isn’t updating when it should!”</li>
<li>Some of the Redux DevTools capabilities depend on having your reducers follow these rules correctly</li>
</ul>
<p>The rule about “immutable updates” is particularly important, and worth talking about further.</p>
<h3 id="reducers-and-immutable-updates-1">Reducers and Immutable Updates</h3>
<p>Earlier, we talked about “mutation” (modifying existing object/array values) and “immutability” (treating values as something that cannot be changed).</p>
<p>In Redux, <strong>our reducers are <em>never</em> allowed to mutate the original / current state values!</strong></p>
<div class="sourceCode" id="cb284"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb284-1" title="1"><span class="co">// ❌ Illegal - by default, this will mutate the state!</span></a>
<a class="sourceLine" id="cb284-2" title="2"><span class="va">state</span>.<span class="at">value</span> <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></a></code></pre></div>
<p>:::</p>
<p>There are several reasons why you must not mutate state in Redux:</p>
<ul>
<li>It causes bugs, such as the UI not updating properly to show the latest values</li>
<li>It makes it harder to understand why and how the state has been updated</li>
<li>It makes it harder to write tests</li>
<li>It breaks the ability to use “time-travel debugging” correctly</li>
<li>It goes against the intended spirit and usage patterns for Redux</li>
</ul>
<p>So if we can’t change the originals, how do we return an updated state?</p>
<div class="tip">
<p><strong>Reducers can only make <em>copies</em> of the original values, and then they can mutate the copies.</strong></p>
<div class="sourceCode" id="cb285"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb285-1" title="1"><span class="co">// ✅ This is safe, because we made a copy</span></a>
<a class="sourceLine" id="cb285-2" title="2"><span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb285-3" title="3">  ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb285-4" title="4">  <span class="dt">value</span><span class="op">:</span> <span class="dv">123</span><span class="op">,</span></a>
<a class="sourceLine" id="cb285-5" title="5"><span class="op">};</span></a></code></pre></div>
</div>
<p>We already saw that we can <a href="./part-1-overview-concepts.md#immutability">write immutable updates by hand</a>, by using JavaScript’s array / object spread operators and other functions that return copies of the original values. However, if you’re thinking that “writing immutable updates by hand this way looks hard to remember and do correctly”… yeah, you’re right! :)</p>
<p>Writing immutable update logic by hand <em>is</em> hard, and accidentally mutating state in reducers is the single most common mistake Redux users make.</p>
<p><strong>That’s why Redux Toolkit’s <code>createSlice</code> function lets you write immutable updates an easier way!</strong></p>
<p><code>createSlice</code> uses a library called <a href="https://immerjs.github.io/immer/">Immer</a> inside. Immer uses a special JS tool called a <code>Proxy</code> to wrap the data you provide, and lets you write code that “mutates” that wrapped data. But, <strong>Immer tracks all the changes you’ve tried to make, and then uses that list of changes to return a safely immutably updated value</strong>, as if you’d written all the immutable update logic by hand.</p>
<p>So, instead of this:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb286-1" title="1"><span class="kw">function</span> <span class="at">handwrittenReducer</span>(state<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb286-2" title="2">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb286-3" title="3">    ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb286-4" title="4">    <span class="dt">first</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb286-5" title="5">      ...<span class="va">state</span>.<span class="at">first</span><span class="op">,</span></a>
<a class="sourceLine" id="cb286-6" title="6">      <span class="dt">second</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb286-7" title="7">        ...<span class="va">state</span>.<span class="va">first</span>.<span class="at">second</span><span class="op">,</span></a>
<a class="sourceLine" id="cb286-8" title="8">        [<span class="va">action</span>.<span class="at">someId</span>]<span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb286-9" title="9">          ...<span class="va">state</span>.<span class="va">first</span>.<span class="at">second</span>[<span class="va">action</span>.<span class="at">someId</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb286-10" title="10">          <span class="dt">fourth</span><span class="op">:</span> <span class="va">action</span>.<span class="at">someValue</span><span class="op">,</span></a>
<a class="sourceLine" id="cb286-11" title="11">        <span class="op">},</span></a>
<a class="sourceLine" id="cb286-12" title="12">      <span class="op">},</span></a>
<a class="sourceLine" id="cb286-13" title="13">    <span class="op">},</span></a>
<a class="sourceLine" id="cb286-14" title="14">  <span class="op">};</span></a>
<a class="sourceLine" id="cb286-15" title="15"><span class="op">}</span></a></code></pre></div>
<p>You can write code that looks like this:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb287-1" title="1"><span class="kw">function</span> <span class="at">reducerWithImmer</span>(state<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb287-2" title="2">  <span class="va">state</span>.<span class="va">first</span>.<span class="at">second</span>[<span class="va">action</span>.<span class="at">someId</span>].<span class="at">fourth</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">someValue</span><span class="op">;</span></a>
<a class="sourceLine" id="cb287-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>That’s a lot easier to read!</p>
<p>But, here’s something <em>very</em> important to remember:</p>
<div class="warning">
<p><strong>You can <em>only</em> write “mutating” logic in Redux Toolkit’s <code>createSlice</code> and <code>createReducer</code> because they use Immer inside! If you write mutating logic in reducers without Immer, it <em>will</em> mutate the state and cause bugs!</strong></p>
</div>
<p>With that in mind, let’s go back and look at the actual reducers from the counter slice.</p>
<p><code>js title="features/counter/counterSlice.js" export const counterSlice = createSlice({   name: "counter",   initialState: {     value: 0,   },   reducers: {     increment: (state) =&gt; {       // Redux Toolkit allows us to write "mutating" logic in reducers. It       // doesn't actually mutate the state because it uses the immer library,       // which detects changes to a "draft state" and produces a brand new       // immutable state based off those changes       state.value += 1;     },     decrement: (state) =&gt; {       state.value -= 1;     },     incrementByAmount: (state, action) =&gt; {       // highlight-next-line       state.value += action.payload;     },   }, });</code></p>
<p>We can see that the <code>increment</code> reducer will always add 1 to <code>state.value</code>. Because Immer knows we’ve made changes to the draft <code>state</code> object, we don’t have to actually return anything here. In the same way, the <code>decrement</code> reducer subtracts 1.</p>
<p>In both of those reducers, we don’t actually need to have our code look at the <code>action</code> object. It will be passed in anyway, but since we don’t need it, we can skip declaring <code>action</code> as a parameter for the reducers.</p>
<p>On the other hand, the <code>incrementByAmount</code> reducer <em>does</em> need to know something: how much it should be adding to the counter value. So, we declare the reducer as having both <code>state</code> and <code>action</code> arguments. In this case, we know that the amount we typed into the textbox is being put into the <code>action.payload</code> field, so we can add that to <code>state.value</code>.</p>
<p>:::info Want to Know More?</p>
<p>For more information on immutability and writing immutable updates, see <a href="../../usage/structuring-reducers/ImmutableUpdatePatterns.md">the “Immutable Update Patterns” docs page</a> and <a href="https://daveceddia.com/react-redux-immutability-guide/">The Complete Guide to Immutability in React and Redux</a>.</p>
<p>:::</p>
<h3 id="writing-async-logic-with-thunks">Writing Async Logic with Thunks</h3>
<p>So far, all the logic in our application has been synchronous. Actions are dispatched, the store runs the reducers and calculates the new state, and the dispatch function finishes. But, the JavaScript language has many ways to write code that is asynchronous, and our apps normally have async logic for things like fetching data from an API. We need a place to put that async logic in our Redux apps.</p>
<p>A <strong>thunk</strong> is a specific kind of Redux function that can contain asynchronous logic. Thunks are written using two functions:</p>
<ul>
<li>An inside thunk function, which gets <code>dispatch</code> and <code>getState</code> as arguments</li>
<li>The outside creator function, which creates and returns the thunk function</li>
</ul>
<p>The next function that’s exported from <code>counterSlice</code> is an example of a thunk action creator:</p>
<p><code>js title="features/counter/counterSlice.js" // The function below is called a thunk and allows us to perform async logic. // It can be dispatched like a regular action: `dispatch(incrementAsync(10))`. // This will call the thunk with the `dispatch` function as the first argument. // Async code can then be executed and other actions can be dispatched export const incrementAsync = (amount) =&gt; (dispatch) =&gt; {   setTimeout(() =&gt; {     dispatch(incrementByAmount(amount));   }, 1000); };</code></p>
<p>We can use them the same way we use a typical Redux action creator:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb288-1" title="1"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">incrementAsync</span>(<span class="dv">5</span>))<span class="op">;</span></a></code></pre></div>
<p>However, using thunks requires that the <code>redux-thunk</code> <em>middleware</em> (a type of plugin for Redux) be added to the Redux store when it’s created. Fortunately, Redux Toolkit’s <code>configureStore</code> function already sets that up for us automatically, so we can go ahead and use thunks here.</p>
<p>When you need to make AJAX calls to fetch data from the server, you can put that call in a thunk. Here’s an example that’s written a bit longer, so you can see how it’s defined:</p>
<p><code>js title="features/counter/counterSlice.js" // the outside "thunk creator" function const fetchUserById = (userId) =&gt; {   // the inside "thunk function"   return async (dispatch, getState) =&gt; {     try {       // make an async call in the thunk       const user = await userAPI.fetchById(userId);       // dispatch an action when we get the response back       dispatch(userLoaded(user));     } catch (err) {       // If something went wrong, handle it here     }   }; };</code></p>
<p>We’ll see thunks being used in <a href="./part-5-async-logic.md">Part 5: Async Logic and Data Fetching</a></p>
<p><DetailedExplanation title="Detailed Explanation: Thunks and Async Logic"></p>
<p>We know that we’re not allowed to put any kind of async logic in reducers. But, that logic has to live somewhere.</p>
<p>If we have access to the Redux store, we could write some async code and call <code>store.dispatch()</code> when we’re done:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb289-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span> <span class="dt">reducer</span><span class="op">:</span> counterReducer <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb289-2" title="2"></a>
<a class="sourceLine" id="cb289-3" title="3"><span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb289-4" title="4">  <span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">increment</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb289-5" title="5"><span class="op">},</span> <span class="dv">250</span>)<span class="op">;</span></a></code></pre></div>
<p>But, in a real Redux app, we’re not allowed to import the store into other files, especially in our React components, because it makes that code harder to test and reuse.</p>
<p>In addition, we often need to write some async logic that we know will be used with <em>some</em> store, eventually, but we don’t know <em>which</em> store.</p>
<p>The Redux store can be extended with “middleware”, which are a kind of add-on or plugin that can add extra abilities. The most common reason to use middleware is to let you write code that can have async logic, but still talk to the store at the same time. They can also modify the store so that we can call <code>dispatch()</code> and pass in values that are <em>not</em> plain action objects, like functions or Promises.</p>
<p>The Redux Thunk middleware modifies the store to let you pass functions into <code>dispatch</code>. In fact, it’s short enough we can paste it here:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb290-1" title="1"><span class="kw">const</span> thunkMiddleware <span class="op">=</span></a>
<a class="sourceLine" id="cb290-2" title="2">  (<span class="op">{</span> dispatch<span class="op">,</span> getState <span class="op">}</span>) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb290-3" title="3">  (next) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb290-4" title="4">  (action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb290-5" title="5">    <span class="cf">if</span> (<span class="kw">typeof</span> action <span class="op">===</span> <span class="st">&quot;function&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb290-6" title="6">      <span class="cf">return</span> <span class="at">action</span>(dispatch<span class="op">,</span> getState)<span class="op">;</span></a>
<a class="sourceLine" id="cb290-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb290-8" title="8"></a>
<a class="sourceLine" id="cb290-9" title="9">    <span class="cf">return</span> <span class="at">next</span>(action)<span class="op">;</span></a>
<a class="sourceLine" id="cb290-10" title="10">  <span class="op">};</span></a></code></pre></div>
<p>It looks to see if the “action” that was passed into <code>dispatch</code> is actually a function instead of a plain action object. If it’s actually a function, it calls the function, and returns the result. Otherwise, since this must be an action object, it passes the action forward to the store.</p>
<p>This gives us a way to write whatever sync or async code we want, while still having access to <code>dispatch</code> and <code>getState</code>.</p>
<p></DetailedExplanation></p>
<p>There’s one more function in this file, but we’ll talk about that in a minute when we look at the <code>&lt;Counter&gt;</code> UI component.</p>
<p>:::info Want to Know More?</p>
<p>See <a href="https://github.com/reduxjs/redux-thunk">the Redux Thunk docs</a>, the post <a href="https://daveceddia.com/what-is-a-thunk/">What the heck is a thunk?</a> and the <a href="../../faq/Actions.md#how-can-i-represent-side-effects-such-as-ajax-calls-why-do-we-need-things-like-action-creators-thunks-and-middleware-to-do-async-behavior">Redux FAQ entry on “why do we use middleware for async?”</a> for more information.</p>
<p>:::</p>
<h3 id="the-react-counter-component">The React Counter Component</h3>
<p>Earlier, we saw what a standalone React <code>&lt;Counter&gt;</code> component looks like. Our React+Redux app has a similar <code>&lt;Counter&gt;</code> component, but it does a few things differently.</p>
<p>We’ll start by looking at the <code>Counter.js</code> component file:</p>
<p>```jsx title=“features/counter/Counter.js” import React, { useState } from “react”; import { useSelector, useDispatch } from “react-redux”; import { decrement, increment, incrementByAmount, incrementAsync, selectCount, } from “./counterSlice”; import styles from “./Counter.module.css”;</p>
<p>export function Counter() { const count = useSelector(selectCount); const dispatch = useDispatch(); const [incrementAmount, setIncrementAmount] = useState(“2”);</p>
return (
<div>
<pre><code>  &lt;div className={styles.row}&gt;
    // highlight-start
    &lt;button
      className={styles.button}
      aria-label=&quot;Increment value&quot;
      onClick={() =&gt; dispatch(increment())}
    &gt;
      +
    &lt;/button&gt;
    // highlight-end
    &lt;span className={styles.value}&gt;{count}&lt;/span&gt;
    &lt;button
      className={styles.button}
      aria-label=&quot;Decrement value&quot;
      onClick={() =&gt; dispatch(decrement())}
    &gt;
      -
    &lt;/button&gt;
  &lt;/div&gt;
  {/* omit additional rendering output here */}
&lt;/div&gt;</code></pre>
<p>); } ```</p>
<p>Like with the earlier plain React example, we have a function component called <code>Counter</code>, that stores some data in a <code>useState</code> hook.</p>
<p>However, in our component, it doesn’t look like we’re storing the actual current counter value as state. There <em>is</em> a variable called <code>count</code>, but it’s not coming from a <code>useState</code> hook.</p>
<p>While React includes several built-in hooks like <code>useState</code> and <code>useEffect</code>, other libraries can create their own <a href="https://reactjs.org/docs/hooks-custom.html">custom hooks</a> that use React’s hooks to build custom logic.</p>
<p>The <a href="https://react-redux.js.org/">React-Redux library</a> has <a href="https://react-redux.js.org/api/hooks">a set of custom hooks that allow your React component to interact with a Redux store</a>.</p>
<h4 id="reading-data-with-useselector">Reading Data with <code>useSelector</code></h4>
<p>First, the <code>useSelector</code> hook lets our component extract whatever pieces of data it needs from the Redux store state.</p>
<p>Earlier, we saw that we can write “selector” functions, which take <code>state</code> as an argument and return some part of the state value.</p>
<p>Our <code>counterSlice.js</code> has this selector function at the bottom:</p>
<p><code>js title="features/counter/counterSlice.js" // The function below is called a selector and allows us to select a value from // the state. Selectors can also be defined inline where they're used instead of // in the slice file. For example: `useSelector((state) =&gt; state.counter.value)` export const selectCount = (state) =&gt; state.counter.value;</code></p>
<p>If we had access to a Redux store, we could retrieve the current counter value as:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb292-1" title="1"><span class="kw">const</span> count <span class="op">=</span> <span class="at">selectCount</span>(<span class="va">store</span>.<span class="at">getState</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb292-2" title="2"><span class="va">console</span>.<span class="at">log</span>(count)<span class="op">;</span></a>
<a class="sourceLine" id="cb292-3" title="3"><span class="co">// 0</span></a></code></pre></div>
<p>Our components can’t talk to the Redux store directly, because we’re not allowed to import it into component files. But, <code>useSelector</code> takes care of talking to the Redux store behind the scenes for us. If we pass in a selector function, it calls <code>someSelector(store.getState())</code> for us, and returns the result.</p>
<p>So, we can get the current store counter value by doing:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb293-1" title="1"><span class="kw">const</span> count <span class="op">=</span> <span class="at">useSelector</span>(selectCount)<span class="op">;</span></a></code></pre></div>
<p>We don’t have to <em>only</em> use selectors that have already been exported, either. For example, we could write a selector function as an inline argument to <code>useSelector</code>:</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb294-1" title="1"><span class="kw">const</span> countPlusTwo <span class="op">=</span> <span class="at">useSelector</span>((state) <span class="kw">=&gt;</span> <span class="va">state</span>.<span class="va">counter</span>.<span class="at">value</span> <span class="op">+</span> <span class="dv">2</span>)<span class="op">;</span></a></code></pre></div>
<p>Any time an action has been dispatched and the Redux store has been updated, <code>useSelector</code> will re-run our selector function. If the selector returns a different value than last time, <code>useSelector</code> will make sure our component re-renders with the new value.</p>
<h4 id="dispatching-actions-with-usedispatch-1">Dispatching Actions with <code>useDispatch</code></h4>
<p>Similarly, we know that if we had access to a Redux store, we could dispatch actions using action creators, like <code>store.dispatch(increment())</code>. Since we don’t have access to the store itself, we need some way to have access to just the <code>dispatch</code> method.</p>
<p>The <code>useDispatch</code> hook does that for us, and gives us the actual <code>dispatch</code> method from the Redux store:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb295-1" title="1"><span class="kw">const</span> dispatch <span class="op">=</span> <span class="at">useDispatch</span>()<span class="op">;</span></a></code></pre></div>
<p>From there, we can dispatch actions when the user does something like clicking on a button:</p>
<p><code>jsx title="features/counter/Counter.js" &lt;button   className={styles.button}   aria-label="Increment value"   onClick={() =&gt; dispatch(increment())} &gt;   + &lt;/button&gt;</code></p>
<h3 id="component-state-and-forms">Component State and Forms</h3>
<p>By now you might be wondering, “Do I always have to put all my app’s state into the Redux store?”</p>
<p>The answer is <strong>NO. Global state that is needed across the app should go in the Redux store. State that’s only needed in one place should be kept in component state.</strong></p>
<p>In this example, we have an input textbox where the user can type in the next number to be added to the counter:</p>
<p>```jsx title=“features/counter/Counter.js” const [incrementAmount, setIncrementAmount] = useState(“2”);</p>
// later return (
<div data-classname="{styles.row}">
<pre><code>&lt;input
  className={styles.textbox}
  aria-label=&quot;Set increment amount&quot;
  value={incrementAmount}
  onChange={(e) =&gt; setIncrementAmount(e.target.value)}
/&gt;
&lt;button
  className={styles.button}
  onClick={() =&gt; dispatch(incrementByAmount(Number(incrementAmount) || 0))}
&gt;
  Add Amount
&lt;/button&gt;
&lt;button
  className={styles.asyncButton}
  onClick={() =&gt; dispatch(incrementAsync(Number(incrementAmount) || 0))}
&gt;
  Add Async
&lt;/button&gt;</code></pre>
</div>
<p>); ```</p>
<p>We <em>could</em> keep the current number string in the Redux store, by dispatching an action in the input’s <code>onChange</code> handler and keeping it in our reducer. But, that doesn’t give us any benefit. The only place that text string is used is here, in the <code>&lt;Counter&gt;</code> component. (Sure, there’s only one other component in this example: <code>&lt;App&gt;</code>. But even if we had a larger application with many components, only <code>&lt;Counter&gt;</code> cares about this input value.)</p>
<p>So, it makes sense to keep that value in a <code>useState</code> hook here in the <code>&lt;Counter&gt;</code> component.</p>
<p>Similarly, if we had a boolean flag called <code>isDropdownOpen</code>, no other components in the app would care about that - it should really stay local to this component.</p>
<p><strong>In a React + Redux app, your global state should go in the Redux store, and your local state should stay in React components.</strong></p>
<p>If you’re not sure where to put something, here are some common rules of thumb for determining what kind of data should be put into Redux:</p>
<ul>
<li>Do other parts of the application care about this data?</li>
<li>Do you need to be able to create further derived data based on this original data?</li>
<li>Is the same data being used to drive multiple components?</li>
<li>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</li>
<li>Do you want to cache the data (ie, use what’s in state if it’s already there instead of re-requesting it)?</li>
<li>Do you want to keep this data consistent while hot-reloading UI components (which may lose their internal state when swapped)?</li>
</ul>
<p>This is also a good example of how to think about forms in Redux in general. <strong>Most form state probably shouldn’t be kept in Redux.</strong> Instead, keep the data in your form components as you’re editing it, and then dispatch Redux actions to update the store when the user is done.</p>
<p>One other thing to note before we move on: remember that <code>incrementAsync</code> thunk from <code>counterSlice.js</code>? We’re using it here in this component. Notice that we use it the same way we dispatch the other normal action creators. This component doesn’t care whether we’re dispatching a normal action or starting some async logic. It only knows that when you click that button, it dispatches something.</p>
<h3 id="providing-the-store">Providing the Store</h3>
<p>We’ve seen that our components can use the <code>useSelector</code> and <code>useDispatch</code> hooks to talk to the Redux store. But, since we didn’t import the store, how do those hooks know what Redux store to talk to?</p>
<p>Now that we’ve seen all the different pieces of this application, it’s time to circle back to the starting point of this application and see how the last pieces of the puzzle fit together.</p>
<p>```jsx title=“index.js” import React from “react”; import ReactDOM from “react-dom”; import “./index.css”; import App from “./App”; import store from “./app/store”; // highlight-next-line import { Provider } from “react-redux”; import * as serviceWorker from “./serviceWorker”;</p>
<p>ReactDOM.render( // highlight-start <Provider store={store}> <App /> </Provider>, // highlight-end document.getElementById(“root”) ); ```</p>
<p>We always have to call <code>ReactDOM.render(&lt;App /&gt;)</code> to tell React to start rendering our root <code>&lt;App&gt;</code> component. In order for our hooks like <code>useSelector</code> to work right, we need to use a component called <code>&lt;Provider&gt;</code> to pass down the Redux store behind the scenes so they can access it.</p>
<p>We already created our store in <code>app/store.js</code>, so we can import it here. Then, we put our <code>&lt;Provider&gt;</code> component around the whole <code>&lt;App&gt;</code>, and pass in the store: <code>&lt;Provider store={store}&gt;</code>.</p>
<p>Now, any React components that call <code>useSelector</code> or <code>useDispatch</code> will be talking to the Redux store we gave to the <code>&lt;Provider&gt;</code>.</p>
<h2 id="what-youve-learned-9">What You’ve Learned</h2>
<p>Even though the counter example app is pretty small, it showed all the key pieces of a React + Redux app working together. Here’s what we covered:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>We can create a Redux store using the Redux Toolkit <code>configureStore</code> API</strong>
<ul>
<li><code>configureStore</code> accepts a <code>reducer</code> function as a named argument</li>
<li><code>configureStore</code> automatically sets up the store with good default settings</li>
</ul></li>
<li><strong>Redux logic is typically organized into files called “slices”</strong>
<ul>
<li>A “slice” contains the reducer logic and actions related to a specific feature / section of the Redux state</li>
<li>Redux Toolkit’s <code>createSlice</code> API generates action creators and action types for each individual reducer function you provide</li>
</ul></li>
<li><strong>Redux reducers must follow specific rules</strong>
<ul>
<li>Should only calculate a new state value based on the <code>state</code> and <code>action</code> arguments</li>
<li>Must make <em>immutable updates</em> by copying the existing state</li>
<li>Cannot contain any asynchronous logic or other “side effects”</li>
<li>Redux Toolkit’s <code>createSlice</code> API uses Immer to allow “mutating” immutable updates</li>
</ul></li>
<li><strong>Async logic is typically written in special functions called “thunks”</strong>
<ul>
<li>Thunks receive <code>dispatch</code> and <code>getState</code> as arguments</li>
<li>Redux Toolkit enables the <code>redux-thunk</code> middleware by default</li>
</ul></li>
<li><strong>React-Redux allows React components to interact with a Redux store</strong>
<ul>
<li>Wrapping the app with <code>&lt;Provider store={store}&gt;</code> enables all components to use the store</li>
<li>Global state should go in the Redux store, local state should stay in React components</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-8">What’s Next?</h2>
<p>Now that you’ve seen all the pieces of a Redux app in action, it’s time to write your own! For the rest of this tutorial, you’ll be building a larger example app that uses Redux. Along the way, we’ll cover all the key ideas you need to know to use Redux the right way.</p>
<p>Continue on to <a href="./part-3-data-flow.md">Part 3: Basic Redux Data Flow</a> to get started building the example app.</p>
<hr />
<p>id: part-3-data-flow title: ‘Redux Essentials, Part 3: Basic Redux Data Flow’ sidebar_label: ‘Basic Redux Data Flow’ description: ‘The official Redux Essentials tutorial: learn how data flows in a React + Redux app’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to add “slices” of reducer logic to the Redux store with <code>createSlice</code></li>
<li>Reading Redux data in components with the <code>useSelector</code> hook</li>
<li>Dispatching actions in components with the <code>useDispatch</code> hook</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Familiarity with key Redux terms and concepts like “actions”, “reducers”, “store”, and “dispatching”. (See <a href="./part-1-overview-concepts.md"><strong>Part 1: Redux Overview and Concepts</strong></a> for explanations of these terms.)</li>
</ul>
<p>:::</p>
<h2 id="introduction-9">Introduction</h2>
<p>In <a href="./part-1-overview-concepts.md">Part 1: Redux Overview and Concepts</a>, we looked at how Redux can help us build maintainable apps by giving us a single central place to put global app state. We also talked about core Redux concepts like dispatching action objects, using reducer functions that return new state values, and writing async logic using thunks. In <a href="./part-2-app-structure.md">Part 2: Redux App Structure</a>, we saw how APIs like <code>configureStore</code> and <code>createSlice</code> from Redux Toolkit and <code>Provider</code> and <code>useSelector</code> from React-Redux work together to let us write Redux logic and interact with that logic from our React components.</p>
<p>Now that you have some idea of what these pieces are, it’s time to put that knowledge into practice. We’re going to build a small social media feed app, which will include a number of features that demonstrate some real-world use cases. This will help you understand how to use Redux in your own applications.</p>
<div class="caution">
<p>The example app is not meant as a complete production-ready project. The goal is to help you learn the Redux APIs and typical usage patterns, and point you in the right direction using some limited examples. Also, some of the early pieces we build will be updated later on to show better ways to do things. Please read through the whole tutorial to see all the concepts in use.</p>
</div>
<h3 id="project-setup-1">Project Setup</h3>
<p>For this tutorial, we’ve created a pre-configured starter project that already has React and Redux set up, includes some default styling, and has a fake REST API that will allow us to write actual API requests in our app. You’ll use this as the basis for writing the actual application code.</p>
<p>To get started, you can open and fork this CodeSandbox:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/master/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-quick-start-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>You can also <a href="https://github.com/reduxjs/redux-essentials-example-app">clone the same project from this Github repo</a>. After cloning the repo, you can install the tools for the project with <code>npm install</code>, and start it with <code>npm start</code>.</p>
<p>If you’d like to see the final version of what we’re going to build, you can check out <a href="https://github.com/reduxjs/redux-essentials-example-app/tree/tutorial-steps">the <strong><code>tutorial-steps</code> branch</strong></a>, or <a href="https://codesandbox.io/s/github/reduxjs/redux-essentials-example-app/tree/tutorial-steps">look at the final version in this CodeSandbox</a>.</p>
<blockquote>
<p>We’d like to thank <a href="https://www.taniarascia.com/">Tania Rascia</a>, whose <a href="https://www.taniarascia.com/redux-react-guide/">Using Redux with React</a> tutorial helped inspire the example in this page. It also uses her <a href="https://taniarascia.github.io/primitive/">Primitive UI CSS starter</a> for styling.</p>
</blockquote>
<h4 id="creating-a-new-redux-react-project-1">Creating a New Redux + React Project</h4>
<p>Once you’ve finished this tutorial, you’ll probably want to try working on your own projects. <strong>We recommend using the <a href="https://github.com/reduxjs/cra-template-redux">Redux templates for Create-React-App</a> as the fastest way to create a new Redux + React project</strong>. It comes with Redux Toolkit and React-Redux already configured, using <a href="./part-1-overview-concepts.md">the same “counter” app example you saw in Part 1</a>. This lets you jump right into writing your actual application code without having to add the Redux packages and set up the store.</p>
<p>If you want to know specific details on how to add Redux to a project, see this explanation:</p>
<p><DetailedExplanation title="Detailed Explanation: Adding Redux to a React Project"></p>
<p>The Redux template for CRA comes with Redux Toolkit and React-Redux already configured. If you’re setting up a new project from scratch without that template, follow these steps:</p>
<ul>
<li>Add the <code>@reduxjs/toolkit</code> and <code>react-redux</code> packages</li>
<li>Create a Redux store using RTK’s <code>configureStore</code> API, and pass in at least one reducer function</li>
<li>Import the Redux store into your application’s entry point file (such as <code>src/index.js</code>)</li>
<li>Wrap your root React component with the <code>&lt;Provider&gt;</code> component from React-Redux, like:</li>
</ul>
<pre class="jsx"><code>ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&quot;root&quot;)
);</code></pre>
<p></DetailedExplanation></p>
<h4 id="exploring-the-initial-project-1">Exploring the Initial Project</h4>
<p>Let’s take a quick look at what the initial project contains:</p>
<ul>
<li><code>/public</code>: the HTML host page template and other static files like icons</li>
<li><code>/src</code>
<ul>
<li><code>index.js</code>: the entry point file for the application. It renders the React-Redux <code>&lt;Provider&gt;</code> component and the main <code>&lt;App&gt;</code> component.</li>
<li><code>App.js</code>: the main application component. Renders the top navbar and handles client-side routing for the other content.</li>
<li><code>index.css</code>: styles for the complete application</li>
<li><code>/api</code>
<ul>
<li><code>client.js</code>: a small AJAX request client that allows us to make GET and POST requests</li>
<li><code>server.js</code>: provides a fake REST API for our data. Our app will fetch data from these fake endpoints later.</li>
</ul></li>
<li><code>/app</code>
<ul>
<li><code>Navbar.js</code>: renders the top header and nav content</li>
<li><code>store.js</code>: creates the Redux store instance</li>
</ul></li>
</ul></li>
</ul>
<p>If you load the app now, you should see the header and a welcome message. We can also open up the Redux DevTools Extension and see that our initial Redux state is entirely empty.</p>
<p>With that, let’s get started!</p>
<h2 id="main-posts-feed">Main Posts Feed</h2>
<p>The main feature for our social media feed app will be a list of posts. We’ll add several more pieces to this feature as we go along, but to start off, our first goal is to only show the list of post entries on screen.</p>
<h3 id="creating-the-posts-slice">Creating the Posts Slice</h3>
<p>The first step is to create a new Redux “slice” that will contain the data for our posts. Once we have that data in the Redux store, we can create the React components to show that data on the page.</p>
<p>Inside of <code>src</code>, create a new <code>features</code> folder, put a <code>posts</code> folder inside of <code>features</code>, and add a new file named <code>postsSlice.js</code>.</p>
<p>We’re going to use the Redux Toolkit <code>createSlice</code> function to make a reducer function that knows how to handle our posts data. Reducer functions need to have some initial data included so that the Redux store has those values loaded when the app starts up.</p>
<p>For now, we’ll create an array with some fake post objects inside so that we can begin adding the UI.</p>
<p>We’ll import <code>createSlice</code>, define our initial posts array, pass that to <code>createSlice</code>, and export the posts reducer function that <code>createSlice</code> generated for us:</p>
<p>```js title=“features/posts/postsSlice.js” import { createSlice } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>const initialState = [ { id: “1”, title: “First Post!”, content: “Hello!” }, { id: “2”, title: “Second Post”, content: “More text” },];</p>
<p>const postsSlice = createSlice({ name: “posts”, initialState, reducers: {}, });</p>
<p>export default postsSlice.reducer; ```</p>
<p>Every time we create a new slice, we need to add its reducer function to our Redux store. We already have a Redux store being created, but right now it doesn’t have any data inside. Open up <code>app/store.js</code>, import the <code>postsReducer</code> function, and update the call to <code>configureStore</code> so that the <code>postsReducer</code> is being passed as a reducer field named <code>posts</code>:</p>
<p>```js title=“app/store.js” import { configureStore } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import postsReducer from “../features/posts/postsSlice”;</p>
<p>export default configureStore({ reducer: { posts: postsReducer, }, }); ```</p>
<p>This tells Redux that we want our top-level state object to have a field named <code>posts</code> inside, and all the data for <code>state.posts</code> will be updated by the <code>postsReducer</code> function when actions are dispatched.</p>
<p>We can confirm that this works by opening the Redux DevTools Extension and looking at the current state contents:</p>
<figure>
<img src="/img/tutorials/essentials/example-initial-posts.png" alt="Initial posts state" /><figcaption>Initial posts state</figcaption>
</figure>
<h3 id="showing-the-posts-list">Showing the Posts List</h3>
<p>Now that we have some posts data in our store, we can create a React component that shows the list of posts. All of the code related to our feed posts feature should go in the <code>posts</code> folder, so go ahead and create a new file named <code>PostsList.js</code> in there.</p>
<p>If we’re going to render a list of posts, we need to get the data from somewhere. React components can read data from the Redux store using the <code>useSelector</code> hook from the React-Redux library. The “selector functions” that you write will be called with the entire Redux <code>state</code> object as a parameter, and should return the specific data that this component needs from the store.</p>
<p>Our initial <code>PostsList</code> component will read the <code>state.posts</code> value from the Redux store, then loop over the array of posts and show each of them on screen:</p>
<p>```jsx title=“features/posts/PostsList.js” import React from “react”; import { useSelector } from “react-redux”;</p>
<p>export const PostsList = () =&gt; { const posts = useSelector((state) =&gt; state.posts);</p>
const renderedPosts = posts.map((post) =&gt; (
<article className="post-excerpt" key={post.id}>
<h3>
{post.title}
</h3>
<p className="post-content">
{post.content.substring(0, 100)}
</p>
</article>
<p>));</p>
return (
<section className="posts-list">
<h2>
Posts
</h2>
{renderedPosts}
</section>
<p>); }; ```</p>
<p>We then need to update the routing in <code>App.js</code> so that we show the <code>PostsList</code> component instead of the “welcome” message. Import the <code>PostsList</code> component into <code>App.js</code>, and replace the welcome text with <code>&lt;PostsList /&gt;</code>. We’ll also wrap it in a React Fragment, because we’re going to add something else to the main page soon:</p>
<p>```jsx title=“App.js” import React from “react”; import { BrowserRouter as Router, Switch, Route, Redirect, } from “react-router-dom”;</p>
<p>import { Navbar } from “./app/Navbar”;</p>
<p>// highlight-next-line import { PostsList } from “./features/posts/PostsList”;</p>
function App() { return ( <Router> <Navbar />
<div className="App">
<pre><code>    &lt;Switch&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={() =&gt; (
          // highlight-start
          &lt;React.Fragment&gt;
            &lt;PostsList /&gt;
          &lt;/React.Fragment&gt;
          // highlight-end
        )}
      /&gt;
      &lt;Redirect to=&quot;/&quot; /&gt;
    &lt;/Switch&gt;
  &lt;/div&gt;
&lt;/Router&gt;</code></pre>
<p>); }</p>
<p>export default App; ```</p>
<p>Once that’s added, the main page of our app should now look like this:</p>
<figure>
<img src="/img/tutorials/essentials/working_post_list.png" alt="Initial posts list" /><figcaption>Initial posts list</figcaption>
</figure>
<p>Progress! We’ve added some data to the Redux store, and shown it on screen in a React component.</p>
<h3 id="adding-new-posts">Adding New Posts</h3>
<p>It’s nice to look at posts people have written, but we’d like to be able to write our own posts. Let’s create an “Add New Post” form that lets us write posts and save them.</p>
<p>We’ll create the empty form first and add it to the page. Then, we’ll connect the form to our Redux store so that new posts are added when we click the “Save Post” button.</p>
<h4 id="adding-the-new-post-form">Adding the New Post Form</h4>
<p>Create <code>AddPostForm.js</code> in our <code>posts</code> folder. We’ll add a text input for the post title, and a text area for the body of the post:</p>
<p>```jsx title=“features/posts/AddPostForm.js” import React, { useState } from “react”;</p>
<p>export const AddPostForm = () =&gt; { const [title, setTitle] = useState("“); const [content, setContent] = useState(”");</p>
<p>const onTitleChanged = (e) =&gt; setTitle(e.target.value); const onContentChanged = (e) =&gt; setContent(e.target.value);</p>
return (
<section>
<h2>
Add a New Post
</h2>
<form>
<label htmlFor="postTitle">Post Title:</label> <input
          type="text"
          id="postTitle"
          name="postTitle"
          value={title}
          onChange={onTitleChanged}
        /> <label htmlFor="postContent">Content:</label>
<textarea
          id="postContent"
          name="postContent"
          value={content}
          onChange={onContentChanged}
        />
<button type="button">
Save Post
</button>
</form>
</section>
<p>); }; ```</p>
<p>Import that component into <code>App.js</code>, and add it right above the <code>&lt;PostsList /&gt;</code> component:</p>
<p><code>jsx title="App.js" &lt;Route   exact   path="/"   render={() =&gt; (     &lt;React.Fragment&gt;       // highlight-next-line       &lt;AddPostForm /&gt;       &lt;PostsList /&gt;     &lt;/React.Fragment&gt;   )} /&gt;</code></p>
<p>You should see the form show up in the page right below the header.</p>
<h4 id="saving-post-entries">Saving Post Entries</h4>
<p>Now, let’s update our posts slice to add new post entries to the Redux store.</p>
<p>Our posts slice is responsible for handling all updates to the posts data. Inside of the <code>createSlice</code> call, there’s an object called <code>reducers</code>. Right now, it’s empty. We need to add a reducer function inside of there to handle the case of a post being added.</p>
<p>Inside of <code>reducers</code>, add a function named <code>postAdded</code>, which will receive two arguments: the current <code>state</code> value, and the <code>action</code> object that was dispatched. Since the posts slice <em>only</em> knows about the data it’s responsible for, the <code>state</code> argument will be the array of posts by itself, and not the entire Redux state object.</p>
<p>The <code>action</code> object will have our new post entry as the <code>action.payload</code> field, and we’ll put that new post object into the <code>state</code> array.</p>
<p>When we write the <code>postAdded</code> reducer function, <code>createSlice</code> will automatically generate an “action creator” function with the same name. We can export that action creator and use it in our UI components to dispatch the action when the user clicks “Save Post”.</p>
<p>```js title=“features/posts/postsSlice.js” const postsSlice = createSlice({ name: “posts”, initialState, reducers: { // highlight-start postAdded(state, action) { state.push(action.payload); }, // highlight-end }, });</p>
<p>// highlight-next-line export const { postAdded } = postsSlice.actions;</p>
<p>export default postsSlice.reducer; ```</p>
<div class="warning">
<p>Remember: <strong>reducer functions must <em>always</em> create new state values immutably, by making copies!</strong> It’s safe to call mutating functions like <code>Array.push()</code> or modify object fields like <code>state.someField = someValue</code> inside of <code>createSlice()</code>, because it converts those mutations into safe immutable updates internally using the Immer library, but <strong>don’t try to mutate any data outside of <code>createSlice</code>!</strong></p>
</div>
<h4 id="dispatching-the-post-added-action">Dispatching the “Post Added” Action</h4>
<p>Our <code>AddPostForm</code> has text inputs and a “Save Post” button, but the button doesn’t do anything yet. We need to add a click handler that will dispatch the <code>postAdded</code> action creator and pass in a new post object containing the title and content the user wrote.</p>
<p>Our post objects also need to have an <code>id</code> field. Right now, our initial test posts are using some fake numbers for their IDs. We could write some code that would figure out what the next incrementing ID number should be, but it would be better if we generated a random unique ID instead. Redux Toolkit has a <code>nanoid</code> function we can use for that.</p>
<div class="info">
<p>We’ll talk more about generating IDs and dispatching actions in <a href="./part-4-using-data.md">Part 4: Using Redux Data</a>.</p>
</div>
<p>In order to dispatch actions from a component, we need access to the store’s <code>dispatch</code> function. We get this by calling the <code>useDispatch</code> hook from React-Redux. We also need to import the <code>postAdded</code> action creator into this file.</p>
<p>Once we have the <code>dispatch</code> function available in our component, we can call <code>dispatch(postAdded())</code> in a click handler. We can take the title and content values from our React component <code>useState</code> hooks, generate a new ID, and put them together into a new post object that we pass to <code>postAdded()</code>.</p>
<p>```jsx title=“features/posts/AddPostForm” import React, { useState } from “react”; // highlight-start import { useDispatch } from “react-redux”; import { nanoid } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import { postAdded } from “./postsSlice”; // highlight-end</p>
<p>export const AddPostForm = () =&gt; { const [title, setTitle] = useState("“); const [content, setContent] = useState(”");</p>
<p>// highlight-next-line const dispatch = useDispatch();</p>
<p>const onTitleChanged = (e) =&gt; setTitle(e.target.value); const onContentChanged = (e) =&gt; setContent(e.target.value);</p>
<p>// highlight-start const onSavePostClicked = () =&gt; { if (title &amp;&amp; content) { dispatch( postAdded({ id: nanoid(), title, content, }) );</p>
<p>setTitle("“); setContent(”"); } }; // highlight-end</p>
return (
<section>
<h2>
Add a New Post
</h2>
<form>
{/* omit form inputs */} // highlight-next-line <button type="button" onClick={onSavePostClicked}> Save Post </button>
</form>
</section>
<p>); }; ```</p>
<p>Now, try typing in a title and some text, and click “Save Post”. You should see a new item for that post show up in the posts list.</p>
<p><strong>Congratulations! You’ve just built your first working React + Redux app!</strong></p>
<p>This shows the complete Redux data flow cycle:</p>
<ul>
<li>Our posts list read the initial set of posts from the store with <code>useSelector</code> and rendered the initial UI</li>
<li>We dispatched the <code>postAdded</code> action containing the data for the new post entry</li>
<li>The posts reducer saw the <code>postAdded</code> action, and updated the posts array with the new entry</li>
<li>The Redux store told the UI that some data had changed</li>
<li>The posts list read the updated posts array, and re-rendered itself to show the new post</li>
</ul>
<p>All the new features we’ll add after this will follow the same basic patterns you’ve seen here: adding slices of state, writing reducer functions, dispatching actions, and rendering the UI based on data from the Redux store.</p>
<p>We can check the Redux DevTools Extension to see the action we dispatched, and look at how the Redux state was updated in response to that action. If we click the <code>"posts/postAdded"</code> entry in the actions list, the “Action” tab should look like this:</p>
<figure>
<img src="/img/tutorials/essentials/example-postAdded-action.png" alt="postAdded action contents" /><figcaption>postAdded action contents</figcaption>
</figure>
<p>The “Diff” tab should also show us that <code>state.posts</code> had one new item added, which is at index 2.</p>
<p>Notice that our <code>AddPostForm</code> component has some React <code>useState</code> hooks inside, to keep track of the title and content values the user is typing in. Remember, <strong>the Redux store should only contain data that’s considered “global” for the application!</strong> In this case, only the <code>AddPostForm</code> will need to know about the latest values for the input fields, so we want to keep that data in React component state instead of trying to keep the temporary data in the Redux store. When the user is done with the form, we dispatch a Redux action to update the store with the final values based on the user input.</p>
<h2 id="what-youve-learned-10">What You’ve Learned</h2>
<p>Let’s recap what you’ve learned in this section:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Redux state is updated by “reducer functions”</strong>:
<ul>
<li>Reducers always calculate a new state <em>immutably</em>, by copying existing state values and modifying the copies with the new data</li>
<li>The Redux Toolkit <code>createSlice</code> function generates “slice reducer” functions for you, and lets you write “mutating” code that is turned into safe immutable updates</li>
<li>Those slice reducer functions are added to the <code>reducer</code> field in <code>configureStore</code>, and that defines the data and state field names inside the Redux store</li>
</ul></li>
<li><strong>React components read data from the store with the <code>useSelector</code> hook</strong>
<ul>
<li>Selector functions receive the whole <code>state</code> object, and should return a value</li>
<li>Selectors will re-run whenever the Redux store is updated, and if the data they return has changed, the component will re-render</li>
</ul></li>
<li><strong>React components dispatch actions to update the store using the <code>useDispatch</code> hook</strong>
<ul>
<li><code>createSlice</code> will generate action creator functions for each reducer we add to a slice</li>
<li>Call <code>dispatch(someActionCreator())</code> in a component to dispatch an action</li>
<li>Reducers will run, check to see if this action is relevant, and return new state if appropriate</li>
<li>Temporary data like form input values should be kept as React component state. Dispatch a Redux action to update the store when the user is done with the form.</li>
</ul></li>
</ul>
<p>:::</p>
<p>Here’s what the app looks like so far:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-1-postAdded/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-quick-start-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<h2 id="whats-next-9">What’s Next?</h2>
<p>Now that you know the basic Redux data flow, move on to <a href="./part-4-using-data.md">Part 4: Using Redux Data</a>, where we’ll add some additional functionality to our app and see examples of how to work with the data that’s already in the store.</p>
<hr />
<p>id: part-4-using-data title: ‘Redux Essentials, Part 4: Using Redux Data’ sidebar_label: ‘Using Redux Data’ description: ‘The official Redux Essentials tutorial: learn how to work with complex Redux state in React components’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>Using Redux data in multiple React components</li>
<li>Organizing logic that dispatches actions</li>
<li>Writing more complex update logic in reducers</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Understanding the <a href="./part-3-data-flow.md">Redux data flow and React-Redux APIs from Part 3</a></li>
<li>Familiarity with <a href="https://reacttraining.com/react-router/web/api">the React Router <code>&lt;Link&gt;</code> and <code>&lt;Route&gt;</code> components for page routing</a></li>
</ul>
<p>:::</p>
<h2 id="introduction-10">Introduction</h2>
<p>In <a href="./part-3-data-flow.md">Part 3: Basic Redux Data Flow</a>, we saw how to start from an empty Redux+React project setup, add a new slice of state, and create React components that can read data from the Redux store and dispatch actions to update that data. We also looked at how data flows through the application, with components dispatching actions, reducers processing actions and returning new state, and components reading the new state and rerendering the UI.</p>
<p>Now that you know the core steps to write Redux logic, we’re going to use those same steps to add some new features to our social media feed that will make it more useful: viewing a single post, editing existing posts, showing post author details, post timestamps, and reaction buttons.</p>
<div class="info">
<p>As a reminder, the code examples focus on the key concepts and changes for each section. See the CodeSandbox projects and the <a href="https://github.com/reduxjs/redux-essentials-example-app/tree/tutorial-steps"><code>tutorial-steps</code> branch in the project repo</a> for the complete changes in the application.</p>
</div>
<h2 id="showing-single-posts">Showing Single Posts</h2>
<p>Since we have the ability to add new posts to the Redux store, we can add some more features that use the post data in different ways.</p>
<p>Currently, our post entries are being shown in the main feed page, but if the text is too long, we only show an excerpt of the content. It would be helpful to have the ability to view a single post entry on its own page.</p>
<h3 id="creating-a-single-post-page">Creating a Single Post Page</h3>
<p>First, we need to add a new <code>SinglePostPage</code> component to our <code>posts</code> feature folder. We’ll use React Router to show this component when the page URL looks like <code>/posts/123</code>, where the <code>123</code> part should be the ID of the post we want to show.</p>
<p>```jsx title=“features/posts/SinglePostPage.js” import React from “react”; import { useSelector } from “react-redux”;</p>
<p>export const SinglePostPage = ({ match }) =&gt; { const { postId } = match.params;</p>
<p>const post = useSelector((state) =&gt; state.posts.find((post) =&gt; post.id === postId) );</p>
if (!post) { return (
<section>
<h2>
Post not found!
</h2>
</section>
<p>); }</p>
return (
<section>
<article className="post">
<h2>
{post.title}
</h2>
<p className="post-content">
{post.content}
</p>
</article>
</section>
<p>); }; ```</p>
<p>React Router will pass in a <code>match</code> object as a prop that contains the URL information we’re looking for. When we set up the route to render this component, we’re going to tell it to parse the second part of the URL as a variable named <code>postId</code>, and we can read that value from <code>match.params</code>.</p>
<p>Once we have that <code>postId</code> value, we can use it inside a selector function to find the right post object from the Redux store. We know that <code>state.posts</code> should be an array of all post objects, so we can use the <code>Array.find()</code> function to loop through the array and return the post entry with the ID we’re looking for.</p>
<p>It’s important to note that <strong>the component will re-render any time the value returned from <code>useSelector</code> changes to a new reference</strong>. Components should always try to select the smallest possible amount of data they need from the store, which will help ensure that it only renders when it actually needs to.</p>
<p>It’s possible that we might not have a matching post entry in the store - maybe the user tried to type in the URL directly, or we don’t have the right data loaded. If that happens, the <code>find()</code> function will return <code>undefined</code> instead of an actual post object. Our component needs to check for that and handle it by showing a “Post not found!” message in the page.</p>
<p>Assuming we do have the right post object in the store, <code>useSelector</code> will return that, and we can use it to render the title and content of the post in the page.</p>
<p>You might notice that this looks fairly similar to the logic we have in the body of our <code>&lt;PostsList&gt;</code> component, where we loop over the whole <code>posts</code> array to show post excerpts on the main feed. We <em>could</em> try to extract a <code>Post</code> component that could be used in both places, but there are already some differences in how we’re showing a post excerpt and the whole post. It’s usually better to keep writing things separately for a while even if there’s some duplication, and then we can decide later if the different sections of code are similar enough that we can really extract a reusable component.</p>
<h3 id="adding-the-single-post-route">Adding the Single Post Route</h3>
<p>Now that we have a <code>&lt;SinglePostPage&gt;</code> component, we can define a route to show it, and add links to each post in the front page feed.</p>
<p>We’ll import <code>SinglePostPage</code> in <code>App.js</code>, and add the route:</p>
<p>```jsx title=“App.js” import { PostsList } from “./features/posts/PostsList”; import { AddPostForm } from “./features/posts/AddPostForm”; // highlight-next-line import { SinglePostPage } from “./features/posts/SinglePostPage”;</p>
function App() { return ( <Router> <Navbar />
<div className="App">
<pre><code>    &lt;Switch&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={() =&gt; (
          &lt;React.Fragment&gt;
            &lt;AddPostForm /&gt;
            &lt;PostsList /&gt;
          &lt;/React.Fragment&gt;
        )}
      /&gt;
      // highlight-next-line
      &lt;Route exact path=&quot;/posts/:postId&quot; component={SinglePostPage} /&gt;
      &lt;Redirect to=&quot;/&quot; /&gt;
    &lt;/Switch&gt;
  &lt;/div&gt;
&lt;/Router&gt;</code></pre>
<p>); } ```</p>
<p>Then, in <code>&lt;PostsList&gt;</code>, we’ll update the list rendering logic to include a <code>&lt;Link&gt;</code> that routes to that specific post:</p>
<p>```jsx title=“features/posts/PostsList.js” import React from “react”; import { useSelector } from “react-redux”; // highlight-next-line import { Link } from “react-router-dom”;</p>
<p>export const PostsList = () =&gt; { const posts = useSelector((state) =&gt; state.posts);</p>
const renderedPosts = posts.map((post) =&gt; (
<article className="post-excerpt" key="{post.id}">
<h3>
{post.title}
</h3>
<p className="post-content">
{post.content.substring(0, 100)}
</p>
// highlight-start <Link to={`/posts/${post.id}`} className="button muted-button"> View Post </Link> // highlight-end
</article>
<p>));</p>
return (
<section className="posts-list">
<h2>
Posts
</h2>
{renderedPosts}
</section>
<p>); }; ```</p>
<p>And since we can now click through to a different page, it would also be helpful to have a link back to the main posts page in the <code>&lt;Navbar&gt;</code> component as well:</p>
<p>```jsx title=“app/Navbar.js” import React from “react”;</p>
<p>// highlight-next-line import { Link } from “react-router-dom”;</p>
export const Navbar = () =&gt; { return ( <nav>
<section>
<h1>
Redux Essentials Example
</h1>
<div className="navContent">
<pre><code>      // highlight-start
      &lt;div className=&quot;navLinks&quot;&gt;
        &lt;Link to=&quot;/&quot;&gt;Posts&lt;/Link&gt;
      &lt;/div&gt;
      // highlight-end
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/nav&gt;</code></pre>
<p>); }; ```</p>
<h2 id="editing-posts">Editing Posts</h2>
<p>As a user, it’s really annoying to finish writing a post, save it, and realize you made a mistake somewhere. Having the ability to edit a post after we created it would be useful.</p>
<p>Let’s add a new <code>&lt;EditPostForm&gt;</code> component that has the ability to take an existing post ID, read that post from the store, lets the user edit the title and post content, and then save the changes to update the post in the store.</p>
<h3 id="updating-post-entries">Updating Post Entries</h3>
<p>First, we need to update our <code>postsSlice</code> to create a new reducer function and an action so that the store knows how to actually update posts.</p>
<p>Inside of the <code>createSlice()</code> call, we should add a new function into the <code>reducers</code> object. Remember that the name of this reducer should be a good description of what’s happening, because we’re going to see the reducer name show up as part of the action type string in the Redux DevTools whenever this action is dispatched. Our first reducer was called <code>postAdded</code>, so let’s call this one <code>postUpdated</code>.</p>
<p>In order to update a post object, we need to know:</p>
<ul>
<li>The ID of the post being updated, so that we can find the right post object in the state</li>
<li>The new <code>title</code> and <code>content</code> fields that the user typed in</li>
</ul>
<p>Redux action objects are required to have a <code>type</code> field, which is normally a descriptive string, and may also contain other fields with more information about what happened. By convention, we normally put the additional info in a field called <code>action.payload</code>, but it’s up to us to decide what the <code>payload</code> field contains - it could be a string, a number, an object, an array, or something else. In this case, since we have three pieces of information we need, let’s plan on having the <code>payload</code> field be an object with the three fields inside of it. That means the action object will look like <code>{type: 'posts/postUpdated', payload: {id, title, content}}</code>.</p>
<p>By default, the action creators generated by <code>createSlice</code> expect you to pass in one argument, and that value will be put into the action object as <code>action.payload</code>. So, we can pass an object containing those fields as the argument to the <code>postUpdated</code> action creator.</p>
<p>We also know that the reducer is responsible for determining how the state should actually be updated when an action is dispatched. Given that, we should have the reducer find the right post object based on the ID, and specifically update the <code>title</code> and <code>content</code> fields in that post.</p>
<p>Finally, we’ll need to export the action creator function that <code>createSlice</code> generated for us, so that the UI can dispatch the new <code>postUpdated</code> action when the user saves the post.</p>
<p>Given all those requirements, here’s how our <code>postsSlice</code> definition should look after we’re done:</p>
<p>```js title=“features/posts/postsSlice.js” const postsSlice = createSlice({ name: “posts”, initialState, reducers: { postAdded(state, action) { state.push(action.payload); }, // highlight-start postUpdated(state, action) { const { id, title, content } = action.payload; const existingPost = state.find((post) =&gt; post.id === id); if (existingPost) { existingPost.title = title; existingPost.content = content; } }, // highlight-end }, });</p>
<p>// highlight-next-line export const { postAdded, postUpdated } = postsSlice.actions;</p>
<p>export default postsSlice.reducer; ```</p>
<h3 id="creating-an-edit-post-form">Creating an Edit Post Form</h3>
<p>Our new <code>&lt;EditPostForm&gt;</code> component will look similar to the <code>&lt;AddPostForm&gt;</code>, but the logic needs to be a bit different. We need to retrieve the right <code>post</code> object from the store, then use that to initialize the state fields in the component so the user can make changes. We’ll save the changed title and content values back to the store after the user is done. We’ll also use React Router’s history API to switch over to the single post page and show that post.</p>
<p>```jsx title=“features/posts/EditPostForm.js” import React, { useState } from “react”; import { useDispatch, useSelector } from “react-redux”; import { useHistory } from “react-router-dom”;</p>
<p>import { postUpdated } from “./postsSlice”;</p>
<p>export const EditPostForm = ({ match }) =&gt; { const { postId } = match.params;</p>
<p>const post = useSelector((state) =&gt; state.posts.find((post) =&gt; post.id === postId) );</p>
<p>const [title, setTitle] = useState(post.title); const [content, setContent] = useState(post.content);</p>
<p>const dispatch = useDispatch(); const history = useHistory();</p>
<p>const onTitleChanged = (e) =&gt; setTitle(e.target.value); const onContentChanged = (e) =&gt; setContent(e.target.value);</p>
<p>const onSavePostClicked = () =&gt; { if (title &amp;&amp; content) { dispatch(postUpdated({ id: postId, title, content })); history.push(<code>/posts/${postId}</code>); } };</p>
return (
<section>
<h2>
Edit Post
</h2>
<form>
<label htmlFor="postTitle">Post Title:</label> <input
          type="text"
          id="postTitle"
          name="postTitle"
          placeholder="What's on your mind?"
          value={title}
          onChange={onTitleChanged}
        /> <label htmlFor="postContent">Content:</label>
<textarea
          id="postContent"
          name="postContent"
          value={content}
          onChange={onContentChanged}
        />
</form>
<button type="button" onClick="{onSavePostClicked}">
Save Post
</button>
</section>
<p>); }; ```</p>
<p>Like with <code>SinglePostPage</code>, we’ll need to import it into <code>App.js</code> and add a route that will render this component with the <code>postId</code> as a route parameter.</p>
<p>```jsx title=“App.js” import { PostsList } from “./features/posts/PostsList”; import { AddPostForm } from “./features/posts/AddPostForm”; import { SinglePostPage } from “./features/posts/SinglePostPage”; // highlight-next-line import { EditPostForm } from “./features/posts/EditPostForm”;</p>
function App() { return ( <Router> <Navbar />
<div className="App">
<pre><code>    &lt;Switch&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={() =&gt; (
          &lt;React.Fragment&gt;
            &lt;AddPostForm /&gt;
            &lt;PostsList /&gt;
          &lt;/React.Fragment&gt;
        )}
      /&gt;
      &lt;Route exact path=&quot;/posts/:postId&quot; component={SinglePostPage} /&gt;
      // highlight-next-line
      &lt;Route exact path=&quot;/editPost/:postId&quot; component={EditPostForm} /&gt;
      &lt;Redirect to=&quot;/&quot; /&gt;
    &lt;/Switch&gt;
  &lt;/div&gt;
&lt;/Router&gt;</code></pre>
<p>); } ```</p>
<p>We should also add a new link to our <code>SinglePostPage</code> that will route to <code>EditPostForm</code>, like:</p>
<p>```jsx title=“features/post/SinglePostPage.js” // highlight-next-line import { Link } from ‘react-router-dom’</p>
<p>export const SinglePostPage = ({ match }) =&gt; {</p>
<pre><code>    // omit other contents

    &lt;p  className=&quot;post-content&quot;&gt;{post.content}&lt;/p&gt;
    // highlight-start
    &lt;Link to={`/editPost/${post.id}`} className=&quot;button&quot;&gt;
      Edit Post
    &lt;/Link&gt;
    // highlight-end</code></pre>
<p>```</p>
<h3 id="preparing-action-payloads">Preparing Action Payloads</h3>
<p>We just saw that the action creators from <code>createSlice</code> normally expect one argument, which becomes <code>action.payload</code>. This simplifies the most common usage pattern, but sometimes we need to do more work to prepare the contents of an action object. In the case of our <code>postAdded</code> action, we need to generate a unique ID for the new post, and we also need to make sure that the payload is an object that looks like <code>{id, title, content}</code>.</p>
<p>Right now, we’re generating the ID and creating the payload object in our React component, and passing the payload object into <code>postAdded</code>. But, what if we needed to dispatch the same action from different components, or the logic for preparing the payload is complicated? We’d have to duplicate that logic every time we wanted to dispatch the action, and we’re forcing the component to know exactly what the payload for this action should look like.</p>
<div class="caution">
<p>If an action needs to contain a unique ID or some other random value, always generate that first and put it in the action object. <strong>Reducers should never calculate random values</strong>, because that makes the results unpredictable.</p>
</div>
<p>If we were writing the <code>postAdded</code> action creator by hand, we could have put the setup logic inside of it ourselves:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb303-1" title="1"><span class="co">// hand-written action creator</span></a>
<a class="sourceLine" id="cb303-2" title="2"><span class="kw">function</span> <span class="at">postAdded</span>(title<span class="op">,</span> content) <span class="op">{</span></a>
<a class="sourceLine" id="cb303-3" title="3">  <span class="kw">const</span> id <span class="op">=</span> <span class="at">nanoid</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb303-4" title="4">  <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb303-5" title="5">    <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;posts/postAdded&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb303-6" title="6">    <span class="dt">payload</span><span class="op">:</span> <span class="op">{</span> id<span class="op">,</span> title<span class="op">,</span> content <span class="op">},</span></a>
<a class="sourceLine" id="cb303-7" title="7">  <span class="op">};</span></a>
<a class="sourceLine" id="cb303-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>But, Redux Toolkit’s <code>createSlice</code> is generating these action creators for us. That makes the code shorter because we don’t have to write them ourselves, but we still need a way to customize the contents of <code>action.payload</code>.</p>
<p>Fortunately, <code>createSlice</code> lets us define a “prepare callback” function when we write a reducer. The “prepare callback” function can take multiple arguments, generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. It should then return an object with the <code>payload</code> field inside. (The return object may also contain a <code>meta</code> field, which can be used to add extra descriptive values to the action, and an <code>error</code> field, which should be a boolean indicating whether this action represents some kind of an error.)</p>
<p>Inside of the <code>reducers</code> field in <code>createSlice</code>, we can define one of the fields as an object that looks like <code>{reducer, prepare}</code>:</p>
<p><code>js title="features/posts/postsSlice.js" const postsSlice = createSlice({   name: "posts",   initialState,   reducers: {     // highlight-start     postAdded: {       reducer(state, action) {         state.push(action.payload);       },       prepare(title, content) {         return {           payload: {             id: nanoid(),             title,             content,           },         };       },     },     // highlight-end     // other reducers here   }, });</code></p>
<p>Now our component doesn’t have to worry about what the payload object looks like - the action creator will take care of putting it together the right way. So, we can update the component so that it passes in <code>title</code> and <code>content</code> as arguments when it dispatches <code>postAdded</code>:</p>
<p><code>jsx title="features/posts/AddPostForm.js" const onSavePostClicked = () =&gt; {   if (title &amp;&amp; content) {     // highlight-next-line     dispatch(postAdded(title, content));     setTitle("");     setContent("");   } };</code></p>
<h2 id="users-and-posts">Users and Posts</h2>
<p>So far, we only have one slice of state. The logic is defined in <code>postsSlice.js</code>, the data is stored in <code>state.posts</code>, and all of our components have been related to the posts feature. Real applications will probably have many different slices of state, and several different “feature folders” for the Redux logic and React components.</p>
<p>You can’t have a “social media” app if there aren’t any other people involved. Let’s add the ability to keep track of a list of users in our app, and update the post-related functionality to make use of that data.</p>
<h3 id="adding-a-users-slice">Adding a Users Slice</h3>
<p>Since the concept of “users” is different than the concept of “posts”, we want to keep the code and data for the users separated from the code and data for posts. We’ll add a new <code>features/users</code> folder, and put a <code>usersSlice</code> file in there. Like with the posts slice, for now we’ll add some initial entries so that we have data to work with.</p>
<p>```js title=“features/users/usersSlice.js” import { createSlice } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>const initialState = [ { id: “0”, name: “Tianna Jenkins” }, { id: “1”, name: “Kevin Grant” }, { id: “2”, name: “Madison Price” },];</p>
<p>const usersSlice = createSlice({ name: “users”, initialState, reducers: {}, });</p>
<p>export default usersSlice.reducer; ```</p>
<p>For now, we don’t need to actually update the data, so we’ll leave the <code>reducers</code> field as an empty object. (We’ll come back to this in a later section.)</p>
<p>As before, we’ll import the <code>usersReducer</code> into our store file and add it to the store setup:</p>
<p>```js title=“app/store.js” import { configureStore } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import postsReducer from “../features/posts/postsSlice”; // highlight-next-line import usersReducer from “../features/users/usersSlice”;</p>
<p>export default configureStore({ reducer: { posts: postsReducer, // highlight-next-line users: usersReducer, }, }); ```</p>
<h3 id="adding-authors-for-posts">Adding Authors for Posts</h3>
<p>Every post in our app was written by one of our users, and every time we add a new post, we should keep track of which user wrote that post. In a real app, we’d have some sort of a <code>state.currentUser</code> field that keeps track of the current logged-in user, and use that information whenever they add a post.</p>
<p>To keep things simpler for this example, we’ll update our <code>&lt;AddPostForm&gt;</code> component so that we can select a user from a dropdown list, and we’ll include that user’s ID as part of the post. Once our post objects have a user ID in them, we can use that to look up the user’s name and show it in each individual post in the UI.</p>
<p>First, we need to update our <code>postAdded</code> action creator to accept a user ID as an argument, and include that in the action. (We’ll also update the existing post entries in <code>initialState</code> to have a <code>post.user</code> field with one of the example user IDs.)</p>
<p><code>js title="features/posts/postsSlice.js" const postsSlice = createSlice({   name: "posts",   initialState,   reducers: {     postAdded: {       reducer(state, action) {         state.push(action.payload);       },       // highlight-next-line       prepare(title, content, userId) {         return {           payload: {             id: nanoid(),             title,             content,             // highlight-next-line             user: userId,           },         };       },     },     // other reducers   }, });</code></p>
<p>Now, in our <code>&lt;AddPostForm&gt;</code>, we can read the list of users from the store with <code>useSelector</code> and show them as a dropdown. We’ll then take the ID of the selected user and pass that to the <code>postAdded</code> action creator. While we’re at it, we can add a bit of validation logic to our form so that the user can only click the “Save Post” button if the title and content inputs have some actual text in them:</p>
<p>```jsx title=“features/posts/AddPostForm.js” import React, { useState } from “react”; // highlight-next-line import { useDispatch, useSelector } from “react-redux”;</p>
<p>import { postAdded } from “./postsSlice”;</p>
<p>export const AddPostForm = () =&gt; { const [title, setTitle] = useState("“); const [content, setContent] = useState(”“); // highlight-next-line const [userId, setUserId] = useState(”");</p>
<p>const dispatch = useDispatch();</p>
<p>// highlight-next-line const users = useSelector((state) =&gt; state.users);</p>
<p>const onTitleChanged = (e) =&gt; setTitle(e.target.value); const onContentChanged = (e) =&gt; setContent(e.target.value); // highlight-next-line const onAuthorChanged = (e) =&gt; setUserId(e.target.value);</p>
<p>const onSavePostClicked = () =&gt; { if (title &amp;&amp; content) { // highlight-next-line dispatch(postAdded(title, content, userId)); setTitle("“); setContent(”"); } };</p>
<p>// highlight-start const canSave = Boolean(title) &amp;&amp; Boolean(content) &amp;&amp; Boolean(userId);</p>
<p>const usersOptions = users.map((user) =&gt; ( <option key={user.id} value={user.id}> {user.name} </option> )); // highlight-end</p>
return (
<section>
<h2>
Add a New Post
</h2>
<form>
<label htmlFor="postTitle">Post Title:</label> <input
          type="text"
          id="postTitle"
          name="postTitle"
          placeholder="What's on your mind?"
          value={title}
          onChange={onTitleChanged}
        /> // highlight-start <label htmlFor="postAuthor">Author:</label> <select id="postAuthor" value={userId} onChange={onAuthorChanged}> <option value=""></option> {usersOptions} </select> // highlight-end <label htmlFor="postContent">Content:</label>
<textarea
          id="postContent"
          name="postContent"
          value={content}
          onChange={onContentChanged}
        />
// highlight-next-line <button type="button" onClick={onSavePostClicked} disabled={!canSave}> Save Post </button>
</form>
</section>
<p>); }; ```</p>
<p>Now, we need a way to show the name of the post’s author inside of our post list items and <code>&lt;SinglePostPage&gt;</code>. Since we want to show this same kind of info in more than one place, we can make a <code>PostAuthor</code> component that takes a user ID as a prop, looks up the right user object, and formats the user’s name:</p>
<p>```jsx title=“features/posts/PostAuthor.js” import React from “react”; import { useSelector } from “react-redux”;</p>
<p>export const PostAuthor = ({ userId }) =&gt; { const author = useSelector((state) =&gt; state.users.find((user) =&gt; user.id === userId) );</p>
<p>return <span>by {author ? author.name : “Unknown author”}</span>; }; ```</p>
<p>Notice that we’re following the same pattern in each of our components as we go. Any component that needs to read data from the Redux store can use the <code>useSelector</code> hook, and extract the specific pieces of data that it needs. Also, many components can access the same data in the Redux store at the same time.</p>
<p>We can now import the <code>PostAuthor</code> component into both <code>PostsList.js</code> and <code>SinglePostPage.js</code>, and render it as <code>&lt;PostAuthor userId={post.user} /&gt;</code>, and every time we add a post entry, the selected user’s name should show up inside of the rendered post.</p>
<h2 id="more-post-features">More Post Features</h2>
<p>At this point, we can create and edit posts. Let’s add some additional logic to make our posts feed more useful.</p>
<h3 id="storing-dates-for-posts">Storing Dates for Posts</h3>
<p>Social media feeds are typically sorted by when the post was created, and show us the post creation time as a relative description like “5 hours ago”. In order to do that, we need to start tracking a <code>date</code> field for our post entries.</p>
<p>Like with the <code>post.user</code> field, we’ll update our <code>postAdded</code> prepare callback to make sure that <code>post.date</code> is always included when the action is dispatched. However, it’s not another parameter that will be passed in. We want to always use the exact timestamp from when the action is dispatched, so we’ll let the prepare callback handle that itself.</p>
<div class="caution">
<p><strong>Redux actions and state should only contain plain JS values like objects, arrays, and primitives. Don’t put class instances, functions, or other non-serializable values into Redux!</strong>.</p>
</div>
<p>Since we can’t just put a <code>Date</code> class instance into the Redux store, we’ll track the <code>post.date</code> value as a timestamp string:</p>
<p><code>js title="features/posts/postsSlice.js"     postAdded: {       reducer(state, action) {         state.push(action.payload)       },       prepare(title, content, userId) {         return {           payload: {             id: nanoid(),             // highlight-next-line             date: new Date().toISOString(),             title,             content,             user: userId,           },         }       },     },</code></p>
<p>Like with post authors, we need to show the relative timestamp description in both our <code>&lt;PostsList&gt;</code> and <code>&lt;SinglePostPage&gt;</code> components. We’ll add a <code>&lt;TimeAgo&gt;</code> component to handle formatting a timestamp string as a relative description. Libraries like <code>date-fns</code> have some useful utility functions for parsing and formatting dates, which we can use here:</p>
<p>```jsx title=“features/posts/TimeAgo.js” import React from “react”; import { parseISO, formatDistanceToNow } from “date-fns”;</p>
<p>export const TimeAgo = ({ timestamp }) =&gt; { let timeAgo = ""; if (timestamp) { const date = parseISO(timestamp); const timePeriod = formatDistanceToNow(date); timeAgo = <code>${timePeriod} ago</code>; }</p>
<p>return ( <span title="{timestamp}">   <i>{timeAgo}</i> </span> ); }; ```</p>
<h3 id="sorting-the-posts-list">Sorting the Posts List</h3>
<p>Our <code>&lt;PostsList&gt;</code> is currently showing all the posts in the same order the posts are kept in the Redux store. Our example has the oldest post first, and any time we add a new post, it gets added to the end of the posts array. That means the newest post is always at the bottom of the page.</p>
<p>Typically, social media feeds show the newest posts first, and you scroll down to see older posts. Even though the data is being kept oldest-first in the store, we can reorder the data in our <code>&lt;PostsList&gt;</code> component so that the newest post is first. In theory, since we know that the <code>state.posts</code> array is already sorted, we <em>could</em> just reverse the list. But, it’s better to go ahead and sort it ourselves just to be sure.</p>
<p>Since <code>array.sort()</code> mutates the existing array, we need to make a copy of <code>state.posts</code> and sort that copy. We know that our <code>post.date</code> fields are being kept as date timestamp strings, and we can directly compare those to sort the posts in the right order:</p>
<p>```jsx title=“features/posts/PostsList.js” // Sort posts in reverse chronological order by datetime string //highlight-start const orderedPosts = posts.slice().sort((a, b) =&gt; b.date.localeCompare(a.date));</p>
const renderedPosts = orderedPosts.map((post) =&gt; { //highlight-end return (
<article className="post-excerpt" key={post.id}>
<h3>
{post.title}
</h3>
<div>
<pre><code>    &lt;PostAuthor userId={post.user} /&gt;
    &lt;TimeAgo timestamp={post.date} /&gt;
  &lt;/div&gt;
  &lt;p className=&quot;post-content&quot;&gt;{post.content.substring(0, 100)}&lt;/p&gt;
  &lt;Link to={`/posts/${post.id}`} className=&quot;button muted-button&quot;&gt;
    View Post
  &lt;/Link&gt;
&lt;/article&gt;</code></pre>
<p>); }); ```</p>
<p>We also need to add the <code>date</code> field to <code>initialState</code> in <code>postsSlice.js</code>. We’ll use <code>date-fns</code> here again to subtract minutes from the current date/time so they differ from each other.</p>
<p>```jsx title=“features/posts/postsSlice.js” import { createSlice, nanoid } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; // highlight-next-line import { sub } from “date-fns”;</p>
<p>const initialState = [ { // omitted fields content: “Hello!”, // highlight-next-line date: sub(new Date(), { minutes: 10 }).toISOString(), }, { // omitted fields content: “More text”, // highlight-next-line date: sub(new Date(), { minutes: 5 }).toISOString(), },]; ```</p>
<h3 id="post-reaction-buttons">Post Reaction Buttons</h3>
<p>We have one more new feature to add for this section. Right now, our posts are kind of boring. We need to make them more exciting, and what better way to do that than letting our friends add reaction emoji to our posts?</p>
<p>We’ll add a row of emoji reaction buttons at the bottom of each post in <code>&lt;PostsList&gt;</code> and <code>&lt;SinglePostPage&gt;</code>. Every time a user clicks one of the reaction buttons, we’ll need to update a matching counter field for that post in the Redux store. Since the reaction counter data is in the Redux store, switching between different parts of the app should consistently show the same values in any component that uses that data.</p>
<p>Like with post authors and timestamps, we want to use this everywhere we show posts, so we’ll create a <code>&lt;ReactionButtons&gt;</code> component that takes a <code>post</code> as a prop. We’ll start by just showing the buttons inside, with the current reaction counts for each button:</p>
<p>```jsx title=“features/posts/ReactionButtons.js” import React from “react”;</p>
<p>const reactionEmoji = { thumbsUp: “👍”, hooray: “🎉”, heart: “❤️”, rocket: “🚀”, eyes: “👀”, };</p>
<p>export const ReactionButtons = ({ post }) =&gt; { const reactionButtons = Object.entries(reactionEmoji).map(([name, emoji]) =&gt; { return ( <button key={name} type="button" className="muted-button reaction-button"> {emoji} {post.reactions[name]} </button> ); });</p>
return
<div>
{reactionButtons}
</div>
<p>; }; ```</p>
<p>We don’t yet have a <code>post.reactions</code> field in our data, so we’ll need to update the <code>initialState</code> post objects and our <code>postAdded</code> prepare callback function to make sure that every post has that data inside, like <code>reactions: {thumbsUp: 0, hooray: 0}</code>.</p>
<p>Now, we can define a new reducer that will handle updating the reaction count for a post when a user clicks the reaction button.</p>
<p>Like with editing posts, we need to know the ID of the post, and which reaction button the user clicked on. We’ll have our <code>action.payload</code> be an object that looks like <code>{id, reaction}</code>. The reducer can then find the right post object, and update the correct reactions field.</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb305-1" title="1"><span class="kw">const</span> postsSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb305-2" title="2">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;posts&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb305-3" title="3">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb305-4" title="4">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb305-5" title="5">    <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb305-6" title="6">    <span class="at">reactionAdded</span>(state<span class="op">,</span> action) <span class="op">{</span></a>
<a class="sourceLine" id="cb305-7" title="7">      <span class="kw">const</span> <span class="op">{</span> postId<span class="op">,</span> reaction <span class="op">}</span> <span class="op">=</span> <span class="va">action</span>.<span class="at">payload</span><span class="op">;</span></a>
<a class="sourceLine" id="cb305-8" title="8">      <span class="kw">const</span> existingPost <span class="op">=</span> <span class="va">state</span>.<span class="at">find</span>((post) <span class="kw">=&gt;</span> <span class="va">post</span>.<span class="at">id</span> <span class="op">===</span> postId)<span class="op">;</span></a>
<a class="sourceLine" id="cb305-9" title="9">      <span class="cf">if</span> (existingPost) <span class="op">{</span></a>
<a class="sourceLine" id="cb305-10" title="10">        <span class="va">existingPost</span>.<span class="at">reactions</span>[reaction]<span class="op">++;</span></a>
<a class="sourceLine" id="cb305-11" title="11">      <span class="op">}</span></a>
<a class="sourceLine" id="cb305-12" title="12">    <span class="op">},</span></a>
<a class="sourceLine" id="cb305-13" title="13">    <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb305-14" title="14">    <span class="co">// other reducers</span></a>
<a class="sourceLine" id="cb305-15" title="15">  <span class="op">},</span></a>
<a class="sourceLine" id="cb305-16" title="16"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb305-17" title="17"></a>
<a class="sourceLine" id="cb305-18" title="18"><span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb305-19" title="19"><span class="im">export</span> <span class="kw">const</span> <span class="op">{</span> postAdded<span class="op">,</span> postUpdated<span class="op">,</span> reactionAdded <span class="op">}</span> <span class="op">=</span> <span class="va">postsSlice</span>.<span class="at">actions</span><span class="op">;</span></a></code></pre></div>
<p>As we’ve seen already, <code>createSlice</code> lets us write “mutating” logic in our reducers. If we weren’t using <code>createSlice</code> and the Immer library, the line <code>existingPost.reactions[reaction]++</code> would indeed mutate the existing <code>post.reactions</code> object, and this would probably cause bugs elsewhere in our app because we didn’t follow the rules of reducers. But, since we <em>are</em> using <code>createSlice</code>, we can write this more complex update logic in a simpler way, and let Immer do the work of turning this code into a safe immutable update.</p>
<p>Notice that <strong>our action object just contains the minimum amount of information needed to describe what happened</strong>. We know which post we need to update, and which reaction name was clicked on. We <em>could</em> have calculated the new reaction counter value and put that in the action, but <strong>it’s always better to keep the action objects as small as possible, and do the state update calculations in the reducer</strong>. This also means that <strong>reducers can contain as much logic as necessary to calculate the new state</strong>.</p>
<div class="info">
<p>When using Immer, you can either “mutate” an existing state object, or return a new state value yourself, but not both at the same time. See the Immer docs guides on <a href="https://immerjs.github.io/immer/pitfalls">Pitfalls</a> and <a href="https://immerjs.github.io/immer/return">Returning New Data</a> for more details.</p>
</div>
<p>Our last step is to update the <code>&lt;ReactionButtons&gt;</code> component to dispatch the <code>reactionAdded</code> action when the user clicks a button:</p>
<p>```jsx title=“features/posts/ReactionButtons.jsx” import React from “react”; // highlight-start import { useDispatch } from “react-redux”;</p>
<p>import { reactionAdded } from “./postsSlice”; // highlight-end</p>
<p>const reactionEmoji = { thumbsUp: “👍”, hooray: “🎉”, heart: “❤️”, rocket: “🚀”, eyes: “👀”, };</p>
<p>export const ReactionButtons = ({ post }) =&gt; { // highlight-next-line const dispatch = useDispatch();</p>
<p>const reactionButtons = Object.entries(reactionEmoji).map(([name, emoji]) =&gt; { return ( &lt;button key={name} type=“button” className=“muted-button reaction-button” // highlight-start onClick={() =&gt; dispatch(reactionAdded({ postId: post.id, reaction: name })) } // highlight-end &gt; {emoji} {post.reactions[name]} </button> ); });</p>
return
<div>
{reactionButtons}
</div>
<p>; }; ```</p>
<p>Now, every time we click a reaction button, the counter should increment. If we browse around to different parts of the app, we should see the correct counter values displayed any time we look at this post, even if we click a reaction button in the <code>&lt;PostsList&gt;</code> and then look at the post by itself on the <code>&lt;SinglePostPage&gt;</code>.</p>
<h2 id="what-youve-learned-11">What You’ve Learned</h2>
<p>Here’s what our app looks like after all these changes:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-2-reactionButtons/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-essentials-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>It’s actually starting to look more useful and interesting!</p>
<p>We’ve covered a lot of information and concepts in this section. Let’s recap the important things to remember:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Any React component can use data from the Redux store as needed</strong>
<ul>
<li>Any component can read any data that is in the Redux store</li>
<li>Multiple components can read the same data, even at the same time</li>
<li>Components should extract the smallest amount of data they need to render themselves</li>
<li>Components can combine values from props, state, and the Redux store to determine what UI they need to render. They can read multiple pieces of data from the store, and reshape the data as needed for display.</li>
<li>Any component can dispatch actions to cause state updates</li>
</ul></li>
<li><strong>Redux action creators can prepare action objects with the right contents</strong>
<ul>
<li><code>createSlice</code> and <code>createAction</code> can accept a “prepare callback” that returns the action payload</li>
<li>Unique IDs and other random values should be put in the action, not calculated in the reducer</li>
</ul></li>
<li><strong>Reducers should contain the actual state update logic</strong>
<ul>
<li>Reducers can contain whatever logic is needed to calculate the next state</li>
<li>Action objects should contain just enough info to describe what happened</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-10">What’s Next?</h2>
<p>By now you should be comfortable working with data in the Redux store and React components. So far we’ve just used data that was in the initial state or added by the user. In <a href="./part-5-async-logic.md">Part 5: Async Logic and Data Fetching</a>, we’ll see how to work with data that comes from a server API.</p>
<hr />
<p>id: part-5-async-logic title: ‘Redux Essentials, Part 5: Async Logic and Data Fetching’ sidebar_label: ‘Async Logic and Data Fetching’ description: ‘The official Redux Essentials tutorial: learn how async logic works in Redux apps’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to use the Redux “thunk” middleware for async logic</li>
<li>Patterns for handling async request state</li>
<li>How to use the Redux Toolkit <code>createAsyncThunk</code> API to simplify async calls</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Familiarity with using AJAX requests to fetch and update data from a server</li>
</ul>
<p>:::</p>
<h2 id="introduction-11">Introduction</h2>
<p>In <a href="./part-4-using-data.md">Part 4: Using Redux Data</a>, we saw how to use multiple pieces of data from the Redux store inside of React components, customize the contents of action objects before they’re dispatched, and handle more complex update logic in our reducers.</p>
<p>So far, all the data we’ve worked with has been directly inside of our React client application. However, most real applications need to work with data from a server, by making HTTP API calls to fetch and save items.</p>
<p>In this section, we’ll convert our social media app to fetch the posts and users data from an API, and add new posts by saving them to the API.</p>
<h3 id="example-rest-api-and-client-1">Example REST API and Client</h3>
<p>To keep the example project isolated but realistic, the initial project setup already included a fake in-memory REST API for our data (configured using <a href="https://mswjs.io/">the Mock Service Worker mock API tool</a>). The API uses <code>/fakeApi</code> as the base URL for the endpoints, and supports the typical <code>GET/POST/PUT/DELETE</code> HTTP methods for <code>/fakeApi/posts</code>, <code>/fakeApi/users</code>, and <code>fakeApi/notifications</code>. It’s defined in <code>src/api/server.js</code>.</p>
<p>The project also includes a small HTTP API client object that exposes <code>client.get()</code> and <code>client.post()</code> methods, similar to popular HTTP libraries like <code>axios</code>. It’s defined in <code>src/api/client.js</code>.</p>
<p>We’ll use the <code>client</code> object to make HTTP calls to our in-memory fake REST API for this section.</p>
<p>Also, the mock server has been set up to reuse the same random seed each time the page is loaded, so that it will generate the same list of fake users and fake posts. If you want to reset that, delete the <code>'randomTimestampSeed'</code> value in your browser’s Local Storage and reload the page, or you can turn that off by editing <code>src/api/server.js</code> and setting <code>useSeededRNG</code> to <code>false</code>.</p>
<div class="info">
<p>As a reminder, the code examples focus on the key concepts and changes for each section. See the CodeSandbox projects and the <a href="https://github.com/reduxjs/redux-essentials-example-app/tree/tutorial-steps"><code>tutorial-steps</code> branch in the project repo</a> for the complete changes in the application.</p>
</div>
<h2 id="thunks-and-async-logic">Thunks and Async Logic</h2>
<h3 id="using-middleware-to-enable-async-logic-1">Using Middleware to Enable Async Logic</h3>
<p>By itself, a Redux store doesn’t know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store.</p>
<p>But, what if you want to have async logic interact with the store by dispatching or checking the current store state? That’s where <a href="../fundamentals/part-4-store.md#middleware">Redux middleware</a> come in. They extend the store, and allow you to:</p>
<ul>
<li>Execute extra logic when any action is dispatched (such as logging the action and state)</li>
<li>Pause, modify, delay, replace, or halt dispatched actions</li>
<li>Write extra code that has access to <code>dispatch</code> and <code>getState</code></li>
<li>Teach <code>dispatch</code> how to accept other values besides plain action objects, such as functions and promises, by intercepting them and dispatching real action objects instead</li>
</ul>
<p><a href="../../faq/Actions.md#how-can-i-represent-side-effects-such-as-ajax-calls-why-do-we-need-things-like-action-creators-thunks-and-middleware-to-do-async-behavior">The most common reason to use middleware is to allow different kinds of async logic to interact with the store</a>. This allows you to write code that can dispatch actions and check the store state, while keeping that logic separate from your UI.</p>
<p>There are many kinds of async middleware for Redux, and each lets you write your logic using different syntax. The most common async middleware is <a href="https://github.com/reduxjs/redux-thunk"><code>redux-thunk</code></a>, which lets you write plain functions that may contain async logic directly. Redux Toolkit’s <code>configureStore</code> function <a href="https://redux-toolkit.js.org/api/getDefaultMiddleware#included-default-middleware">automatically sets up the thunk middleware by default</a>, and <a href="../../style-guide/style-guide.md#use-thunks-for-async-logic">we recommend using thunks as the standard approach for writing async logic with Redux</a>.</p>
<p>Earlier, we saw <a href="part-1-overview-concepts.md#redux-application-data-flow">what the synchronous data flow for Redux looks like</a>. When we introduce asynchronous logic, we add an extra step where middleware can run logic like AJAX requests, then dispatch actions. That makes the async data flow look like this:</p>
<figure>
<img src="/img/tutorials/essentials/ReduxAsyncDataFlowDiagram.gif" alt="Redux async data flow diagram" /><figcaption>Redux async data flow diagram</figcaption>
</figure>
<h3 id="thunk-functions">Thunk Functions</h3>
<p>Once the thunk middleware has been added to the Redux store, it allows you to pass <em>thunk functions</em> directly to <code>store.dispatch</code>. A thunk function will always be called with <code>(dispatch, getState)</code> as its arguments, and you can use them inside the thunk as needed.</p>
<p>Thunks typically dispatch plain actions using action creators, like <code>dispatch(increment())</code>:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb306-1" title="1"><span class="kw">const</span> store <span class="op">=</span> <span class="at">configureStore</span>(<span class="op">{</span> <span class="dt">reducer</span><span class="op">:</span> counterReducer <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb306-2" title="2"></a>
<a class="sourceLine" id="cb306-3" title="3"><span class="kw">const</span> exampleThunkFunction <span class="op">=</span> (dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb306-4" title="4">  <span class="kw">const</span> stateBefore <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb306-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Counter before: </span><span class="sc">${</span><span class="va">stateBefore</span>.<span class="at">counter</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb306-6" title="6">  <span class="at">dispatch</span>(<span class="at">increment</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb306-7" title="7">  <span class="kw">const</span> stateAfter <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb306-8" title="8">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Counter after: </span><span class="sc">${</span><span class="va">stateAfter</span>.<span class="at">counter</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb306-9" title="9"><span class="op">};</span></a>
<a class="sourceLine" id="cb306-10" title="10"></a>
<a class="sourceLine" id="cb306-11" title="11"><span class="va">store</span>.<span class="at">dispatch</span>(exampleThunkFunction)<span class="op">;</span></a></code></pre></div>
<p>For consistency with dispatching normal action objects, we typically write these as <em>thunk action creators</em>, which return the thunk function. These action creators can take arguments that can be used inside the thunk.</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb307-1" title="1"><span class="kw">const</span> logAndAdd <span class="op">=</span> (amount) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb307-2" title="2">  <span class="cf">return</span> (dispatch<span class="op">,</span> getState) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb307-3" title="3">    <span class="kw">const</span> stateBefore <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb307-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Counter before: </span><span class="sc">${</span><span class="va">stateBefore</span>.<span class="at">counter</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb307-5" title="5">    <span class="at">dispatch</span>(<span class="at">incrementByAmount</span>(amount))<span class="op">;</span></a>
<a class="sourceLine" id="cb307-6" title="6">    <span class="kw">const</span> stateAfter <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb307-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Counter after: </span><span class="sc">${</span><span class="va">stateAfter</span>.<span class="at">counter</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb307-8" title="8">  <span class="op">};</span></a>
<a class="sourceLine" id="cb307-9" title="9"><span class="op">};</span></a>
<a class="sourceLine" id="cb307-10" title="10"></a>
<a class="sourceLine" id="cb307-11" title="11"><span class="va">store</span>.<span class="at">dispatch</span>(<span class="at">logAndAdd</span>(<span class="dv">5</span>))<span class="op">;</span></a></code></pre></div>
<p>Thunks are typically written in “slice” files. <code>createSlice</code> itself does not have any special support for defining thunks, so you should write them as separate functions in the same slice file. That way, they have access to the plain action creators for that slice, and it’s easy to find where the thunk lives.</p>
<div class="info">
<p>The word “thunk” is a programming term that means <a href="https://en.wikipedia.org/wiki/Thunk">“a piece of code that does some delayed work”</a>. For more details on how to use thunks, see the thunk usage guide page:</p>
<ul>
<li><a href="../../usage/writing-logic-thunks.mdx">Using Redux: Writing Logic with Thunks</a></li>
</ul>
<p>as well as these posts:</p>
<ul>
<li><a href="https://daveceddia.com/what-is-a-thunk/">What the heck is a thunk?</a></li>
<li><a href="https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60">Thunks in Redux: the basics</a></li>
</ul>
</div>
<h3 id="writing-async-thunks">Writing Async Thunks</h3>
<p>Thunks may have async logic inside of them, such as <code>setTimeout</code>, <code>Promise</code>s, and <code>async/await</code>. This makes them a good place to put AJAX calls to a server API.</p>
<p>Data fetching logic for Redux typically follows a predictable pattern:</p>
<ul>
<li>A “start” action is dispatched before the request, to indicate that the request is in progress. This may be used to track loading state to allow skipping duplicate requests or show loading indicators in the UI.</li>
<li>The async request is made</li>
<li>Depending on the request result, the async logic dispatches either a “success” action containing the result data, or a “failure” action containing error details. The reducer logic clears the loading state in both cases, and either processes the result data from the success case, or stores the error value for potential display.</li>
</ul>
<p>These steps are not <em>required</em>, but are commonly used. (If all you care about is a successful result, you can just dispatch a single “success” action when the request finishes, and skip the “start” and “failure” actions.)</p>
<p>Redux Toolkit provides a <code>createAsyncThunk</code> API to implement the creation and dispatching of these actions, and we’ll look at how to use it shortly.</p>
<p><DetailedExplanation title="Detailed Explanation: Dispatching Request Status Actions in Thunks"></p>
<p>If we were to write out the code for a typical async thunk by hand, it might look like this:</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb308-1" title="1"><span class="kw">const</span> getRepoDetailsStarted <span class="op">=</span> () <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb308-2" title="2">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;repoDetails/fetchStarted&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb308-3" title="3"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb308-4" title="4"><span class="kw">const</span> getRepoDetailsSuccess <span class="op">=</span> (repoDetails) <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb308-5" title="5">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;repoDetails/fetchSucceeded&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb308-6" title="6">  <span class="dt">payload</span><span class="op">:</span> repoDetails<span class="op">,</span></a>
<a class="sourceLine" id="cb308-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb308-8" title="8"><span class="kw">const</span> getRepoDetailsFailed <span class="op">=</span> (error) <span class="kw">=&gt;</span> (<span class="op">{</span></a>
<a class="sourceLine" id="cb308-9" title="9">  <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;repoDetails/fetchFailed&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb308-10" title="10">  error<span class="op">,</span></a>
<a class="sourceLine" id="cb308-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb308-12" title="12"><span class="kw">const</span> fetchIssuesCount <span class="op">=</span> (org<span class="op">,</span> repo) <span class="kw">=&gt;</span> <span class="kw">async</span> (dispatch) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb308-13" title="13">  <span class="at">dispatch</span>(<span class="at">getRepoDetailsStarted</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb308-14" title="14">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb308-15" title="15">    <span class="kw">const</span> repoDetails <span class="op">=</span> <span class="cf">await</span> <span class="at">getRepoDetails</span>(org<span class="op">,</span> repo)<span class="op">;</span></a>
<a class="sourceLine" id="cb308-16" title="16">    <span class="at">dispatch</span>(<span class="at">getRepoDetailsSuccess</span>(repoDetails))<span class="op">;</span></a>
<a class="sourceLine" id="cb308-17" title="17">  <span class="op">}</span> <span class="cf">catch</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb308-18" title="18">    <span class="at">dispatch</span>(<span class="at">getRepoDetailsFailed</span>(<span class="va">err</span>.<span class="at">toString</span>()))<span class="op">;</span></a>
<a class="sourceLine" id="cb308-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb308-20" title="20"><span class="op">};</span></a></code></pre></div>
<p>However, writing code using this approach is tedious. Each separate type of request needs repeated similar implementation:</p>
<ul>
<li>Unique action types need to be defined for the three different cases</li>
<li>Each of those action types usually has a corresponding action creator function</li>
<li>A thunk has to be written that dispatches the correct actions in the right sequence</li>
</ul>
<p><code>createAsyncThunk</code> abstracts this pattern by generating the action types and action creators, and generating a thunk that dispatches those actions automatically. You provide a callback function that makes the async call and returns a Promise with the result.</p>
<p></DetailedExplanation></p>
<p><br /></p>
<div class="tip">
<p>Redux Toolkit has a new <a href="https://redux-toolkit.js.org/rtk-query/overview"><strong>RTK Query data fetching API</strong></a>. RTK Query is a purpose built data fetching and caching solution for Redux apps, and <strong>can eliminate the need to write <em>any</em> thunks or reducers to manage data fetching</strong>. We encourage you to try it out and see if it can help simplify the data fetching code in your own apps!</p>
<p>We’ll cover how to use RTK Query starting in <a href="./part-7-rtk-query-basics.md">Part 7: RTK Query Basics</a>.</p>
</div>
<h2 id="loading-posts">Loading Posts</h2>
<p>So far, our <code>postsSlice</code> has used some hardcoded sample data as its initial state. We’re going to switch that to start with an empty array of posts instead, and then fetch a list of posts from the server.</p>
<p>In order to do that, we’re going to have to change the structure of the state in our <code>postsSlice</code>, so that we can keep track of the current state of the API request.</p>
<h3 id="extracting-posts-selectors">Extracting Posts Selectors</h3>
<p>Right now, the <code>postsSlice</code> state is a single array of <code>posts</code>. We need to change that to be an object that has the <code>posts</code> array, plus the loading state fields.</p>
<p>Meanwhile, the UI components like <code>&lt;PostsList&gt;</code> are trying to read posts from <code>state.posts</code> in their <code>useSelector</code> hooks, assuming that that field is an array. We need to change those locations also to match the new data.</p>
<p>It would be nice if we didn’t have to keep rewriting our components every time we made a change to the data format in our reducers. One way to avoid this is to define reusable selector functions in the slice files, and have the components use those selectors to extract the data they need instead of repeating the selector logic in each component. That way, if we do change our state structure again, we only need to update the code in the slice file.</p>
<p>The <code>&lt;PostsList&gt;</code> component needs to read a list of all the posts, and the <code>&lt;SinglePostPage&gt;</code> and <code>&lt;EditPostForm&gt;</code> components need to look up a single post by its ID. Let’s export two small selector functions from <code>postsSlice.js</code> to cover those cases:</p>
<p>```js title=“features/posts/postsSlice.js” const postsSlice = createSlice(/* omit slice code*/);</p>
<p>export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;</p>
<p>export default postsSlice.reducer;</p>
<p>// highlight-start export const selectAllPosts = (state) =&gt; state.posts;</p>
<p>export const selectPostById = (state, postId) =&gt; state.posts.find((post) =&gt; post.id === postId); //highlight-end ```</p>
<p>Note that the <code>state</code> parameter for these selector functions is the root Redux state object, as it was for the inlined anonymous selectors we wrote directly inside of <code>useSelector</code>.</p>
<p>We can then use them in the components:</p>
<p>```js title=“features/posts/PostsList.js” // omit imports // highlight-next-line import { selectAllPosts } from “./postsSlice”;</p>
<p>export const PostsList = () =&gt; { // highlight-next-line const posts = useSelector(selectAllPosts); // omit component contents }; ```</p>
<p>```js title=“features/posts/SinglePostPage.js” // omit imports //highlight-next-line import { selectPostById } from “./postsSlice”;</p>
<p>export const SinglePostPage = ({ match }) =&gt; { const { postId } = match.params;</p>
<p>// highlight-next-line const post = useSelector((state) =&gt; selectPostById(state, postId)); // omit component logic }; ```</p>
<p>```js title=“features/posts/EditPostForm.js” // omit imports //highlight-next-line import { postUpdated, selectPostById } from “./postsSlice”;</p>
<p>export const EditPostForm = ({ match }) =&gt; { const { postId } = match.params;</p>
<p>// highlight-next-line const post = useSelector((state) =&gt; selectPostById(state, postId)); // omit component logic }; ```</p>
<p>It’s often a good idea to encapsulate data lookups by writing reusable selectors. You can also create “memoized” selectors that can help improve performance, which we’ll look at in a later part of this tutorial.</p>
<p>But, like any abstraction, it’s not something you should do <em>all</em> the time, everywhere. Writing selectors means more code to understand and maintain. <strong>Don’t feel like you need to write selectors for every single field of your state</strong>. Try starting without any selectors, and add some later when you find yourself looking up the same values in many parts of your application code.</p>
<h3 id="loading-state-for-requests">Loading State for Requests</h3>
<p>When we make an API call, we can view its progress as a small state machine that can be in one of four possible states:</p>
<ul>
<li>The request hasn’t started yet</li>
<li>The request is in progress</li>
<li>The request succeeded, and we now have the data we need</li>
<li>The request failed, and there’s probably an error message</li>
</ul>
<p>We <em>could</em> track that information using some booleans, like <code>isLoading: true</code>, but it’s better to track these states as a single enum value. A good pattern for this is to have a state section that looks like this (using TypeScript type notation):</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode ts"><code class="sourceCode typescript"><a class="sourceLine" id="cb309-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb309-2" title="2">  <span class="co">// Multiple possible status enum values</span></a>
<a class="sourceLine" id="cb309-3" title="3">  status<span class="op">:</span> <span class="st">&#39;idle&#39;</span> <span class="op">|</span> <span class="st">&#39;loading&#39;</span> <span class="op">|</span> <span class="st">&#39;succeeded&#39;</span> <span class="op">|</span> <span class="st">&#39;failed&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb309-4" title="4">  error<span class="op">:</span> <span class="dt">string</span> <span class="op">|</span> <span class="dt">null</span></a>
<a class="sourceLine" id="cb309-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>These fields would exist alongside whatever actual data is being stored. These specific string state names aren’t required - feel free to use other names if you want, like <code>'pending'</code> instead of <code>'loading'</code>, or <code>'complete'</code> instead of <code>'succeeded'</code>.</p>
<p>We can use this information to decide what to show in our UI as the request progresses, and also add logic in our reducers to prevent cases like loading data twice.</p>
<p>Let’s update our <code>postsSlice</code> to use this pattern to track loading state for a “fetch posts” request. We’ll switch our state from being an array of posts by itself, to look like <code>{posts, status, error}</code>. We’ll also remove the old sample post entries from our initial state. As part of this change, we also need to change any uses of <code>state</code> as an array to be <code>state.posts</code> instead, because the array is now one level deeper:</p>
<p>```js title=“features/posts/postsSlice.js” import { createSlice, nanoid } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>// highlight-start const initialState = { posts: [], status: “idle”, error: null, }; //highlight-end</p>
<p>const postsSlice = createSlice({ name: “posts”, initialState, reducers: { postAdded: { reducer(state, action) { // highlight-next-line state.posts.push(action.payload); }, prepare(title, content, userId) { // omit prepare logic }, }, reactionAdded(state, action) { const { postId, reaction } = action.payload; // highlight-next-line const existingPost = state.posts.find((post) =&gt; post.id === postId); if (existingPost) { existingPost.reactions[reaction]++; } }, postUpdated(state, action) { const { id, title, content } = action.payload; // highlight-next-line const existingPost = state.posts.find((post) =&gt; post.id === id); if (existingPost) { existingPost.title = title; existingPost.content = content; } }, }, });</p>
<p>export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;</p>
<p>export default postsSlice.reducer;</p>
<p>// highlight-start export const selectAllPosts = (state) =&gt; state.posts.posts;</p>
<p>export const selectPostById = (state, postId) =&gt; state.posts.posts.find((post) =&gt; post.id === postId); // highlight-end ```</p>
<p>Yes, this <em>does</em> mean that we now have a nested object path that looks like <code>state.posts.posts</code>, which is somewhat repetitive and silly :) We <em>could</em> change the nested array name to be <code>items</code> or <code>data</code> or something if we wanted to avoid that, but we’ll leave it as-is for now.</p>
<h3 id="fetching-data-with-createasyncthunk">Fetching Data with <code>createAsyncThunk</code></h3>
<p>Redux Toolkit’s <code>createAsyncThunk</code> API generates thunks that automatically dispatch those “start/success/failure” actions for you.</p>
<p>Let’s start by adding a thunk that will make an AJAX call to retrieve a list of posts. We’ll import the <code>client</code> utility from the <code>src/api</code> folder, and use that to make a request to <code>'/fakeApi/posts'</code>.</p>
<p>```js title=“features/posts/postsSlice” // highlight-next-line import { createSlice, nanoid, createAsyncThunk } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; // highlight-next-line import { client } from “../../api/client”;</p>
<p>const initialState = { posts: [], status: “idle”, error: null, };</p>
<p>// highlight-start export const fetchPosts = createAsyncThunk(“posts/fetchPosts”, async () =&gt; { const response = await client.get(“/fakeApi/posts”); return response.data; }); // highlight-end ```</p>
<p><code>createAsyncThunk</code> accepts two arguments:</p>
<ul>
<li>A string that will be used as the prefix for the generated action types</li>
<li>A “payload creator” callback function that should return a <code>Promise</code> containing some data, or a rejected <code>Promise</code> with an error</li>
</ul>
<p>The payload creator will usually make an AJAX call of some kind, and can either return the <code>Promise</code> from the AJAX call directly, or extract some data from the API response and return that. We typically write this using the JS <code>async/await</code> syntax, which lets us write functions that use <code>Promise</code>s while using standard <code>try/catch</code> logic instead of <code>somePromise.then()</code> chains.</p>
<p>In this case, we pass in <code>'posts/fetchPosts'</code> as the action type prefix. Our payload creation callback waits for the API call to return a response. The response object looks like <code>{data: []}</code>, and we want our dispatched Redux action to have a payload that is <em>just</em> the array of posts. So, we extract <code>response.data</code>, and return that from the callback.</p>
<p>If we try calling <code>dispatch(fetchPosts())</code>, the <code>fetchPosts</code> thunk will first dispatch an action type of <code>'posts/fetchPosts/pending'</code>:</p>
<figure>
<img src="/img/tutorials/essentials/devtools-posts-pending.png" alt="createAsyncThunk: posts pending action" /><figcaption><code>createAsyncThunk</code>: posts pending action</figcaption>
</figure>
<p>We can listen for this action in our reducer and mark the request status as <code>'loading'</code>.</p>
<p>Once the <code>Promise</code> resolves, the <code>fetchPosts</code> thunk takes the <code>response.data</code> array we returned from the callback, and dispatches a <code>'posts/fetchPosts/fulfilled'</code> action containing the posts array as <code>action.payload</code>:</p>
<figure>
<img src="/img/tutorials/essentials/devtools-posts-fulfilled.png" alt="createAsyncThunk: posts pending action" /><figcaption><code>createAsyncThunk</code>: posts pending action</figcaption>
</figure>
<h4 id="dispatching-thunks-from-components">Dispatching Thunks from Components</h4>
<p>So, let’s update our <code>&lt;PostsList&gt;</code> component to actually fetch this data automatically for us.</p>
<p>We’ll import the <code>fetchPosts</code> thunk into the component. Like all of our other action creators, we have to dispatch it, so we’ll also need to add the <code>useDispatch</code> hook. Since we want to fetch this data when <code>&lt;PostsList&gt;</code> mounts, we need to import the React <code>useEffect</code> hook:</p>
<p>```js title=“features/posts/PostsList.js” // highlight-start import React, { useEffect } from “react”; import { useSelector, useDispatch } from “react-redux”; // omit other imports // highlight-end //highlight-next-line import { selectAllPosts, fetchPosts } from “./postsSlice”;</p>
<p>export const PostsList = () =&gt; { // highlight-next-line const dispatch = useDispatch(); const posts = useSelector(selectAllPosts);</p>
<p>// highlight-start const postStatus = useSelector((state) =&gt; state.posts.status);</p>
<p>useEffect(() =&gt; { if (postStatus === “idle”) { dispatch(fetchPosts()); } }, [postStatus, dispatch]); // highlight-end</p>
<p>// omit rendering logic }; ```</p>
<p>It’s important that we only try to fetch the list of posts once. If we do it every time the <code>&lt;PostsList&gt;</code> component renders, or is re-created because we’ve switched between views, we might end up fetching the posts several times. We can use the <code>posts.status</code> enum to help decide if we need to actually start fetching, by selecting that into the component and only starting the fetch if the status is <code>'idle'</code>.</p>
<h3 id="reducers-and-loading-actions">Reducers and Loading Actions</h3>
<p>Next up, we need to handle both these actions in our reducers. This requires a bit deeper look at the <code>createSlice</code> API we’ve been using.</p>
<p>We’ve already seen that <code>createSlice</code> will generate an action creator for every reducer function we define in the <code>reducers</code> field, and that the generated action types include the name of the slice, like:</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb310-1" title="1"><span class="va">console</span>.<span class="at">log</span>(</a>
<a class="sourceLine" id="cb310-2" title="2">  <span class="at">postUpdated</span>(<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&quot;123&quot;</span><span class="op">,</span> <span class="dt">title</span><span class="op">:</span> <span class="st">&quot;First Post&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="st">&quot;Some text here&quot;</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb310-3" title="3">)<span class="op">;</span></a>
<a class="sourceLine" id="cb310-4" title="4"><span class="co">/*</span></a>
<a class="sourceLine" id="cb310-5" title="5"><span class="co">{</span></a>
<a class="sourceLine" id="cb310-6" title="6"><span class="co">  type: &#39;posts/postUpdated&#39;,</span></a>
<a class="sourceLine" id="cb310-7" title="7"><span class="co">  payload: {</span></a>
<a class="sourceLine" id="cb310-8" title="8"><span class="co">    id: &#39;123&#39;,</span></a>
<a class="sourceLine" id="cb310-9" title="9"><span class="co">    title: &#39;First Post&#39;,</span></a>
<a class="sourceLine" id="cb310-10" title="10"><span class="co">    content: &#39;Some text here&#39;</span></a>
<a class="sourceLine" id="cb310-11" title="11"><span class="co">  }</span></a>
<a class="sourceLine" id="cb310-12" title="12"><span class="co">}</span></a>
<a class="sourceLine" id="cb310-13" title="13"><span class="co">*/</span></a></code></pre></div>
<p>However, there are times when a slice reducer needs to respond to <em>other</em> actions that weren’t defined as part of this slice’s <code>reducers</code> field. We can do that using the slice <code>extraReducers</code> field instead.</p>
<p>The <code>extraReducers</code> option should be a function that receives a parameter called <code>builder</code>. The <code>builder</code> object provides methods that let us define additional case reducers that will run in response to actions defined outside of the slice. We’ll use <code>builder.addCase(actionCreator, reducer)</code> to handle each of the actions dispatched by our async thunks.</p>
<p><DetailedExplanation title="Detailed Explanation: Adding Extra Reducers to Slices"></p>
<p>The <code>builder</code> object in <code>extraReducers</code> provides methods that let us define additional case reducers that will run in response to actions defined outside of the slice:</p>
<ul>
<li><code>builder.addCase(actionCreator, reducer)</code>: defines a case reducer that handles a single known action type based on either an RTK action creator or a plain action type string</li>
<li><code>builder.addMatcher(matcher, reducer)</code>: defines a case reducer that can run in response to any action where the <code>matcher</code> function returns <code>true</code></li>
<li><code>builder.addDefaultCase(reducer)</code>: defines a case reducer that will run if no other case reducers were executed for this action.</li>
</ul>
<p>You can chain these together, like <code>builder.addCase().addCase().addMatcher().addDefault()</code>. If multiple matchers match the action, they will run in the order they were defined.</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb311-1" title="1"><span class="im">import</span> <span class="op">{</span> increment <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../features/counter/counterSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb311-2" title="2"></a>
<a class="sourceLine" id="cb311-3" title="3"><span class="kw">const</span> postsSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb311-4" title="4">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;posts&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb311-5" title="5">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb311-6" title="6">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb311-7" title="7">    <span class="co">// slice-specific reducers here</span></a>
<a class="sourceLine" id="cb311-8" title="8">  <span class="op">},</span></a>
<a class="sourceLine" id="cb311-9" title="9">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb311-10" title="10">  <span class="dt">extraReducers</span><span class="op">:</span> (builder) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb311-11" title="11">    builder</a>
<a class="sourceLine" id="cb311-12" title="12">      .<span class="at">addCase</span>(<span class="st">&quot;counter/decrement&quot;</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{}</span>)</a>
<a class="sourceLine" id="cb311-13" title="13">      .<span class="at">addCase</span>(increment<span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb311-14" title="14">  <span class="op">},</span></a>
<a class="sourceLine" id="cb311-15" title="15">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb311-16" title="16"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>If you’re using TypeScript, you should use the builder callback form of <code>extraReducers</code>.</p>
<p>Alternately, <code>extraReducers</code> can also be an object. <strong>This is a legacy syntax - it’s still supported, but we recommend the “builder callback” syntax as it works better with TypeScript.</strong></p>
<p>The keys in the <code>extraReducers</code> object should be Redux action type strings, like <code>'counter/increment'</code>. We <em>could</em> write those by hand ourselves, although we’d have to quote the keys if they contain any characters like ‘/’:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb312-1" title="1"><span class="kw">const</span> postsSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb312-2" title="2">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;posts&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb312-3" title="3">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb312-4" title="4">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb312-5" title="5">    <span class="co">// slice-specific reducers here</span></a>
<a class="sourceLine" id="cb312-6" title="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb312-7" title="7">  <span class="dt">extraReducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb312-8" title="8">    <span class="st">&quot;counter/increment&quot;</span><span class="op">:</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb312-9" title="9">      <span class="co">// normal reducer logic to update the posts slice</span></a>
<a class="sourceLine" id="cb312-10" title="10">    <span class="op">},</span></a>
<a class="sourceLine" id="cb312-11" title="11">  <span class="op">},</span></a>
<a class="sourceLine" id="cb312-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>However, action creators generated by Redux Toolkit automatically return their action type string if you call <code>actionCreator.toString()</code>. This means we can pass them as ES6 object literal computed properties, and the action types will become the keys of the object:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb313-1" title="1"><span class="im">import</span> <span class="op">{</span> increment <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../features/counter/counterSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb313-2" title="2"><span class="kw">const</span> object <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb313-3" title="3">  [increment]<span class="op">:</span> () <span class="kw">=&gt;</span> <span class="op">{},</span></a>
<a class="sourceLine" id="cb313-4" title="4"><span class="op">};</span></a>
<a class="sourceLine" id="cb313-5" title="5"><span class="va">console</span>.<span class="at">log</span>(object)<span class="op">;</span></a>
<a class="sourceLine" id="cb313-6" title="6"><span class="co">// { &quot;counter/increment&quot;: Function}</span></a></code></pre></div>
<p>This works for the <code>extraReducers</code> field when used as an object:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb314-1" title="1"><span class="im">import</span> <span class="op">{</span> increment <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../features/counter/counterSlice&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb314-2" title="2"></a>
<a class="sourceLine" id="cb314-3" title="3"><span class="kw">const</span> postsSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb314-4" title="4">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;posts&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb314-5" title="5">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb314-6" title="6">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb314-7" title="7">    <span class="co">// slice-specific reducers here</span></a>
<a class="sourceLine" id="cb314-8" title="8">  <span class="op">},</span></a>
<a class="sourceLine" id="cb314-9" title="9">  <span class="dt">extraReducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb314-10" title="10">    <span class="co">// highlight-next-line</span></a>
<a class="sourceLine" id="cb314-11" title="11">    [increment]<span class="op">:</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb314-12" title="12">      <span class="co">// normal reducer logic to update the posts slice</span></a>
<a class="sourceLine" id="cb314-13" title="13">    <span class="op">},</span></a>
<a class="sourceLine" id="cb314-14" title="14">  <span class="op">},</span></a>
<a class="sourceLine" id="cb314-15" title="15"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Unfortunately, TypeScript fails to recognize this will work correctly, so you have to use <code>increment.type</code> here to pass the type string. It also will not correctly infer the type of <code>action</code> inside the reducer.</p>
<p></DetailedExplanation></p>
<p>In this case, we need to listen for the “pending” and “fulfilled” action types dispatched by our <code>fetchPosts</code> thunk. Those action creators are attached to our actual <code>fetchPost</code> function, and we can pass those to <code>extraReducers</code> to listen for those actions:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb315-1" title="1"><span class="im">export</span> <span class="kw">const</span> fetchPosts <span class="op">=</span> <span class="at">createAsyncThunk</span>(<span class="st">&quot;posts/fetchPosts&quot;</span><span class="op">,</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb315-2" title="2">  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="va">client</span>.<span class="at">get</span>(<span class="st">&quot;/fakeApi/posts&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb315-3" title="3">  <span class="cf">return</span> <span class="va">response</span>.<span class="at">data</span><span class="op">;</span></a>
<a class="sourceLine" id="cb315-4" title="4"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb315-5" title="5"></a>
<a class="sourceLine" id="cb315-6" title="6"><span class="kw">const</span> postsSlice <span class="op">=</span> <span class="at">createSlice</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb315-7" title="7">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;posts&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb315-8" title="8">  initialState<span class="op">,</span></a>
<a class="sourceLine" id="cb315-9" title="9">  <span class="dt">reducers</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb315-10" title="10">    <span class="co">// omit existing reducers here</span></a>
<a class="sourceLine" id="cb315-11" title="11">  <span class="op">},</span></a>
<a class="sourceLine" id="cb315-12" title="12">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb315-13" title="13">  <span class="at">extraReducers</span>(builder) <span class="op">{</span></a>
<a class="sourceLine" id="cb315-14" title="14">    builder</a>
<a class="sourceLine" id="cb315-15" title="15">      .<span class="at">addCase</span>(<span class="va">fetchPosts</span>.<span class="at">pending</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb315-16" title="16">        <span class="va">state</span>.<span class="at">status</span> <span class="op">=</span> <span class="st">&quot;loading&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb315-17" title="17">      <span class="op">}</span>)</a>
<a class="sourceLine" id="cb315-18" title="18">      .<span class="at">addCase</span>(<span class="va">fetchPosts</span>.<span class="at">fulfilled</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb315-19" title="19">        <span class="va">state</span>.<span class="at">status</span> <span class="op">=</span> <span class="st">&quot;succeeded&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb315-20" title="20">        <span class="co">// Add any fetched posts to the array</span></a>
<a class="sourceLine" id="cb315-21" title="21">        <span class="va">state</span>.<span class="at">posts</span> <span class="op">=</span> <span class="va">state</span>.<span class="va">posts</span>.<span class="at">concat</span>(<span class="va">action</span>.<span class="at">payload</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb315-22" title="22">      <span class="op">}</span>)</a>
<a class="sourceLine" id="cb315-23" title="23">      .<span class="at">addCase</span>(<span class="va">fetchPosts</span>.<span class="at">rejected</span><span class="op">,</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb315-24" title="24">        <span class="va">state</span>.<span class="at">status</span> <span class="op">=</span> <span class="st">&quot;failed&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb315-25" title="25">        <span class="va">state</span>.<span class="at">error</span> <span class="op">=</span> <span class="va">action</span>.<span class="va">error</span>.<span class="at">message</span><span class="op">;</span></a>
<a class="sourceLine" id="cb315-26" title="26">      <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb315-27" title="27">  <span class="op">},</span></a>
<a class="sourceLine" id="cb315-28" title="28">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb315-29" title="29"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>We’ll handle all three action types that could be dispatched by the thunk, based on the <code>Promise</code> we returned:</p>
<ul>
<li>When the request starts, we’ll set the <code>status</code> enum to <code>'loading'</code></li>
<li>If the request succeeds, we mark the <code>status</code> as <code>'succeeded'</code>, and add the fetched posts to <code>state.posts</code></li>
<li>If the request fails, we’ll mark the <code>status</code> as <code>'failed'</code>, and save any error message into the state so we can display it</li>
</ul>
<h3 id="displaying-loading-state">Displaying Loading State</h3>
<p>Our <code>&lt;PostsList&gt;</code> component is already checking for any updates to the posts that are stored in Redux, and rerendering itself any time that list changes. So, if we refresh the page, we should see a random set of posts from our fake API show up on screen:</p>
<p>The fake API we’re using returns data immediately. However, a real API call will probably take some time to return a response. It’s usually a good idea to show some kind of “loading…” indicator in the UI so the user knows we’re waiting for data.</p>
<p>We can update our <code>&lt;PostsList&gt;</code> to show a different bit of UI based on the <code>state.posts.status</code> enum: a spinner if we’re loading, an error message if it failed, or the actual posts list if we have the data. While we’re at it, this is probably a good time to extract a <code>&lt;PostExcerpt&gt;</code> component to encapsulate the rendering for one item in the list as well.</p>
<p>The result might look like this:</p>
<p>```jsx title=“features/posts/PostsList.js” // highlight-next-line import { Spinner } from “../../components/Spinner”; import { PostAuthor } from “./PostAuthor”; import { TimeAgo } from “./TimeAgo”; import { ReactionButtons } from “./ReactionButtons”; import { selectAllPosts, fetchPosts } from “./postsSlice”;</p>
// highlight-start const PostExcerpt = ({ post }) =&gt; { return (
<article className="post-excerpt" key={post.id}>
<h3>
{post.title}
</h3>
<div>
<pre><code>    &lt;PostAuthor userId={post.user} /&gt;
    &lt;TimeAgo timestamp={post.date} /&gt;
  &lt;/div&gt;
  &lt;p className=&quot;post-content&quot;&gt;{post.content.substring(0, 100)}&lt;/p&gt;

  &lt;ReactionButtons post={post} /&gt;
  &lt;Link to={`/posts/${post.id}`} className=&quot;button muted-button&quot;&gt;
    View Post
  &lt;/Link&gt;
&lt;/article&gt;</code></pre>
<p>); }; // highlight-end</p>
<p>export const PostsList = () =&gt; { const dispatch = useDispatch(); const posts = useSelector(selectAllPosts);</p>
<p>const postStatus = useSelector((state) =&gt; state.posts.status); // highlight-next-line const error = useSelector((state) =&gt; state.posts.error);</p>
<p>useEffect(() =&gt; { if (postStatus === “idle”) { dispatch(fetchPosts()); } }, [postStatus, dispatch]);</p>
<p>// highlight-start let content;</p>
<p>if (postStatus === “loading”) { content = <Spinner text="Loading..." />; } else if (postStatus === “succeeded”) { // Sort posts in reverse chronological order by datetime string const orderedPosts = posts .slice() .sort((a, b) =&gt; b.date.localeCompare(a.date));</p>
<pre><code>content = orderedPosts.map((post) =&gt; (
  &lt;PostExcerpt key={post.id} post={post} /&gt;
));</code></pre>
} else if (postStatus === “failed”) { content =
<div>
{error}
</div>
<p>; } // highlight-end</p>
return (
<section className="posts-list">
<h2>
Posts
</h2>
{content}
</section>
<p>); }; ```</p>
<p>You might notice that the API calls are taking a while to complete, and that the loading spinner is staying on screen for a couple seconds. Our mock API server is configured to add a 2-second delay to all responses, specifically to help visualize times when there’s a loading spinner visible. If you want to change this behavior, you can open up <code>api/server.js</code>, and alter this line:</p>
<p><code>js title="api/server.js" // Add an extra delay to all endpoints, so loading spinners show up. const ARTIFICIAL_DELAY_MS = 2000;</code></p>
<p>Feel free to turn that on and off as we go if you want the API calls to complete faster.</p>
<h2 id="loading-users">Loading Users</h2>
<p>We’re now fetching and displaying our list of posts. But, if we look at the posts, there’s a problem: they all now say “Unknown author” as the authors:</p>
<figure>
<img src="/img/tutorials/essentials/posts-unknownAuthor.png" alt="Unknown post authors" /><figcaption>Unknown post authors</figcaption>
</figure>
<p>This is because the post entries are being randomly generated by the fake API server, which also randomly generates a set of fake users every time we reload the page. We need to update our users slice to fetch those users when the application starts.</p>
<p>Like last time, we’ll create another async thunk to get the users from the API and return them, then handle the <code>fulfilled</code> action in the <code>extraReducers</code> slice field. We’ll skip worrying about loading state for now:</p>
<p>```js title=“features/users/usersSlice.js” // highlight-start import { createSlice, createAsyncThunk } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; import { client } from “../../api/client”; // highlight-end</p>
<p>const initialState = [];</p>
<p>// highlight-start export const fetchUsers = createAsyncThunk(“users/fetchUsers”, async () =&gt; { const response = await client.get(“/fakeApi/users”); return response.data; }); // highlight-end</p>
<p>const usersSlice = createSlice({ name: “users”, initialState, reducers: {}, // highlight-start extraReducers(builder) { builder.addCase(fetchUsers.fulfilled, (state, action) =&gt; { return action.payload; }); }, // highlight-end });</p>
<p>export default usersSlice.reducer; ```</p>
<p>We only need to fetch the list of users once, and we want to do it right when the application starts. We can do that in our <code>index.js</code> file, and directly dispatch the <code>fetchUsers</code> thunk because we have the <code>store</code> right there:</p>
<p>```js title=“index.js” // omit imports</p>
<p>// highlight-next-line import { fetchUsers } from “./features/users/usersSlice”;</p>
<p>import { worker } from “./api/server”;</p>
<p>// Start our mock API server worker.start({ onUnhandledRequest: “bypass” });</p>
<p>// highlight-next-line store.dispatch(fetchUsers());</p>
<p>ReactDOM.render( &lt;React.StrictMode&gt; <Provider store={store}> <App /> </Provider> &lt;/React.StrictMode&gt;, document.getElementById(“root”) ); ```</p>
<p>Now, each of the posts should be showing a username again, and we should also have that same list of users shown in the “Author” dropdown in our <code>&lt;AddPostForm&gt;</code>.</p>
<h2 id="adding-new-posts-1">Adding New Posts</h2>
<p>We have one more step for this section. When we add a new post from the <code>&lt;AddPostForm&gt;</code>, that post is only getting added to the Redux store inside our app. We need to actually make an API call that will create the new post entry in our fake API server instead, so that it’s “saved”. (Since this is a fake API, the new post won’t persist if we reload the page, but if we had a real backend server it would be available next time we reload.)</p>
<h3 id="sending-data-with-thunks">Sending Data with Thunks</h3>
<p>We can use <code>createAsyncThunk</code> to help with sending data, not just fetching it. We’ll create a thunk that accepts the values from our <code>&lt;AddPostForm&gt;</code> as an argument, and makes an HTTP POST call to the fake API to save the data.</p>
<p>In the process, we’re going to change how we work with the new post object in our reducers. Currently, our <code>postsSlice</code> is creating a new post object in the <code>prepare</code> callback for <code>postAdded</code>, and generating a new unique ID for that post. In most apps that save data to a server, the server will take care of generating unique IDs and filling out any extra fields, and will usually return the completed data in its response. So, we can send a request body like <code>{ title, content, user: userId }</code> to the server, and then take the complete post object it sends back and add it to our <code>postsSlice</code> state.</p>
<p>``<code>js title="features/posts/postsSlice.js" // highlight-start export const addNewPost = createAsyncThunk(   "posts/addNewPost",   // The payload creator receives the partial</code>{title, content, user}` object async (initialPost) =&gt; { // We send the initial data to the fake API server const response = await client.post(“/fakeApi/posts”, initialPost); // The response includes the complete post object, including unique ID return response.data; } ); // highlight-end</p>
<p>const postsSlice = createSlice({ name: “posts”, initialState, reducers: { // The existing <code>postAdded</code> reducer and prepare callback were deleted reactionAdded(state, action) {}, // omit logic postUpdated(state, action) {}, // omit logic }, extraReducers(builder) { // omit posts loading reducers // highlight-start builder.addCase(addNewPost.fulfilled, (state, action) =&gt; { // We can directly add the new post object to our posts array state.posts.push(action.payload); }); // highlight-end }, }); ```</p>
<h3 id="checking-thunk-results-in-components">Checking Thunk Results in Components</h3>
<p>Finally, we’ll update <code>&lt;AddPostForm&gt;</code> to dispatch the <code>addNewPost</code> thunk instead of the old <code>postAdded</code> action. Since this is another API call to the server, it will take some time and <em>could</em> fail. The <code>addNewPost()</code> thunk will automatically dispatch its <code>pending/fulfilled/rejected</code> actions to the Redux store, which we’re already handling. We <em>could</em> track the request status in <code>postsSlice</code> using a second loading enum if we wanted to, but for this example let’s keep the loading state tracking limited to the component.</p>
<p>It would be good if we can at least disable the “Save Post” button while we’re waiting for the request, so the user can’t accidentally try to save a post twice. If the request fails, we might also want to show an error message here in the form, or perhaps just log it to the console.</p>
<p>We can have our component logic wait for the async thunk to finish, and check the result when it’s done:</p>
<p>```js title=“features/posts/AddPostForm.js” import React, { useState } from “react”; import { useDispatch, useSelector } from “react-redux”;</p>
<p>// highlight-next-line import { addNewPost } from “./postsSlice”;</p>
<p>export const AddPostForm = () =&gt; { const [title, setTitle] = useState("“); const [content, setContent] = useState(”“); const [userId, setUserId] = useState(”“); // highlight-next-line const [addRequestStatus, setAddRequestStatus] = useState(”idle");</p>
<p>// omit useSelectors and change handlers</p>
<p>// highlight-start const canSave = [title, content, userId].every(Boolean) &amp;&amp; addRequestStatus === “idle”;</p>
<p>const onSavePostClicked = async () =&gt; { if (canSave) { try { setAddRequestStatus(“pending”); await dispatch(addNewPost({ title, content, user: userId })).unwrap(); setTitle("“); setContent(”“); setUserId(”“); } catch (err) { console.error(”Failed to save the post: “, err); } finally { setAddRequestStatus(”idle"); } } }; // highlight-end</p>
<p>// omit rendering logic }; ```</p>
<p>We can add a loading status enum field as a React <code>useState</code> hook, similar to how we’re tracking loading state in <code>postsSlice</code> for fetching posts. In this case, we just want to know if the request is in progress or not.</p>
<p>When we call <code>dispatch(addNewPost())</code>, the async thunk returns a <code>Promise</code> from <code>dispatch</code>. We can <code>await</code> that promise here to know when the thunk has finished its request. But, we don’t yet know if that request succeeded or failed.</p>
<p><code>createAsyncThunk</code> handles any errors internally, so that we don’t see any messages about “rejected Promises” in our logs. It then returns the final action it dispatched: either the <code>fulfilled</code> action if it succeeded, or the <code>rejected</code> action if it failed.</p>
<p>However, it’s common to want to write logic that looks at the success or failure of the actual request that was made. Redux Toolkit adds a <code>.unwrap()</code> function to the returned <code>Promise</code>, which will return a new <code>Promise</code> that either has the actual <code>action.payload</code> value from a <code>fulfilled</code> action, or throws an error if it’s the <code>rejected</code> action. This lets us handle success and failure in the component using normal <code>try/catch</code> logic. So, we’ll clear out the input fields to reset the form if the post was successfully created, and log the error to the console if it failed.</p>
<p>If you want to see what happens when the <code>addNewPost</code> API call fails, try creating a new post where the “Content” field only has the word “error” (without quotes). The server will see that and send back a failed response, so you should see a message logged to the console.</p>
<h2 id="what-youve-learned-12">What You’ve Learned</h2>
<p>Async logic and data fetching are always a complex topic. As you’ve seen, Redux Toolkit includes some tools to automate the typical Redux data fetching patterns.</p>
<p>Here’s what our app looks like now that we’re fetching data from that fake API:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-3-postRequests/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-essentials-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>As a reminder, here’s what we covered in this section:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>You can write reusable “selector” functions to encapsulate reading values from the Redux state</strong>
<ul>
<li>Selectors are functions that get the Redux <code>state</code> as an argument, and return some data</li>
</ul></li>
<li><strong>Redux uses plugins called “middleware” to enable async logic</strong>
<ul>
<li>The standard async middleware is called <code>redux-thunk</code>, which is included in Redux Toolkit</li>
<li>Thunk functions receive <code>dispatch</code> and <code>getState</code> as arguments, and can use those as part of async logic</li>
</ul></li>
<li><strong>You can dispatch additional actions to help track the loading status of an API call</strong>
<ul>
<li>The typical pattern is dispatching a “pending” action before the call, then either a “success” containing the data or a “failure” action containing the error</li>
<li>Loading state should usually be stored as an enum, like <code>'idle' | 'loading' | 'succeeded' | 'failed'</code></li>
</ul></li>
<li><strong>Redux Toolkit has a <code>createAsyncThunk</code> API that dispatches these actions for you</strong>
<ul>
<li><code>createAsyncThunk</code> accepts a “payload creator” callback that should return a <code>Promise</code>, and generates <code>pending/fulfilled/rejected</code> action types automatically</li>
<li>Generated action creators like <code>fetchPosts</code> dispatch those actions based on the <code>Promise</code> you return</li>
<li>You can listen for these action types in <code>createSlice</code> using the <code>extraReducers</code> field, and update the state in reducers based on those actions.</li>
<li>Action creators can be used to automatically fill in the keys of the <code>extraReducers</code> object so the slice knows what actions to listen for.</li>
<li>Thunks can return promises. For <code>createAsyncThunk</code> specifically, you can <code>await dispatch(someThunk()).unwrap()</code> to handle the request success or failure at the component level.</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-11">What’s Next?</h2>
<p>We’ve got one more set of topics to cover the core Redux Toolkit APIs and usage patterns. In <a href="./part-6-performance-normalization.md">Part 6: Performance and Normalizing Data</a>, we’ll look at how Redux usage affects React performance, and some ways we can optimize our application for improved performance.</p>
<hr />
<p>id: part-6-performance-normalization title: ‘Redux Essentials, Part 6: Performance and Normalizing Data’ sidebar_label: ‘Performance and Normalizing Data’ description: ‘The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to create memoized selector functions with <code>createSelector</code></li>
<li>Patterns for optimizing component rendering performance</li>
<li>How to use <code>createEntityAdapter</code> to store and update normalized data</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Completion of <a href="./part-5-async-logic.md">Part 5</a> to understand data fetching flow</li>
</ul>
<p>:::</p>
<h2 id="introduction-12">Introduction</h2>
<p>In <a href="./part-5-async-logic.md">Part 5: Async Logic and Data Fetching</a>, we saw how to write async thunks to fetch data from a server API, patterns for handling async request loading state, and use of selector functions for encapsulating lookups of data from the Redux state.</p>
<p>In this section, we’ll look at optimized patterns for ensuring good performance in our application, and techniques for automatically handling common updates of data in the store.</p>
<p>So far, most of our functionality has been centered around the <code>posts</code> feature. We’re going to add a couple new sections of the app. After those are added, we’ll look at some specific details of how we’ve built things, and talk about some weaknesses with what we’ve built so far and how we can improve the implementation.</p>
<h2 id="adding-user-pages">Adding User Pages</h2>
<p>We’re fetching a list of users from our fake API, and we can choose a user as the author when we add a new post. But, a social media app needs the ability to look at the page for a specific user and see all the posts they’ve made. Let’s add a page to show the list of all users, and another to show all posts by a specific user.</p>
<p>We’ll start by adding a new <code>&lt;UsersList&gt;</code> component. It follows the usual pattern of reading some data from the store with <code>useSelector</code>, and mapping over the array to show a list of users with links to their individual pages:</p>
<p>```jsx title=“features/users/UsersList.js” import React from “react”; import { useSelector } from “react-redux”; import { Link } from “react-router-dom”; import { selectAllUsers } from “./usersSlice”;</p>
<p>export const UsersList = () =&gt; { const users = useSelector(selectAllUsers);</p>
const renderedUsers = users.map((user) =&gt; (
<li key="{user.id}">
<Link to={`/users/${user.id}`}>{user.name}</Link>
</li>
<p>));</p>
return (
<section>
<h2>
Users
</h2>
<ul>
{renderedUsers}
</ul>
</section>
<p>); }; ```</p>
<p>We don’t yet have a <code>selectAllUsers</code> selector, so we’ll need to add that to <code>usersSlice.js</code> along with a <code>selectUserById</code> selector:</p>
<p>```js title=“features/users/usersSlice.js” export default usersSlice.reducer;</p>
<p>// highlight-start export const selectAllUsers = (state) =&gt; state.users;</p>
<p>export const selectUserById = (state, userId) =&gt; state.users.find((user) =&gt; user.id === userId); // highlight-end ```</p>
<p>And we’ll add a <code>&lt;UserPage&gt;</code>, which is similar to our <code>&lt;SinglePostPage&gt;</code> in taking a <code>userId</code> parameter from the router:</p>
<p>```jsx title=“features/users/UserPage.js” import React from “react”; import { useSelector } from “react-redux”; import { Link } from “react-router-dom”;</p>
<p>import { selectUserById } from “../users/usersSlice”; import { selectAllPosts } from “../posts/postsSlice”;</p>
<p>export const UserPage = ({ match }) =&gt; { const { userId } = match.params;</p>
<p>const user = useSelector((state) =&gt; selectUserById(state, userId));</p>
<p>const postsForUser = useSelector((state) =&gt; { const allPosts = selectAllPosts(state); return allPosts.filter((post) =&gt; post.user === userId); });</p>
const postTitles = postsForUser.map((post) =&gt; (
<li key="{post.id}">
<Link to={`/posts/${post.id}`}>{post.title}</Link>
</li>
<p>));</p>
return (
<section>
<h2>
{user.name}
</h2>
<ul>
{postTitles}
</ul>
</section>
<p>); }; ```</p>
<p>As we’ve seen before, we can take data from one <code>useSelector</code> call, or from props, and use that to help decide what to read from the store in another <code>useSelector</code> call.</p>
<p>As usual, we will add routes for these components in <code>&lt;App&gt;</code>:</p>
<p><code>jsx title="App.js"           &lt;Route exact path="/posts/:postId" component={SinglePostPage} /&gt;           &lt;Route exact path="/editPost/:postId" component={EditPostForm} /&gt;           // highlight-start           &lt;Route exact path="/users" component={UsersList} /&gt;           &lt;Route exact path="/users/:userId" component={UserPage} /&gt;           // highlight-end           &lt;Redirect to="/" /&gt;</code></p>
<p>We’ll also add another tab in <code>&lt;Navbar&gt;</code> that links to <code>/users</code> so that we can click and go to <code>&lt;UsersList&gt;</code>:</p>
```jsx title=“app/Navbar.js” export const Navbar = () =&gt; { return ( <nav>
<section>
<h1>
Redux Essentials Example
</h1>
<div className="navContent">
<pre><code>      &lt;div className=&quot;navLinks&quot;&gt;
        &lt;Link to=&quot;/&quot;&gt;Posts&lt;/Link&gt;
        // highlight-next-line
        &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/nav&gt;</code></pre>
<p>); }; ```</p>
<h2 id="adding-notifications">Adding Notifications</h2>
<p>No social media app would be complete without some notifications popping up to tell us that someone has sent a message, left a comment, or reacted to one of our posts.</p>
<p>In a real application, our app client would be in constant communication with the backend server, and the server would push an update to the client every time something happens. Since this is a small example app, we’re going to mimic that process by adding a button to actually fetch some notification entries from our fake API. We also don’t have any other <em>real</em> users sending messages or reacting to posts, so the fake API will just create some random notification entries every time we make a request. (Remember, the goal here is to see how to use Redux itself.)</p>
<h3 id="notifications-slice">Notifications Slice</h3>
<p>Since this is a new part of our app, the first step is to create a new slice for our notifications, and an async thunk to fetch some notification entries from the API. In order to create some realistic notifications, we’ll include the timestamp of the latest notification we have in state. That will let our mock server generate notifications newer than that timestamp.</p>
<p>```js title=“features/notifications/notificationsSlice.js” import { createSlice, createAsyncThunk } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import { client } from “../../api/client”;</p>
<p>export const fetchNotifications = createAsyncThunk( “notifications/fetchNotifications”, async (_, { getState }) =&gt; { const allNotifications = selectAllNotifications(getState()); const [latestNotification] = allNotifications; const latestTimestamp = latestNotification ? latestNotification.date : ""; const response = await client.get( <code>/fakeApi/notifications?since=${latestTimestamp}</code> ); return response.data; } );</p>
<p>const notificationsSlice = createSlice({ name: “notifications”, initialState: [], reducers: {}, extraReducers: { [fetchNotifications.fulfilled]: (state, action) =&gt; { state.push(…action.payload); // Sort with newest first state.sort((a, b) =&gt; b.date.localeCompare(a.date)); }, }, });</p>
<p>export default notificationsSlice.reducer;</p>
<p>export const selectAllNotifications = (state) =&gt; state.notifications; ```</p>
<p>As with the other slices, import <code>notificationsReducer</code> into <code>store.js</code> and add it to the <code>configureStore()</code> call.</p>
<p>We’ve written an async thunk called <code>fetchNotifications</code>, which will retrieve a list of new notifications from the server. As part of that, we want to use the creation timestamp of the most recent notification as part of our request, so that the server knows it should only send back notifications that are actually new.</p>
<p>We know that we will be getting back an array of notifications, so we can pass them as separate arguments to <code>state.push()</code>, and the array will add each item. We also want to make sure that they’re sorted so that the most recent notification is last in the array, just in case the server were to send them out of order. (As a reminder, <code>array.sort()</code> always mutates the existing array - this is only safe because we’re using <code>createSlice</code> and Immer inside.)</p>
<h3 id="thunk-arguments">Thunk Arguments</h3>
<p>If you look at our <code>fetchNotifications</code> thunk, it has something new that we haven’t seen before. Let’s talk about thunk arguments for a minute.</p>
<p>We’ve already seen that we can pass an argument into a thunk action creator when we dispatch it, like <code>dispatch(addPost(newPost))</code>. For <code>createAsyncThunk</code> specifically, you can only pass in one argument, and whatever we pass in becomes the first argument of the payload creation callback.</p>
<p>The second argument to our payload creator is a <code>thunkAPI</code> object containing several useful functions and pieces of information:</p>
<ul>
<li><code>dispatch</code> and <code>getState</code>: the actual <code>dispatch</code> and <code>getState</code> methods from our Redux store. You can use these inside the thunk to dispatch more actions, or get the latest Redux store state (such as reading an updated value after another action is dispatched).</li>
<li><code>extra</code>: the “extra argument” that can be passed into the thunk middleware when creating the store. This is typically some kind of API wrapper, such as a set of functions that know how to make API calls to your application’s server and return data, so that your thunks don’t have to have all the URLs and query logic directly inside.</li>
<li><code>requestId</code>: a unique random ID value for this thunk call. Useful for tracking status of an individual request.</li>
<li><code>signal</code>: An <code>AbortController.signal</code> function that can be used to cancel an in-progress request.</li>
<li><code>rejectWithValue</code>: a utility that helps customize the contents of a <code>rejected</code> action if the thunk receives an error.</li>
</ul>
<p>(If you’re writing a thunk by hand instead of using <code>createAsyncThunk</code>, the thunk function will get<code>(dispatch, getState)</code> as separate arguments, instead of putting them together in one object.)</p>
<div class="info">
<p>For more details on these arguments and how to handle canceling thunks and requests, see <a href="https://redux-toolkit.js.org/api/createAsyncThunk">the <code>createAsyncThunk</code> API reference page</a>.</p>
</div>
<p>In this case, we know that the list of notifications is in our Redux store state, and that the latest notification should be first in the array. We can destructure the <code>getState</code> function out of the <code>thunkAPI</code> object, call it to read the state value, and use the <code>selectAllNotifications</code> selector to give us just the array of notifications. Since the array of notifications is sorted newest first, we can grab the latest one using array destructuring.</p>
<h3 id="adding-the-notifications-list">Adding the Notifications List</h3>
<p>With that slice created, we can add a <code>&lt;NotificationsList&gt;</code> component:</p>
<p>```jsx title=“features/notifications/NotificationsList.js” import React from “react”; import { useSelector } from “react-redux”; import { formatDistanceToNow, parseISO } from “date-fns”;</p>
<p>import { selectAllUsers } from “../users/usersSlice”;</p>
<p>import { selectAllNotifications } from “./notificationsSlice”;</p>
<p>export const NotificationsList = () =&gt; { const notifications = useSelector(selectAllNotifications); const users = useSelector(selectAllUsers);</p>
<p>const renderedNotifications = notifications.map((notification) =&gt; { const date = parseISO(notification.date); const timeAgo = formatDistanceToNow(date); const user = users.find((user) =&gt; user.id === notification.user) || { name: “Unknown User”, };</p>
<pre><code>return (
  &lt;div key={notification.id} className=&quot;notification&quot;&gt;
    &lt;div&gt;
      &lt;b&gt;{user.name}&lt;/b&gt; {notification.message}
    &lt;/div&gt;
    &lt;div title={notification.date}&gt;
      &lt;i&gt;{timeAgo} ago&lt;/i&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);</code></pre>
<p>});</p>
return (
<section className="notificationsList">
<h2>
Notifications
</h2>
{renderedNotifications}
</section>
<p>); }; ```</p>
<p>Once again, we’re reading a list of items from the Redux state, mapping over them, and rendering content for each item.</p>
<p>We also need to update the <code>&lt;Navbar&gt;</code> to add a “Notifications” tab, and a new button to fetch some notifications:</p>
<p>```jsx title=“app/Navbar.js” import React from “react”; // highlight-next-line import { useDispatch } from “react-redux”; import { Link } from “react-router-dom”;</p>
<p>// highlight-next-line import { fetchNotifications } from “../features/notifications/notificationsSlice”;</p>
<p>export const Navbar = () =&gt; { // highlight-start const dispatch = useDispatch();</p>
<p>const fetchNewNotifications = () =&gt; { dispatch(fetchNotifications()); }; // highlight-end</p>
return ( <nav>
<section>
<h1>
Redux Essentials Example
</h1>
<div className="navContent">
<pre><code>      &lt;div className=&quot;navLinks&quot;&gt;
        &lt;Link to=&quot;/&quot;&gt;Posts&lt;/Link&gt;
        &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
        // highlight-next-line
        &lt;Link to=&quot;/notifications&quot;&gt;Notifications&lt;/Link&gt;
      &lt;/div&gt;
      // highlight-start
      &lt;button className=&quot;button&quot; onClick={fetchNewNotifications}&gt;
        Refresh Notifications
      &lt;/button&gt;
      // highlight-end
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/nav&gt;</code></pre>
<p>); }; ```</p>
<p>Lastly, we need to update <code>App.js</code> with the “Notifications” route so we can navigate to it:</p>
<p>```js title=“App.js” // omit imports // highlight-next-line import { NotificationsList } from “./features/notifications/NotificationsList”;</p>
function App() { return ( <Router> <Navbar />
<div className="App">
<pre><code>    &lt;Switch&gt;
      // highlight-next-line
      &lt;Route exact path=&quot;/notifications&quot; component={NotificationsList} /&gt;
      // omit existing routes
      &lt;Redirect to=&quot;/&quot; /&gt;
    &lt;/Switch&gt;
  &lt;/div&gt;
&lt;/Router&gt;</code></pre>
<p>); } ```</p>
<p>Here’s what the “Notifications” tab looks like so far:</p>
<figure>
<img src="/img/tutorials/essentials/notifications-initial.png" alt="Initial Notifications tab" /><figcaption>Initial Notifications tab</figcaption>
</figure>
<h3 id="showing-new-notifications">Showing New Notifications</h3>
<p>Each time we click “Refresh Notifications”, a few more notification entries will be added to our list. In a real app, those could be coming from the server while we’re looking at other parts of the UI. We can do something similar by clicking “Refresh Notifications” while we’re looking at the <code>&lt;PostsList&gt;</code> or <code>&lt;UserPage&gt;</code>. But, right now we have no idea how many notifications just arrived, and if we keep clicking the button, there could be many notifications we haven’t read yet. Let’s add some logic to keep track of which notifications have been read and which of them are “new”. That will let us show the count of “Unread” notifications as a badge on our “Notifications” tab in the navbar, and display new notifications in a different color.</p>
<p>Our fake API is already sending back the notification entries with <code>isNew</code> and <code>read</code> fields, so we can use those in our code.</p>
<p>First, we’ll update <code>notificationsSlice</code> to have a reducer that marks all notifications as read, and some logic to handle marking existing notifications as “not new”:</p>
<p>```js title=“features/notifications/notificationsSlice.js” const notificationsSlice = createSlice({ name: “notifications”, initialState: [], reducers: { // highlight-start allNotificationsRead(state, action) { state.forEach((notification) =&gt; { notification.read = true; }); }, // highlight-end }, extraReducers(builder) { builder.addCase(fetchNotifications.fulfilled, (state, action) =&gt; { state.push(…action.payload); // highlight-start state.forEach((notification) =&gt; { // Any notifications we’ve read are no longer new notification.isNew = !notification.read; }); // highlight-end // Sort with newest first state.sort((a, b) =&gt; b.date.localeCompare(a.date)); }); }, });</p>
<p>// highlight-next-line export const { allNotificationsRead } = notificationsSlice.actions;</p>
<p>export default notificationsSlice.reducer; ```</p>
<p>We want to mark these notifications as read whenever our <code>&lt;NotificationsList&gt;</code> component renders, either because we clicked on the tab to view the notifications, or because we already have it open and we just received some additional notifications. We can do this by dispatching <code>allNotificationsRead</code> any time this component re-renders. In order to avoid flashing of old data as this updates, we’ll dispatch the action in a <code>useLayoutEffect</code> hook. We also want to add an additional classname to any notification list entries in the page, to highlight them:</p>
<p>```jsx title=“features/notifications/NotificationsList.js” import React, { useLayoutEffect } from “react”; // highlight-next-line import { useSelector, useDispatch } from “react-redux”; import { formatDistanceToNow, parseISO } from “date-fns”; // highlight-next-line import classnames from “classnames”;</p>
<p>import { selectAllUsers } from “../users/usersSlice”;</p>
<p>// highlight-start import { selectAllNotifications, allNotificationsRead, } from “./notificationsSlice”; // highlight-end</p>
<p>export const NotificationsList = () =&gt; { // highlight-next-line const dispatch = useDispatch(); const notifications = useSelector(selectAllNotifications); const users = useSelector(selectAllUsers);</p>
<p>// highlight-start useLayoutEffect(() =&gt; { dispatch(allNotificationsRead()); }); // highlight-end</p>
<p>const renderedNotifications = notifications.map((notification) =&gt; { const date = parseISO(notification.date); const timeAgo = formatDistanceToNow(date); const user = users.find((user) =&gt; user.id === notification.user) || { name: “Unknown User”, };</p>
<pre><code>// highlight-start
const notificationClassname = classnames(&quot;notification&quot;, {
  new: notification.isNew,
});

return (
  &lt;div key={notification.id} className={notificationClassname}&gt;
    // highlight-end
    &lt;div&gt;
      &lt;b&gt;{user.name}&lt;/b&gt; {notification.message}
    &lt;/div&gt;
    &lt;div title={notification.date}&gt;
      &lt;i&gt;{timeAgo} ago&lt;/i&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);</code></pre>
<p>});</p>
return (
<section className="notificationsList">
<h2>
Notifications
</h2>
{renderedNotifications}
</section>
<p>); }; ```</p>
<p>This works, but actually has a slightly surprising bit of behavior. Any time there are new notifications (either because we’ve just switched to this tab, or we’ve fetched some new notifications from the API), you’ll actually see <em>two</em> <code>"notifications/allNotificationsRead"</code> actions dispatched. Why is that?</p>
<p>Let’s say we have fetched some notifications while looking at the <code>&lt;PostsList&gt;</code>, and then click the “Notifications” tab. The <code>&lt;NotificationsList&gt;</code> component will mount, and the <code>useLayoutEffect</code> callback will run after that first render and dispatch <code>allNotificationsRead</code>. Our <code>notificationsSlice</code> will handle that by updating the notification entries in the store. This creates a new <code>state.notifications</code> array containing the immutably-updated entries, which forces our component to render again because it sees a new array returned from the <code>useSelector</code>, and the <code>useLayoutEffect</code> hook runs again and dispatches <code>allNotificationsRead</code> a second time. The reducer runs again, but this time no data changes, so the component doesn’t re-render.</p>
<p>There’s a couple ways we could potentially avoid that second dispatch, like splitting the logic to dispatch once when the component mounts, and only dispatch again if the size of the notifications array changes. But, this isn’t actually hurting anything, so we can leave it alone.</p>
<p>This does actually show that <strong>it’s possible to dispatch an action and not have <em>any</em> state changes happen at all</strong>. Remember, <strong>it’s always up to your reducers to decide <em>if</em> any state actually needs to be updated, and “nothing needs to happen” is a valid decision for a reducer to make</strong>.</p>
<p>Here’s how the notifications tab looks now that we’ve got the “new/read” behavior working:</p>
<figure>
<img src="/img/tutorials/essentials/notifications-new.png" alt="New notifications" /><figcaption>New notifications</figcaption>
</figure>
<p>The last thing we need to do before we move on is to add the badge on our “Notifications” tab in the navbar. This will show us the count of “Unread” notifications when we are in other tabs:</p>
<p>```jsx title=“app/Navbar.js” // omit imports // highlight-next-line import { useDispatch, useSelector } from “react-redux”;</p>
<p>// highlight-start import { fetchNotifications, selectAllNotifications, } from “../features/notifications/notificationsSlice”; // highlight-end</p>
<p>export const Navbar = () =&gt; { const dispatch = useDispatch(); // highlight-start const notifications = useSelector(selectAllNotifications); const numUnreadNotifications = notifications.filter((n) =&gt; !n.read).length; // highlight-end // omit component contents // highlight-start let unreadNotificationsBadge;</p>
if (numUnreadNotifications &gt; 0) { unreadNotificationsBadge = ( <span data-classname="badge">{numUnreadNotifications}</span> ); } // highlight-end return ( <nav> // omit component contents
<div className="navLinks">
<pre><code>    &lt;Link to=&quot;/&quot;&gt;Posts&lt;/Link&gt;
    &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;
    // highlight-start
    &lt;Link to=&quot;/notifications&quot;&gt;
      Notifications {unreadNotificationsBadge}
    &lt;/Link&gt;
    // highlight-end
  &lt;/div&gt;
  // omit component contents
&lt;/nav&gt;</code></pre>
<p>); }; ```</p>
<h2 id="improving-render-performance">Improving Render Performance</h2>
<p>Our application is looking useful, but we’ve actually got a couple flaws in when and how our components re-render. Let’s look at those problems, and talk about some ways to improve the performance.</p>
<h3 id="investigating-render-behavior">Investigating Render Behavior</h3>
<p>We can use the React DevTools Profiler to view some graphs of what components re-render when state is updated. Try clicking over to the <code>&lt;UserPage&gt;</code> for a single user. Open up your browser’s DevTools, and in the React “Profiler” tab, click the circle “Record” button in the upper-left. Then, click the “Refresh Notifications” button in our app, and stop the recording in the React DevTools Profiler. You should see a chart that looks like this:</p>
<figure>
<img src="/img/tutorials/essentials/userpage-rerender.png" alt="React DevTools Profiler render capture - " /><figcaption>React DevTools Profiler render capture - <UserPage></figcaption>
</figure>
<p>We can see that the <code>&lt;Navbar&gt;</code> re-rendered, which makes sense because it had to show the updated “unread notifications” badge in the tab. But, why did our <code>&lt;UserPage&gt;</code> re-render?</p>
<p>If we inspect the last couple dispatched actions in the Redux DevTools, we can see that only the notifications state updated. Since the <code>&lt;UserPage&gt;</code> doesn’t read any notifications, it shouldn’t have re-rendered. Something must be wrong with the component.</p>
<p>If we look at <code>&lt;UserPage&gt;</code> carefully, there’s a specific problem:</p>
<p>```jsx title="features/UserPage.js export const UserPage = ({ match }) =&gt; { const { userId } = match.params;</p>
<p>const user = useSelector((state) =&gt; selectUserById(state, userId));</p>
<p>// highlight-start const postsForUser = useSelector((state) =&gt; { const allPosts = selectAllPosts(state); return allPosts.filter((post) =&gt; post.user === userId); }); // highlight-end</p>
<p>// omit rendering logic }; ```</p>
<p>We know that <code>useSelector</code> will re-run every time an action is dispatched, and that it forces the component to re-render if we return a new reference value.</p>
<p>We’re calling <code>filter()</code> inside of our <code>useSelector</code> hook, so that we only return the list of posts that belong to this user. Unfortunately, <strong>this means that <code>useSelector</code> <em>always</em> returns a new array reference, and so our component will re-render after <em>every</em> action even if the posts data hasn’t changed!</strong>.</p>
<h3 id="memoizing-selector-functions">Memoizing Selector Functions</h3>
<p>What we really need is a way to only calculate the new filtered array if either <code>state.posts</code> or <code>userId</code> have changed. If they <em>haven’t</em> changed, we want to return the same filtered array reference as the last time.</p>
<p>This idea is called “memoization”. We want to save a previous set of inputs and the calculated result, and if the inputs are the same, return the previous result instead of recalculating it again.</p>
<p>So far, we’ve been writing selector functions by ourselves, and just so that we don’t have to copy and paste the code for reading data from the store. It would be great if there was a way to make our selector functions memoized.</p>
<p><strong><a href="https://github.com/reduxjs/reselect">Reselect</a> is a library for creating memoized selector functions</strong>, and was specifically designed to be used with Redux. It has a <code>createSelector</code> function that generates memoized selectors that will only recalculate results when the inputs change. Redux Toolkit <a href="https://redux-toolkit.js.org/api/createSelector">exports the <code>createSelector</code> function</a>, so we already have it available.</p>
<p>Let’s make a new <code>selectPostsByUser</code> selector function, using Reselect, and use it here.</p>
<p>```js title=“features/posts/postsSlice.js” // highlight-next-line import { createSlice, createAsyncThunk, createSelector, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>// omit slice logic</p>
<p>export const selectAllPosts = (state) =&gt; state.posts.posts;</p>
<p>export const selectPostById = (state, postId) =&gt; state.posts.posts.find((post) =&gt; post.id === postId);</p>
<p>// highlight-start export const selectPostsByUser = createSelector( [selectAllPosts, (state, userId) =&gt; userId], (posts, userId) =&gt; posts.filter((post) =&gt; post.user === userId) ); // highlight-end ```</p>
<p><code>createSelector</code> takes one or more “input selector” functions as argument, plus an “output selector” function. When we call <code>selectPostsByUser(state, userId)</code>, <code>createSelector</code> will pass all of the arguments into each of our input selectors. Whatever those input selectors return becomes the arguments for the output selector.</p>
<p>In this case, we know that we need the array of all posts and the user ID as the two arguments for our output selector. We can reuse our existing <code>selectAllPosts</code> selector to extract the posts array. Since the user ID is the second argument we’re passing into <code>selectPostsByUser</code>, we can write a small selector that just returns <code>userId</code>.</p>
<p>Our output selector then takes <code>posts</code> and <code>userId</code>, and returns the filtered array of posts for just that user.</p>
<p>If we try calling <code>selectPostsByUser</code> multiple times, it will only re-run the output selector if either <code>posts</code> or <code>userId</code> has changed:</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb324-1" title="1"><span class="kw">const</span> state1 <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb324-2" title="2"><span class="co">// Output selector runs, because it&#39;s the first call</span></a>
<a class="sourceLine" id="cb324-3" title="3"><span class="at">selectPostsByUser</span>(state1<span class="op">,</span> <span class="st">&quot;user1&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb324-4" title="4"><span class="co">// Output selector does _not_ run, because the arguments haven&#39;t changed</span></a>
<a class="sourceLine" id="cb324-5" title="5"><span class="at">selectPostsByUser</span>(state1<span class="op">,</span> <span class="st">&quot;user1&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb324-6" title="6"><span class="co">// Output selector runs, because `userId` changed</span></a>
<a class="sourceLine" id="cb324-7" title="7"><span class="at">selectPostsByUser</span>(state1<span class="op">,</span> <span class="st">&quot;user2&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb324-8" title="8"></a>
<a class="sourceLine" id="cb324-9" title="9"><span class="at">dispatch</span>(<span class="at">reactionAdded</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb324-10" title="10"><span class="kw">const</span> state2 <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb324-11" title="11"><span class="co">// Output selector does not run, because `posts` and `userId` are the same</span></a>
<a class="sourceLine" id="cb324-12" title="12"><span class="at">selectPostsByUser</span>(state2<span class="op">,</span> <span class="st">&quot;user2&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb324-13" title="13"></a>
<a class="sourceLine" id="cb324-14" title="14"><span class="co">// Add some more posts</span></a>
<a class="sourceLine" id="cb324-15" title="15"><span class="at">dispatch</span>(<span class="at">addNewPost</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb324-16" title="16"><span class="kw">const</span> state3 <span class="op">=</span> <span class="at">getState</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb324-17" title="17"><span class="co">// Output selector runs, because `posts` has changed</span></a>
<a class="sourceLine" id="cb324-18" title="18"><span class="at">selectPostsByUser</span>(state3<span class="op">,</span> <span class="st">&quot;user2&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>If we call this selector in <code>&lt;UserPage&gt;</code> and re-run the React profiler while fetching notifications, we should see that <code>&lt;UserPage&gt;</code> doesn’t re-render this time:</p>
<pre class="jsx"><code>export const UserPage = ({ match }) =&gt; {
  const { userId } = match.params;

  const user = useSelector((state) =&gt; selectUserById(state, userId));

  // highlight-start
  const postsForUser = useSelector((state) =&gt; selectPostsByUser(state, userId));
  // highlight-end

  // omit rendering logic
};</code></pre>
<p>Memoized selectors are a valuable tool for improving performance in a React+Redux application, because they can help us avoid unnecessary re-renders, and also avoid doing potentially complex or expensive calculations if the input data hasn’t changed.</p>
<div class="info">
<p>For more details on why we use selector functions and how to write memoized selectors with Reselect, see:</p>
<ul>
<li><a href="../../usage/deriving-data-selectors.md">Using Redux: Deriving Data with Selectors</a></li>
</ul>
</div>
<h3 id="investigating-the-posts-list">Investigating the Posts List</h3>
<p>If we go back to our <code>&lt;PostsList&gt;</code> and try clicking a reaction button on one of the posts while capturing a React profiler trace, we’ll see that not only did the <code>&lt;PostsList&gt;</code> and the updated <code>&lt;PostExcerpt&gt;</code> instance render, <em>all</em> of the <code>&lt;PostExcerpt&gt;</code> components rendered:</p>
<figure>
<img src="/img/tutorials/essentials/postslist-rerender.png" alt="React DevTools Profiler render capture - " /><figcaption>React DevTools Profiler render capture - <PostsList></figcaption>
</figure>
<p>Why is that? None of the other posts changed, so why would they need to re-render?</p>
<p><a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/"><strong>React’s default behavior is that when a parent component renders, React will recursively render all child components inside of it!</strong></a>. The immutable update of one post object also created a new <code>posts</code> array. Our <code>&lt;PostsList&gt;</code> had to re-render because the <code>posts</code> array was a new reference, so after it rendered, React continued downwards and re-rendered all of the <code>&lt;PostExcerpt&gt;</code> components too.</p>
<p>This isn’t a serious problem for our small example app, but in a larger real-world app, we might have some very long lists or very large component trees, and having all those extra components re-render might slow things down.</p>
<p>There’s a few different ways we could optimize this behavior in <code>&lt;PostsList&gt;</code>.</p>
<p>First, we could wrap the <code>&lt;PostExcerpt&gt;</code> component in <a href="https://reactjs.org/docs/react-api.html#reactmemo"><code>React.memo()</code></a>, which will ensure that the component inside of it only re-renders if the props have actually changed. This will actually work quite well - try it out and see what happens:</p>
<p>```jsx title="features/posts/PostsList.js // highlight-next-line let PostExcerpt = ({ post }) =&gt; { // omit logic };</p>
<p>// highlight-next-line PostExcerpt = React.memo(PostExcerpt); ```</p>
<p>Another option is to rewrite <code>&lt;PostsList&gt;</code> so that it only selects a list of post IDs from the store instead of the entire <code>posts</code> array, and rewrite <code>&lt;PostExcerpt&gt;</code> so that it receives a <code>postId</code> prop and calls <code>useSelector</code> to read the post object it needs. If <code>&lt;PostsList&gt;</code> gets the same list of IDs as before, it won’t need to re-render, and so only our one changed <code>&lt;PostExcerpt&gt;</code> component should have to render.</p>
<p>Unfortunately, this gets tricky because we also need to have all our posts sorted by date and rendered in the right order. We could update our <code>postsSlice</code> to keep the array sorted at all times, so we don’t have to sort it in the component, and use a memoized selector to extract just the list of post IDs. We could also <a href="https://react-redux.js.org/api/hooks#equality-comparisons-and-updates">customize the comparison function that <code>useSelector</code> runs to check the results</a>, like <code>useSelector(selectPostIds, shallowEqual)</code>, so that will skip re-rendering if the <em>contents</em> of the IDs array haven’t changed.</p>
<p>The last option is to find some way to have our reducer keep a separate array of IDs for all the posts, and only modify that array when posts are added or removed, and do the same rewrite of <code>&lt;PostsList&gt;</code> and <code>&lt;PostExcerpt&gt;</code>. This way, <code>&lt;PostsList&gt;</code> only needs to re-render when that IDs array changes.</p>
<p>Conveniently, Redux Toolkit has a <code>createEntityAdapter</code> function that will help us do just that.</p>
<h2 id="normalizing-data">Normalizing Data</h2>
<p>You’ve seen that a lot of our logic has been looking up items by their ID field. Since we’ve been storing our data in arrays, that means we have to loop over all the items in the array using <code>array.find()</code> until we find the item with the ID we’re looking for.</p>
<p>Realistically, this doesn’t take very long, but if we had arrays with hundreds or thousands of items inside, looking through the entire array to find one item becomes wasted effort. What we need is a way to look up a single item based on its ID, directly, without having to check all the other items. This process is known as “normalization”.</p>
<h3 id="normalized-state-structure">Normalized State Structure</h3>
<p>“Normalized state” means that:</p>
<ul>
<li>We only have one copy of each particular piece of data in our state, so there’s no duplication</li>
<li>Data that has been normalized is kept in a lookup table, where the item IDs are the keys, and the items themselves are the values.</li>
<li>There may also be an array of all of the IDs for a particular item type</li>
</ul>
<p>JavaScript objects can be used as lookup tables, similar to “maps” or “dictionaries” in other languages. Here’s what the normalized state for a group of <code>user</code> objects might look like:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb326-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb326-2" title="2">  <span class="dt">users</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb326-3" title="3">    <span class="dt">ids</span><span class="op">:</span> [<span class="st">&quot;user1&quot;</span><span class="op">,</span> <span class="st">&quot;user2&quot;</span><span class="op">,</span> <span class="st">&quot;user3&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb326-4" title="4">    <span class="dt">entities</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb326-5" title="5">      <span class="st">&quot;user1&quot;</span><span class="op">:</span> <span class="op">{</span><span class="dt">id</span><span class="op">:</span> <span class="st">&quot;user1&quot;</span><span class="op">,</span> firstName<span class="op">,</span> lastName<span class="op">},</span></a>
<a class="sourceLine" id="cb326-6" title="6">      <span class="st">&quot;user2&quot;</span><span class="op">:</span> <span class="op">{</span><span class="dt">id</span><span class="op">:</span> <span class="st">&quot;user2&quot;</span><span class="op">,</span> firstName<span class="op">,</span> lastName<span class="op">},</span></a>
<a class="sourceLine" id="cb326-7" title="7">      <span class="st">&quot;user3&quot;</span><span class="op">:</span> <span class="op">{</span><span class="dt">id</span><span class="op">:</span> <span class="st">&quot;user3&quot;</span><span class="op">,</span> firstName<span class="op">,</span> lastName<span class="op">},</span></a>
<a class="sourceLine" id="cb326-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb326-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb326-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>This makes it easy to find a particular <code>user</code> object by its ID, without having to loop through all the other user objects in an array:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb327-1" title="1"><span class="kw">const</span> userId <span class="op">=</span> <span class="st">&quot;user2&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb327-2" title="2"><span class="kw">const</span> userObject <span class="op">=</span> <span class="va">state</span>.<span class="va">users</span>.<span class="at">entities</span>[userId]<span class="op">;</span></a></code></pre></div>
<div class="info">
<p>For more details on why normalizing state is useful, see <a href="../../usage/structuring-reducers/NormalizingStateShape.md">Normalizing State Shape</a> and the Redux Toolkit Usage Guide section on <a href="https://redux-toolkit.js.org/usage/usage-guide#managing-normalized-data">Managing Normalized Data</a>.</p>
</div>
<h3 id="managing-normalized-state-with-createentityadapter">Managing Normalized State with <code>createEntityAdapter</code></h3>
<p>Redux Toolkit’s <code>createEntityAdapter</code> API provides a standardized way to store your data in a slice by taking a collection of items and putting them into the shape of <code>{ ids: [], entities: {} }</code>. Along with this predefined state shape, it generates a set of reducer functions and selectors that know how to work with that data.</p>
<p>This has several benefits:</p>
<ul>
<li>We don’t have to write the code to manage the normalization ourselves</li>
<li><code>createEntityAdapter</code>’s pre-built reducer functions handle common cases like “add all these items”, “update one item”, or “remove multiple items”</li>
<li><code>createEntityAdapter</code> can keep the ID array in a sorted order based on the contents of the items, and will only update that array if items are added / removed or the sorting order changes.</li>
</ul>
<p><code>createEntityAdapter</code> accepts an options object that may include a <code>sortComparer</code> function, which will be used to keep the item IDs array in sorted order by comparing two items (and works the same way as <code>Array.sort()</code>).</p>
<p>It returns an object that contains <a href="https://redux-toolkit.js.org/api/createEntityAdapter#crud-functions">a set of generated reducer functions for adding, updating, and removing items from an entity state object</a>. These reducer functions can either be used as a case reducer for a specific action type, or as a “mutating” utility function within another reducer in <code>createSlice</code>.</p>
<p>The adapter object also has a <code>getSelectors</code> function. You can pass in a selector that returns this particular slice of state from the Redux root state, and it will generate selectors like <code>selectAll</code> and <code>selectById</code>.</p>
<p>Finally, the adapter object has a <code>getInitialState</code> function that generates an empty <code>{ids: [], entities: {}}</code> object. You can pass in more fields to <code>getInitialState</code>, and those will be merged in.</p>
<h3 id="updating-the-posts-slice">Updating the Posts Slice</h3>
<p>With that in mind, let’s update our <code>postsSlice</code> to use <code>createEntityAdapter</code>:</p>
<p>```js title=“features/posts/postsSlice.js” import { // highlight-next-line createEntityAdapter, // omit other imports } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>// highlight-start const postsAdapter = createEntityAdapter({ sortComparer: (a, b) =&gt; b.date.localeCompare(a.date), });</p>
<p>const initialState = postsAdapter.getInitialState({ status: “idle”, error: null, }); // highlight-end</p>
<p>// omit thunks</p>
<p>const postsSlice = createSlice({ name: “posts”, initialState, reducers: { reactionAdded(state, action) { const { postId, reaction } = action.payload; // highlight-next-line const existingPost = state.entities[postId]; if (existingPost) { existingPost.reactions[reaction]++; } }, postUpdated(state, action) { const { id, title, content } = action.payload; // highlight-next-line const existingPost = state.entities[id]; if (existingPost) { existingPost.title = title; existingPost.content = content; } }, }, extraReducers(builder) { // omit other reducers</p>
<pre><code>builder
  .addCase(fetchPosts.fulfilled, (state, action) =&gt; {
    state.status = &quot;succeeded&quot;;
    // Add any fetched posts to the array
    // highlight-start
    // Use the `upsertMany` reducer as a mutating update utility
    postsAdapter.upsertMany(state, action.payload);
    // highlight-end
  })
  // highlight-start
  // Use the `addOne` reducer for the fulfilled case
  .addCase(addNewPost.fulfilled, postsAdapter.addOne);
// highlight-end</code></pre>
<p>}, });</p>
<p>export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;</p>
<p>export default postsSlice.reducer;</p>
<p>// highlight-start // Export the customized selectors for this adapter using <code>getSelectors</code> export const { selectAll: selectAllPosts, selectById: selectPostById, selectIds: selectPostIds, // Pass in a selector that returns the posts slice of state } = postsAdapter.getSelectors((state) =&gt; state.posts); // highlight-end</p>
<p>export const selectPostsByUser = createSelector( [selectAllPosts, (state, userId) =&gt; userId], (posts, userId) =&gt; posts.filter((post) =&gt; post.user === userId) ); ```</p>
<p>There’s a lot going on there! Let’s break it down.</p>
<p>First, we import <code>createEntityAdapter</code>, and call it to create our <code>postsAdapter</code> object. We know that we want to keep an array of all post IDs sorted with the newest post first, so we pass in a <code>sortComparer</code> function that will sort newer items to the front based on the <code>post.date</code> field.</p>
<p><code>getInitialState()</code> returns an empty <code>{ids: [], entities: {}}</code> normalized state object. Our <code>postsSlice</code> needs to keep the <code>status</code> and <code>error</code> fields for loading state too, so we pass those in to <code>getInitialState()</code>.</p>
<p>Now that our posts are being kept as a lookup table in <code>state.entities</code>, we can change our <code>reactionAdded</code> and <code>postUpdated</code> reducers to directly look up the right posts by their IDs, instead of having to loop over the old <code>posts</code> array.</p>
<p>When we receive the <code>fetchPosts.fulfilled</code> action, we can use the <code>postsAdapter.upsertMany</code> function to add all of the incoming posts to the state, by passing in the draft <code>state</code> and the array of posts in <code>action.payload</code>. If there’s any items in <code>action.payload</code> that already existing in our state, the <code>upsertMany</code> function will merge them together based on matching IDs.</p>
<p>When we receive the <code>addNewPost.fulfilled</code> action, we know we need to add that one new post object to our state. We can use the adapter functions as reducers directly, so we’ll pass <code>postsAdapter.addOne</code> as the reducer function to use to handle that action.</p>
<p>Finally, we can replace the old hand-written <code>selectAllPosts</code> and <code>selectPostById</code> selector functions with the ones generated by <code>postsAdapter.getSelectors</code>. Since the selectors are called with the root Redux state object, they need to know where to find our posts data in the Redux state, so we pass in a small selector that returns <code>state.posts</code>. The generated selector functions are always called <code>selectAll</code> and <code>selectById</code>, so we can use ES6 destructuring syntax to rename them as we export them and match the old selector names. We’ll also export <code>selectPostIds</code> the same way, since we want to read the list of sorted post IDs in our <code>&lt;PostsList&gt;</code> component.</p>
<h3 id="optimizing-the-posts-list">Optimizing the Posts List</h3>
<p>Now that our posts slice is using <code>createEntityAdapter</code>, we can update <code>&lt;PostsList&gt;</code> to optimize its rendering behavior.</p>
<p>We’ll update <code>&lt;PostsList&gt;</code> to read just the sorted array of post IDs, and pass <code>postId</code> to each <code>&lt;PostExcerpt&gt;</code>:</p>
<p>```jsx title=“features/posts/PostsList.js” // omit other imports</p>
<p>// highlight-start import { selectAllPosts, fetchPosts, selectPostIds, selectPostById, } from “./postsSlice”;</p>
<p>let PostExcerpt = ({ postId }) =&gt; { const post = useSelector((state) =&gt; selectPostById(state, postId)); // highlight-end // omit rendering logic };</p>
<p>export const PostsList = () =&gt; { const dispatch = useDispatch(); // highlight-next-line const orderedPostIds = useSelector(selectPostIds);</p>
<p>// omit other selections and effects</p>
if (postStatus === “loading”) { content = <Spinner text="Loading..." />; } else if (postStatus === “succeeded”) { // highlight-start content = orderedPostIds.map((postId) =&gt; ( <PostExcerpt key={postId} postId={postId} /> )); // highlight-end } else if (postStatus === “error”) { content =
<div>
{error}
</div>
<p>; }</p>
<p>// omit other rendering }; ```</p>
<p>Now, if we try clicking a reaction button on one of the posts while capturing a React component performance profile, we should see that <em>only</em> that one component re-rendered:</p>
<figure>
<img src="/img/tutorials/essentials/postslist-optimized.png" alt="React DevTools Profiler render capture - optimized " /><figcaption>React DevTools Profiler render capture - optimized <PostsList></figcaption>
</figure>
<h2 id="converting-other-slices">Converting Other Slices</h2>
<p>We’re almost done. As a final cleanup step, we’ll update our other two slices to use <code>createEntityAdapter</code> as well.</p>
<h3 id="converting-the-users-slice">Converting the Users Slice</h3>
<p>The <code>usersSlice</code> is fairly small, so we’ve only got a few things to change:</p>
<p>```js title=“features/users/usersSlice.js” import { createSlice, createAsyncThunk, // highlight-next-line createEntityAdapter, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”; import { client } from “../../api/client”;</p>
<p>// highlight-start const usersAdapter = createEntityAdapter();</p>
<p>const initialState = usersAdapter.getInitialState(); // highlight-end</p>
<p>export const fetchUsers = createAsyncThunk(“users/fetchUsers”, async () =&gt; { const response = await client.get(“/fakeApi/users”); return response.users; });</p>
<p>const usersSlice = createSlice({ name: “users”, initialState, reducers: {}, extraReducers(builder) { // highlight-next-line builder.addCase(fetchUsers.fulfilled, usersAdapter.setAll); }, });</p>
<p>export default usersSlice.reducer;</p>
<p>// highlight-start export const { selectAll: selectAllUsers, selectById: selectUserById } = usersAdapter.getSelectors((state) =&gt; state.users); // highlight-end ```</p>
<p>The only action we’re handling here always replaces the entire list of users with the array we fetched from the server. We can use <code>usersAdapter.setAll</code> to implement that instead.</p>
<p>Our <code>&lt;AddPostForm&gt;</code> is still trying to read <code>state.users</code> as an array, as is <code>&lt;PostAuthor&gt;</code>. Update them to use <code>selectAllUsers</code> and <code>selectUserById</code>, respectively.</p>
<h3 id="converting-the-notifications-slice">Converting the Notifications Slice</h3>
<p>Last but not least, we’ll update <code>notificationsSlice</code> as well:</p>
<p>```js title=“features/notifications/notificationsSlice.js” import { createSlice, createAsyncThunk, // highlight-next-line createEntityAdapter, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import { client } from “../../api/client”;</p>
<p>// highlight-start const notificationsAdapter = createEntityAdapter({ sortComparer: (a, b) =&gt; b.date.localeCompare(a.date), }); // highlight-end</p>
<p>// omit fetchNotifications thunk</p>
<p>const notificationsSlice = createSlice({ name: “notifications”, // highlight-next-line initialState: notificationsAdapter.getInitialState(), reducers: { allNotificationsRead(state, action) { // highlight-start Object.values(state.entities).forEach((notification) =&gt; { notification.read = true; }); // highlight-end }, }, extraReducers(builder) { builder.addCase(fetchNotifications.fulfilled, (state, action) =&gt; { // highlight-start Object.values(state.entities).forEach((notification) =&gt; { // Any notifications we’ve read are no longer new notification.isNew = !notification.read; }); notificationsAdapter.upsertMany(state, action.payload); // highlight-end }); }, });</p>
<p>export const { allNotificationsRead } = notificationsSlice.actions;</p>
<p>export default notificationsSlice.reducer;</p>
<p>// highlight-start export const { selectAll: selectAllNotifications } = notificationsAdapter.getSelectors((state) =&gt; state.notifications); // highlight-end ```</p>
<p>We again import <code>createEntityAdapter</code>, call it, and call <code>notificationsAdapter.getInitialState()</code> to help set up the slice.</p>
<p>Ironically, we do have a couple places in here where we need to loop over all notification objects and update them. Since those are no longer being kept in an array, we have to use <code>Object.values(state.entities)</code> to get an array of those notifications and loop over that. On the other hand, we can replace the previous fetch update logic with <code>notificationsAdapter.upsertMany</code>.</p>
<p>And with that… we’re done learning the core concepts and functionality of Redux Toolkit!</p>
<h2 id="what-youve-learned-13">What You’ve Learned</h2>
<p>We’ve built a lot of new behavior in this section. Let’s see what how the app looks with all those changes:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-4-entitySlices/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-essentials-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>Here’s what we covered in this section:</p>
<p>:::tip Summary</p>
<ul>
<li><strong>Memoized selector functions can be used to optimize performance</strong>
<ul>
<li>Redux Toolkit re-exports the <code>createSelector</code> function from Reselect, which generates memoized selectors</li>
<li>Memoized selectors will only recalculate the results if the input selectors return new values</li>
<li>Memoization can skip expensive calculations, and ensure the same result references are returned</li>
</ul></li>
<li><strong>There are multiple patterns you can use to optimize React component rendering with Redux</strong>
<ul>
<li>Avoid creating new object/array references inside of <code>useSelector</code> - those will cause unnecessary re-renders</li>
<li>Memoized selector functions can be passed to <code>useSelector</code> to optimize rendering</li>
<li><code>useSelector</code> can accept an alternate comparison function like <code>shallowEqual</code> instead of reference equality</li>
<li>Components can be wrapped in <code>React.memo()</code> to only re-render if their props change</li>
<li>List rendering can be optimized by having list parent components read just an array of item IDs, passing the IDs to list item children, and retrieving items by ID in the children</li>
</ul></li>
<li><strong>Normalized state structure is a recommended approach for storing items</strong>
<ul>
<li>“Normalization” means no duplication of data, and keeping items stored in a lookup table by item ID</li>
<li>Normalized state shape usually looks like <code>{ids: [], entities: {}}</code></li>
</ul></li>
<li><strong>Redux Toolkit’s <code>createEntityAdapter</code> API helps manage normalized data in a slice</strong>
<ul>
<li>Item IDs can be kept in sorted order by passing in a <code>sortComparer</code> option</li>
<li>The adapter object includes:
<ul>
<li><code>adapter.getInitialState</code>, which can accept additional state fields like loading state</li>
<li>Prebuilt reducers for common cases, like <code>setAll</code>, <code>addMany</code>, <code>upsertOne</code>, and <code>removeMany</code></li>
<li><code>adapter.getSelectors</code>, which generates selectors like <code>selectAll</code> and <code>selectById</code></li>
</ul></li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-12">What’s Next?</h2>
<p>There’s a couple more sections in the Redux Essentials tutorial, but this is a good spot to pause and put what you’ve learned into practice.</p>
<p>The concepts we’ve covered in this tutorial so far should be enough to get you started building your own applications using React and Redux. Now’s a great time to try working on a project yourself to solidify these concepts and see how they work in practice. If you’re not sure what kind of a project to build, see <a href="https://github.com/florinpop17/app-ideas">this list of app project ideas</a> for some inspiration.</p>
<p><strong>Redux Toolkit also includes a powerful data fetching and caching API called “RTK Query”</strong>. RTK Query is an optional addon that can completely eliminate the need to write any data fetching logic yourself. In <a href="./part-7-rtk-query-basics.md">Part 7: RTK Query Basics</a>, you’ll learn what RTK Query is, what problems it solves, and how to use it to fetch and use cached data in your application.</p>
<p>The Redux Essentials tutorial focused on “how to use Redux correctly”, rather than “how it works” or “why it works this way”. In particular, Redux Toolkit is a higher-level set of abstractions and utilities, and it’s helpful to understand what the abstractions in RTK are actually doing for you. Reading through the <a href="../fundamentals/part-1-overview.md">“Redux Fundamentals” tutorial</a> will help you understand how to write Redux code “by hand”, and why we recommend Redux Toolkit as the default way to write Redux logic.</p>
<p>The <a href="../../usage/index.md">Using Redux</a> section has information on a number of important concepts, like <a href="../../usage/structuring-reducers/StructuringReducers.md">how to structure your reducers</a>, and <a href="../../style-guide/style-guide">our Style Guide page</a> has important information on our recommended patterns and best practices.</p>
<p>If you’d like to know more about <em>why</em> Redux exists, what problems it tries to solve, and how it’s meant to be used, see Redux maintainer Mark Erikson’s posts on <a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/">The Tao of Redux, Part 1: Implementation and Intent</a> and <a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/">The Tao of Redux, Part 2: Practice and Philosophy</a>.</p>
<p>If you’re looking for help with Redux questions, come join <a href="https://www.reactiflux.com">the <code>#redux</code> channel in the Reactiflux server on Discord</a>.</p>
<p><strong>Thanks for reading through this tutorial, and we hope you enjoy building applications with Redux!</strong></p>
<hr />
<p>id: part-7-rtk-query-basics title: ‘Redux Essentials, Part 7: RTK Query Basics’ sidebar_label: ‘RTK Query Basics’ description: ‘The official Redux Essentials tutorial: learn how to use RTK Query for data fetching’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How RTK Query simplifies data fetching for Redux apps</li>
<li>How to set up RTK Query</li>
<li>How to use RTK Query for basic data fetching and update requests</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Completion of the previous sections of this tutorial to understand Redux Toolkit usage patterns</li>
</ul>
<p>:::</p>
<h2 id="introduction-13">Introduction</h2>
<p>in <a href="./part-5-async-logic.md">Part 5: Async Logic and Data Fetching</a> and <a href="./part-6-performance-normalization.md">Part 6: Performance and Normalization</a>, we saw the standard patterns used for data fetching and caching with Redux. Those patterns include using async thunks to fetch data, dispatching actions with the results, managing request loading state in the store, and normalizing the cached data to enable easier lookups and updates of individual items by ID.</p>
<p>In this section, we’ll look at how to use RTK Query, a data fetching and caching solution designed for Redux applications, and see how it simplifies the process of fetching data and using it in our components.</p>
<h2 id="rtk-query-overview">RTK Query Overview</h2>
<p><strong>RTK Query</strong> is a powerful data fetching and caching tool. It is designed to simplify common cases for loading data in a web application, <strong>eliminating the need to hand-write data fetching &amp; caching logic yourself</strong>.</p>
<p>RTK Query is <strong>an optional addon included in the Redux Toolkit package</strong>, and its functionality is built on top of the other APIs in Redux Toolkit.</p>
<h3 id="motivation">Motivation</h3>
<p>Web applications normally need to fetch data from a server in order to display it. They also usually need to make updates to that data, send those updates to the server, and keep the cached data on the client in sync with the data on the server. This is made more complicated by the need to implement other behaviors used in today’s applications:</p>
<ul>
<li>Tracking loading state in order to show UI spinners</li>
<li>Avoiding duplicate requests for the same data</li>
<li>Optimistic updates to make the UI feel faster</li>
<li>Managing cache lifetimes as the user interacts with the UI</li>
</ul>
<p>We’ve already seen how we can implement these behaviors using Redux Toolkit.</p>
<p>However, historically Redux has never included anything built in to help <em>completely</em> solve these use cases. Even when we use <code>createAsyncThunk</code> together with <code>createSlice</code>, there’s still a fair amount of manual work involved in making requests and managing loading state. We have to create the async thunk, make the actual request, pull relevant fields out of the response, add loading state fields, add handlers in <code>extraReducers</code> to handle the <code>pending/fulfilled/rejected</code> cases, and actually write the proper state updates.</p>
<p>Over the last couple years, the React community has come to realize that <strong>“data fetching and caching” is really a different set of concerns than “state management”</strong>. While you can use a state management library like Redux to cache data, the use cases are different enough that it’s worth using tools that are purpose-built for the data fetching use case.</p>
<p>RTK Query takes inspiration from other tools that have pioneered solutions for data fetching, like Apollo Client, React Query, Urql, and SWR, but adds a unique approach to its API design:</p>
<ul>
<li>The data fetching and caching logic is built on top of Redux Toolkit’s <code>createSlice</code> and <code>createAsyncThunk</code> APIs</li>
<li>Because Redux Toolkit is UI-agnostic, RTK Query’s functionality can be used with any UI layer</li>
<li>API endpoints are defined ahead of time, including how to generate query parameters from arguments and transform responses for caching</li>
<li>RTK Query can also generate React hooks that encapsulate the entire data fetching process, provide <code>data</code> and <code>isFetching</code> fields to components, and manage the lifetime of cached data as components mount and unmount</li>
<li>RTK Query provides “cache entry lifecycle” options that enable use cases like streaming cache updates via websocket messages after fetching the initial data</li>
<li>We have early working examples of code generation of API slices from OpenAPI and GraphQL schemas</li>
<li>Finally, RTK Query is completely written in TypeScript, and is designed to provide an excellent TS usage experience</li>
</ul>
<h3 id="whats-included">What’s included</h3>
<h4 id="apis">APIs</h4>
<p>RTK Query is included within the installation of the core Redux Toolkit package. It is available via either of the two entry points below:</p>
<p>```ts no-transpile import { createApi } from “<span class="citation" data-cites="reduxjs/toolkit/query">@reduxjs/toolkit/query</span>”;</p>
<p>/* React-specific entry point that automatically generates hooks corresponding to the defined endpoints */ import { createApi } from “<span class="citation" data-cites="reduxjs/toolkit/query/react">@reduxjs/toolkit/query/react</span>”; ```</p>
<p>RTK Query primarily consists of two APIs:</p>
<ul>
<li><a href="https://redux-toolkit.js.org/rtk-query/api/createApi"><code>createApi()</code></a>: The core of RTK Query’s functionality. It allows you to define a set of endpoints describe how to retrieve data from a series of endpoints, including configuration of how to fetch and transform that data. In most cases, you should use this once per app, with “one API slice per base URL” as a rule of thumb.</li>
<li><a href="https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery"><code>fetchBaseQuery()</code></a>: A small wrapper around <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch</code></a> that aims to simplify requests. Intended as the recommended <code>baseQuery</code> to be used in <code>createApi</code> for the majority of users.</li>
</ul>
<h4 id="bundle-size">Bundle Size</h4>
<p>RTK Query adds a fixed one-time amount to your app’s bundle size. Since RTK Query builds on top of Redux Toolkit and React-Redux, the added size varies depending on whether you are already using those in your app. The estimated min+gzip bundle sizes are:</p>
<ul>
<li>If you are using RTK already: ~9kb for RTK Query and ~2kb for the hooks.</li>
<li>If you are not using RTK already:
<ul>
<li>Without React: 17 kB for RTK+dependencies+RTK Query</li>
<li>With React: 19kB + React-Redux, which is a peer dependency</li>
</ul></li>
</ul>
<p>Adding additional endpoint definitions should only increase size based on the actual code inside the <code>endpoints</code> definitions, which will typically be just a few bytes.</p>
<p>The functionality included in RTK Query quickly pays for the added bundle size, and the elimination of hand-written data fetching logic should be a net improvement in size for most meaningful applications.</p>
<h3 id="thinking-in-rtk-query-caching">Thinking in RTK Query Caching</h3>
<p>Redux has always had an emphasis on predictability and explicit behavior. There’s no “magic” involved in Redux - you should be able to understand what’s happening in the application because <strong>all Redux logic follows the same basic patterns of dispatching actions and updating state via reducers</strong>. This does mean that sometimes you have to write more code to make things happen, but the tradeoff is that should be very clear what the data flow and behavior is.</p>
<p><strong>The Redux Toolkit core APIs do not change any of the basic data flow in a Redux app</strong> You’re still dispatching actions and writing reducers, just with less code than writing all of that logic by hand. <strong>RTK Query is the same way</strong>. It’s an additional level of abstraction, but <strong>internally it’s still doing the exact same steps we’ve already seen for managing async requests and their results</strong>.</p>
<p>However, when you use RTK Query, there <em>is</em> a mindset shift that happens. We’re no longer thinking about “managing state” per se. Instead, <strong>we now think about “managing <em>cached data</em>”</strong>. Rather than trying to write reducers ourselves, we’re now going to focus on defining <strong>“where is this data coming from?”, “how should this update be sent?”, “when should this cached data be re-fetched?”, and “how should the cached data be updated?”</strong>. How that data gets fetched, stored, and retrieved becomes implementation details we no longer have to worry about.</p>
<p>We’ll see how this mindset shift applies as we continue.</p>
<h2 id="setting-up-rtk-query">Setting Up RTK Query</h2>
<p>Our example application already works, but now it’s time to migrate all of the async logic over to use RTK Query. As we go through, we’ll see how to use all the major features of RTK Query, as well as how to migrate existing uses of <code>createAsyncThunk</code> and <code>createSlice</code> over to use the RTK Query APIs.</p>
<h3 id="defining-an-api-slice">Defining an API Slice</h3>
<p>Previously, we’ve defined separate “slices” for each of our different data types like Posts, Users, and Notifications. Each slice had its own reducer, defined its own actions and thunks, and cached the entries for that data type separately.</p>
<p>With RTK Query, <strong>the logic for managing cached data is centralized into a single “API slice” per application</strong>. In much the same way that you have a single Redux store per app, we now have a single slice for <em>all</em> our cached data.</p>
<p>We’ll start by defining a new <code>apiSlice.js</code> file. Since this isn’t specific to any of the other “features” we’ve already written, we’ll add a new <code>features/api/</code> folder and put <code>apiSlice.js</code> in there. Let’s fill out the API slice file, and then break down the code inside to see what it’s doing:</p>
<p>```js title=“features/api/apiSlice.js” // Import the RTK Query methods from the React-specific entry point import { createApi, fetchBaseQuery } from “<span class="citation" data-cites="reduxjs/toolkit/query/react">@reduxjs/toolkit/query/react</span>”;</p>
<p>// Define our single API slice object export const apiSlice = createApi({ // The cache reducer expects to be added at <code>state.api</code> (already default - this is optional) reducerPath: “api”, // All of our requests will have URLs starting with ‘/fakeApi’ baseQuery: fetchBaseQuery({ baseUrl: “/fakeApi” }), // The “endpoints” represent operations and requests for this server endpoints: (builder) =&gt; ({ // The <code>getPosts</code> endpoint is a “query” operation that returns data getPosts: builder.query({ // The URL for the request is ‘/fakeApi/posts’ query: () =&gt; “/posts”, }), }), });</p>
<p>// Export the auto-generated hook for the <code>getPost</code> query endpoint export const { useGetPostsQuery } = apiSlice; ```</p>
<p>RTK Query’s functionality is based on a single method, called <code>createApi</code>. All of the Redux Toolkit APIs we’ve seen so far are UI-agnostic, and could be used with <em>any</em> UI layer. The RTK Query core logic is the same way. However, RTK Query also includes a React-specific version of <code>createApi</code>, and since we’re using RTK and React together, we need to use that to take advantage of RTK’s React integration. So, we import from <code>'@reduxjs/toolkit/query/react'</code> specifically.</p>
<h4 id="api-slice-parameters">API Slice Parameters</h4>
<p>When we call <code>createApi</code>, there are two fields that are required:</p>
<ul>
<li><code>baseQuery</code>: a function that knows how to fetch data from the server. RTK Query includes <code>fetchBaseQuery</code>, a small wrapper around the standard <code>fetch()</code> function that handles typical processing of requests and responses. When we create a <code>fetchBaseQuery</code> instance, we can pass in the base URL of all future requests, as well as override behavior such as modifying request headers.</li>
<li><code>endpoints</code>: a set of operations that we’ve defined for interacting with this server. Endpoints can be <strong><em>queries</em></strong>, which return data for caching, or <strong><em>mutations</em></strong>, which send an update to the server. The endpoints are defined using a callback function that accepts a <code>builder</code> parameter and returns an object containing endpoint definitions created with <code>builder.query()</code> and <code>builder.mutation()</code>.</li>
</ul>
<p><code>createApi</code> also accepts a <code>reducerPath</code> field, which defines the expected top-level state slice field for the generated reducer. For our other slices like <code>postsSlice</code>, there’s no guarantee that it will be used to update <code>state.posts</code> - we <em>could</em> have attached the reducer anywhere in the root state, like <code>someOtherField: postsReducer</code>. Here, <code>createApi</code> expects us to tell it where the cache state will exist when we add the cache reducer to the store. If you don’t provide a <code>reducerPath</code> option, it defaults to <code>'api'</code>, so all your RTKQ cache data will be stored under <code>state.api</code>.</p>
<p>If you forget to add the reducer to the store, or attach it at a different key than what is specified in <code>reducerPath</code>, RTKQ will log an error to let you know this needs to be fixed.</p>
<h4 id="defining-endpoints">Defining Endpoints</h4>
<p>The first part of the URL for all requests is defined as <code>'/fakeApi'</code> in the <code>fetchBaseQuery</code> definition.</p>
<p>For our first step, we want to add an endpoint that will return the entire list of posts from the fake API server. We’ll include an endpoint called <code>getPosts</code>, and define it as a <strong>query endpoint</strong> using <code>builder.query()</code>. This method accepts many options for configuring how to make the request and process the response. For now, all we need to do is supply the remaining piece of the URL path by defining a <code>query</code> option, with a callback that returns the URL string: <code>() =&gt; '/posts'</code>.</p>
<p>By default, query endpoints will use a <code>GET</code> HTTP request, but you can override that by returning an object like <code>{url: '/posts', method: 'POST', body: newPost}</code> instead of just the URL string itself. You can also define several other options for the request this way, such as setting headers.</p>
<h4 id="exporting-api-slices-and-hooks">Exporting API Slices and Hooks</h4>
<p>In our earlier slice files, we just exported the action creators and the slice reducers, because those are all that’s needed in other files. With RTK Query, we typically export the entire “API slice” object itself, because it has several fields that may be useful.</p>
<p>Finally, look carefully at the last line of this file. Where’s this <code>useGetPostsQuery</code> value coming from?</p>
<p><strong>RTK Query’s React integration will automatically generate React hooks for <em>every</em> endpoint we define!</strong> Those hooks encapsulate the process of triggering a request when a component mounts, and re-rendering the component as the request is processed and data is available. We can export those hooks out of this API slice file for use in our React components.</p>
<p>The hooks are automatically named based on a standard convention:</p>
<ul>
<li><code>use</code>, the normal prefix for any React hook</li>
<li>The name of the endpoint, capitalized</li>
<li>The type of the endpoint, <code>Query</code> or <code>Mutation</code></li>
</ul>
<p>In this case, our endpoint is <code>getPosts</code> and it’s a query endpoint, so the generated hook is <code>useGetPostsQuery</code>.</p>
<h3 id="configuring-the-store-2">Configuring the Store</h3>
<p>We now need to hook up the API slice to our Redux store. We can modify the existing <code>store.js</code> file to add the API slice’s cache reducer to the state. Also, the API slice generates a custom middleware that needs to be added to the store. This middleware <em>must</em> be added as well - it manages cache lifetimes and expiration.</p>
<p>```js title=“app/store.js” import postsReducer from “../features/posts/postsSlice”; import usersReducer from “../features/users/usersSlice”; import notificationsReducer from “../features/notifications/notificationsSlice”; // highlight-next-line import { apiSlice } from “../features/api/apiSlice”;</p>
<p>export default configureStore({ reducer: { posts: postsReducer, users: usersReducer, notifications: notificationsReducer, // highlight-next-line [apiSlice.reducerPath]: apiSlice.reducer, }, // highlight-start middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat(apiSlice.middleware), // highlight-end }); ```</p>
<p>We can reuse the <code>apiSlice.reducerPath</code> field as a computed key in the <code>reducer</code> parameter, to ensure that the caching reducer is added in the right place.</p>
<p>We need to keep all of the existing standard middleware like <code>redux-thunk</code> in the store setup, and the API slice’s middleware typically goes after those. We can do that by supplying the <code>middleware</code> argument to <code>configureStore</code>, calling the provided <code>getDefaultMiddleware()</code> method, and adding <code>apiSlice.middleware</code> at the end of the returned middleware array.</p>
<h2 id="displaying-posts-with-queries">Displaying Posts with Queries</h2>
<h3 id="using-query-hooks-in-components">Using Query Hooks in Components</h3>
<p>Now that we have the API slice defined and added to the store, we can import the generated <code>useGetPostsQuery</code> hook into our <code>&lt;PostsList&gt;</code> component and use it there.</p>
<p>Currently, <code>&lt;PostsList&gt;</code> is specifically importing <code>useSelector</code>, <code>useDispatch</code>, and <code>useEffect</code>, reading posts data and loading state from the store, and dispatching the <code>fetchPosts()</code> thunk on mount to trigger the data fetch. <strong>The <code>useGetPostsQueryHook</code> replaces all of that!</strong></p>
<p>Let’s see how <code>&lt;PostsList&gt;</code> looks when we use this hook:</p>
<p>```jsx title=“features/posts/PostsList.js” import React from “react”; import { Link } from “react-router-dom”;</p>
<p>import { Spinner } from “../../components/Spinner”; import { PostAuthor } from “./PostAuthor”; import { TimeAgo } from “./TimeAgo”; import { ReactionButtons } from “./ReactionButtons”;</p>
<p>// highlight-next-line import { useGetPostsQuery } from “../api/apiSlice”;</p>
// highlight-next-line let PostExcerpt = ({ post }) =&gt; { return (
<article className="post-excerpt" key={post.id}>
<h3>
{post.title}
</h3>
<div>
<pre><code>    &lt;PostAuthor userId={post.user} /&gt;
    &lt;TimeAgo timestamp={post.date} /&gt;
  &lt;/div&gt;
  &lt;p className=&quot;post-content&quot;&gt;{post.content.substring(0, 100)}&lt;/p&gt;

  &lt;ReactionButtons post={post} /&gt;
  &lt;Link to={`/posts/${post.id}`} className=&quot;button muted-button&quot;&gt;
    View Post
  &lt;/Link&gt;
&lt;/article&gt;</code></pre>
<p>); };</p>
<p>export const PostsList = () =&gt; { // highlight-start const { data: posts, isLoading, isSuccess, isError, error, } = useGetPostsQuery(); // highlight-end</p>
<p>let content;</p>
// highlight-next-line if (isLoading) { content = <Spinner text="Loading..." />; // highlight-next-line } else if (isSuccess) { content = posts.map((post) =&gt; <PostExcerpt key={post.id} post={post} />); // highlight-next-line } else if (isError) { content =
<div>
{error.toString()}
</div>
<p>; }</p>
return (
<section className="posts-list">
<h2>
Posts
</h2>
{content}
</section>
<p>); }; ```</p>
<p>Conceptually, <code>&lt;PostsList&gt;</code> is still doing all the same work it was before, but we were able to replace the multiple <code>useSelector</code> calls and the <code>useEffect</code> dispatch with a single call to <code>useGetPostsQuery()</code>.</p>
<p>Each generated query hook returns a “result” object containing several fields, including:</p>
<ul>
<li><code>data</code>: the actual response contents from the server. <strong>This field will be <code>undefined</code> until the response is received</strong>.</li>
<li><code>isLoading</code>: a boolean indicating if this hook is currently making the <em>first</em> request to the server. (Note that if the parameters change to request different data, <code>isLoading</code> will remain false.)</li>
<li><code>isFetching</code>: a boolean indicating if the hook is currently making <em>any</em> request to the server</li>
<li><code>isSuccess</code>: a boolean indicating if the hook has made a successful request and has cached data available (ie, <code>data</code> should be defined now)</li>
<li><code>isError</code>: a boolean indicating if the last request had an error</li>
<li><code>error</code>: a serialized error object</li>
</ul>
<p>It’s common to destructure fields from the result object, and possibly rename <code>data</code> to a more specific variable like <code>posts</code> to describe what it contains. We can then use the status booleans and the <code>data/error</code> fields to render the UI that we want. However, if you’re using TypeScript, you may need to keep the original object as-is and refer to flags as <code>result.isSuccess</code> in your conditional checks, so that TS can correctly infer that <code>data</code> is valid.</p>
<p>Previously, we were selecting a list of post IDs from the store, passing a post ID to each <code>&lt;PostExcerpt&gt;</code> component, and selecting each individual <code>Post</code> object from the store separately. Since the <code>posts</code> array already has all of the post objects, we’ve switched back to passing the post objects themselves down as props.</p>
<h3 id="sorting-posts">Sorting Posts</h3>
<p>Unfortunately, the posts are now being displayed out of order. Previously, we were sorting them by date at the reducer level with <code>createEntityAdapter</code>’s sorting option. Since the API slice is just caching the exact array returned from the server, there’s no specific sorting happening - whatever order the server sent back is what we’ve got.</p>
<p>There’s a few different options for how to handle this. For now, we’ll do the sorting inside of <code>&lt;PostsList&gt;</code> itself, and we’ll talk about the other options and their tradeoffs later.</p>
<p>We can’t just call <code>posts.sort()</code> directly, because <code>Array.sort()</code> mutates the existing array, so we’ll need to make a copy of it first. To avoid re-sorting on every rerender, we can do the sorting in a <code>useMemo()</code> hook. We’ll also want to give <code>posts</code> a default empty array in case it’s <code>undefined</code>, so that we always have an array to sort on.</p>
<p>```jsx title=“features/posts/PostsList.js” // omit setup</p>
<p>export const PostsList = () =&gt; { const { // highlight-next-line data: posts = [], isLoading, isSuccess, isError, error, } = useGetPostsQuery();</p>
<p>// highlight-start const sortedPosts = useMemo(() =&gt; { const sortedPosts = posts.slice(); // Sort posts in descending chronological order sortedPosts.sort((a, b) =&gt; b.date.localeCompare(a.date)); return sortedPosts; }, [posts]); // highlight-end</p>
<p>let content;</p>
if (isLoading) { content = <Spinner text="Loading..." />; } else if (isSuccess) { // highlight-next-line content = sortedPosts.map((post) =&gt; ( <PostExcerpt key={post.id} post={post} /> )); } else if (isError) { content =
<div>
{error.toString()}
</div>
<p>; }</p>
return (
<section className="posts-list">
<h2>
Posts
</h2>
{content}
</section>
<p>); }; ```</p>
<h2 id="displaying-individual-posts">Displaying Individual Posts</h2>
<p>We’ve updated <code>&lt;PostsList&gt;</code> to fetch a list of <em>all</em> posts, and we’re showing pieces of each <code>Post</code> inside the list. But, if we click on “View Post” for any of them, our <code>&lt;SinglePostPage&gt;</code> component will fail to find a post in the old <code>state.posts</code> slice and show us a “Post not found!” error. We need to update <code>&lt;SinglePostPage&gt;</code> to use RTK Query as well.</p>
<p>There’s a couple ways we could do this. One would be to have <code>&lt;SinglePostPage&gt;</code> call the same <code>useGetPostsQuery()</code> hook, get the <em>entire</em> array of posts, and find just the one <code>Post</code> object it needs to display. Query hooks also have a <code>selectFromResult</code> option that would allow us to do that same lookup earlier, inside the hook itself - we’ll see this in action later.</p>
<p>Instead, we’re going to try adding another endpoint definition that will let us request a single post from the server based on its ID. This is somewhat redundant, but it will allow us to see how RTK Query can be used to customize query requests based on arguments.</p>
<h3 id="adding-the-single-post-query-endpoint">Adding the Single Post Query Endpoint</h3>
<p>In <code>apiSlice.js</code>, we’re going to add another query endpoint definition, called <code>getPost</code> (no ‘s’ this time):</p>
<p>``<code>js title="features/api/apiSlice.js" export const apiSlice = createApi({   reducerPath: "api",   baseQuery: fetchBaseQuery({ baseUrl: "/fakeApi" }),   endpoints: (builder) =&gt; ({     getPosts: builder.query({       query: () =&gt; "/posts",     }),     // highlight-start     getPost: builder.query({       query: (postId) =&gt;</code>/posts/${postId}`, }), // highlight-end }), });</p>
<p>// highlight-next-line export const { useGetPostsQuery, useGetPostQuery } = apiSlice; ```</p>
<p>The <code>getPost</code> endpoint looks much like the existing <code>getPosts</code> endpoint, but the <code>query</code> parameter is different. Here, <code>query</code> takes an argument called <code>postId</code>, and we’re using that <code>postId</code> to construct the server URL. That way we can make a server request for just one specific <code>Post</code> object.</p>
<p>This also generates a new <code>useGetPostQuery</code> hook, so we export that as well.</p>
<h3 id="query-arguments-and-cache-keys">Query Arguments and Cache Keys</h3>
<p>Our <code>&lt;SinglePostPage&gt;</code> is currently reading one <code>Post</code> entry from <code>state.posts</code> based on ID. We need to update it to call the new <code>useGetPostQuery</code> hook, and use similar loading state as the main list.</p>
<p>```jsx title=“features/posts/SinglePostPage.js” import React from “react”; import { Link } from “react-router-dom”;</p>
<p>// highlight-start import { Spinner } from “../../components/Spinner”; import { useGetPostQuery } from “../api/apiSlice”; // highlight-end</p>
<p>import { PostAuthor } from “./PostAuthor”; import { TimeAgo } from “./TimeAgo”; import { ReactionButtons } from “./ReactionButtons”;</p>
<p>export const SinglePostPage = ({ match }) =&gt; { const { postId } = match.params;</p>
<p>// highlight-next-line const { data: post, isFetching, isSuccess } = useGetPostQuery(postId);</p>
let content; // highlight-start if (isFetching) { content = <Spinner text="Loading..." />; } else if (isSuccess) { // highlight-end content = (
<article className="post">
<h2>
{post.title}
</h2>
<div>
<pre><code>      &lt;PostAuthor userId={post.user} /&gt;
      &lt;TimeAgo timestamp={post.date} /&gt;
    &lt;/div&gt;
    &lt;p className=&quot;post-content&quot;&gt;{post.content}&lt;/p&gt;
    &lt;ReactionButtons post={post} /&gt;
    &lt;Link to={`/editPost/${post.id}`} className=&quot;button&quot;&gt;
      Edit Post
    &lt;/Link&gt;
  &lt;/article&gt;
);</code></pre>
<p>}</p>
return
<section>
{content}
</section>
<p>; }; ```</p>
<p>Notice that we’re taking the <code>postId</code> we’ve read from the router match, and passing it as an argument to <code>useGetPostQuery</code>. The query hook will then use that to construct the request URL, and fetch this specific <code>Post</code> object.</p>
<p>So how is all this data being cached, anyway? Let’s click “View Post” for one of our post entries, then take a look at what’s inside the Redux store at this point.</p>
<figure>
<img src="/img/tutorials/essentials/devtools-rtkq-cache.png" alt="RTK Query data cached in the store state" /><figcaption>RTK Query data cached in the store state</figcaption>
</figure>
<p>We can see that we have a top-level <code>state.api</code> slice, as expected from the store setup. Inside of there is a section called <code>queries</code>, and it currently has two items. The key <code>getPosts(undefined)</code> represents the metadata and response contents for the request we made with the <code>getPosts</code> endpoint. Similarly, the key <code>getPost('abcd1234')</code> is for the specific request we just made for this one post.</p>
<p>RTK Query creates a “cache key” for each unique endpoint + argument combination, and stores the results for each cache key separately. That means that <strong>you can use the same query hook multiple times, pass it different query parameters, and each result will be cached separately in the Redux store</strong>.</p>
<p>It’s also important to note that <strong>the query parameter must be a <em>single</em> value!</strong> If you need to pass through multiple parameters, you must pass an object containing multiple fields (exactly the same as with <code>createAsyncThunk</code>). RTK Query will do a “shallow stable” comparison of the fields, and re-fetch the data if any of them have changed.</p>
<p>Notice that the names of the actions in the left-hand list are much more generic and less descriptive: <code>api/executeQuery/fulfilled</code>, instead of <code>posts/fetchPosts/fulfilled</code>. This is a tradeoff of using an additional abstraction layer. The individual actions do contain the specific endpoint name under <code>action.meta.arg.endpointName</code>, but it’s not as easily viewable in the action history list.</p>
<div class="tip">
<p>The Redux team is working on a new RTK Query view for the Redux DevTools that will specifically show RTK Query data in a more usable format. This includes info on each endpoint and cache result, stats on query timing, and much more. This will be added to the DevTools Extension in the near future. For a preview, see:</p>
<ul>
<li><a href="https://github.com/reduxjs/redux-devtools/pull/750">Redux DevTools #750: Add RTK Query-Inspector monitor</a></li>
<li><a href="https://rtk-query-monitor-demo.netlify.app/">RTK Query Monitor preview demo</a></li>
</ul>
</div>
<h2 id="creating-posts-with-mutations">Creating Posts with Mutations</h2>
<p>We’ve seen how we can fetch data from the server by defining “query” endpoints, but what about sending updates to the server?</p>
<p>RTK Query lets us define <strong>mutation endpoints</strong> that update data on the server. Let’s add a mutation that will let us add a new post.</p>
<h3 id="adding-the-new-post-mutation-endpoint">Adding the New Post Mutation Endpoint</h3>
<p>Adding a mutation endpoint is very similar to adding a query endpoint. The biggest difference is that we define the endpoint using <code>builder.mutation()</code> instead of <code>builder.query()</code>. Also, we now need to change the HTTP method to be a <code>'POST'</code> request, and we have to provide the body of the request as well.</p>
<p>``<code>js title="features/api/apiSlice.js" export const apiSlice = createApi({   reducerPath: "api",   baseQuery: fetchBaseQuery({ baseUrl: "/fakeApi" }),   endpoints: (builder) =&gt; ({     getPosts: builder.query({       query: () =&gt; "/posts",     }),     getPost: builder.query({       query: (postId) =&gt;</code>/posts/${postId}`, }), // highlight-start addNewPost: builder.mutation({ query: (initialPost) =&gt; ({ url: “/posts”, method: “POST”, // Include the entire post object as the body of the request body: initialPost, }), }), // highlight-end }), });</p>
<p>export const { useGetPostsQuery, useGetPostQuery, // highlight-next-line useAddNewPostMutation, } = apiSlice; ```</p>
<p>Here our <code>query</code> option returns an object containing <code>{url, method, body}</code>. Since we’re using <code>fetchBaseQuery</code> to make the requests, the <code>body</code> field will automatically be JSON-serialized for us.</p>
<p>Like with query endpoints, the API slice automatically generates a React hook for the mutation endpoint - in this case, <code>useAddNewPostMutation</code>.</p>
<h3 id="using-mutation-hooks-in-components">Using Mutation Hooks in Components</h3>
<p>Our <code>&lt;AddNewPostForm&gt;</code> is already dispatching an async thunk to add a post whenever we click the “Save Post” button. To do that, it has to import <code>useDispatch</code> and the <code>addNewPost</code> thunk. The mutation hooks replace both of those, and the usage pattern is very similar.</p>
<p>```js title=“features/posts/AddNewPostForm” import React, { useState } from “react”; import { useSelector } from “react-redux”;</p>
<p>import { Spinner } from “../../components/Spinner”; import { useAddNewPostMutation } from “../api/apiSlice”; import { selectAllUsers } from “../users/usersSlice”;</p>
<p>export const AddPostForm = () =&gt; { const [title, setTitle] = useState("“); const [content, setContent] = useState(”“); const [userId, setUserId] = useState(”");</p>
<p>// highlight-next-line const [addNewPost, { isLoading }] = useAddNewPostMutation(); const users = useSelector(selectAllUsers);</p>
<p>const onTitleChanged = (e) =&gt; setTitle(e.target.value); const onContentChanged = (e) =&gt; setContent(e.target.value); const onAuthorChanged = (e) =&gt; setUserId(e.target.value);</p>
<p>// highlight-next-line const canSave = [title, content, userId].every(Boolean) &amp;&amp; !isLoading;</p>
<p>const onSavePostClicked = async () =&gt; { if (canSave) { try { // highlight-next-line await addNewPost({ title, content, user: userId }).unwrap(); setTitle("“); setContent(”“); setUserId(”“); } catch (err) { console.error(”Failed to save the post: ", err); } } };</p>
<p>// omit rendering logic }; ```</p>
<p>Mutation hooks return an array with two values:</p>
<ul>
<li>The first value is a “trigger function”. When called, it makes the request to the server, with whatever argument you provide. This is effectively like a thunk that has already been wrapped to immediately dispatch itself.</li>
<li>The second value is an object with metadata about the current in-progress request, if any. This includes an <code>isLoading</code> flag to indicate if a request is in-progress.</li>
</ul>
<p>We can replace the existing thunk dispatch and component loading state with the trigger function and <code>isLoading</code> flag from the <code>useAddNewPostMutation</code> hook, and the rest of the component stays the same.</p>
<p>As with the thunk dispatch, we call <code>addNewPost</code> with the initial post object. This returns a special <code>Promise</code> with a <code>.unwrap()</code> method, and we can <code>await addNewPost().unwrap()</code> to handle any potential errors with a standard <code>try/catch</code> block.</p>
<h2 id="refreshing-cached-data">Refreshing Cached Data</h2>
<p>When we click “Save Post”, we can view the Network tab in the browser DevTools and confirm that the HTTP <code>POST</code> request succeeded. But, the new post isn’t showing up in our <code>&lt;PostsList&gt;</code> if we go back there. We still have the same cached data in memory.</p>
<p>We need to tell RTK Query to refresh its cached list of posts so that we can see the new post we just added.</p>
<h3 id="refetching-posts-manually">Refetching Posts Manually</h3>
<p>The first option is to manually force RTK Query to refetch data for a given endpoint. Query hook result objects include a <code>refetch</code> function that we can call to force a refetch. We can temporarily add a “Refetch Posts” button to <code>&lt;PostsList&gt;</code> and click that after adding a new post.</p>
<p>Also, earlier we saw that query hooks have both an <code>isLoading</code> flag, which is <code>true</code> if this is the <em>first</em> request for data, and an <code>isFetching</code> flag, which is <code>true</code> while <em>any</em> request for data is in progress. We could look at the <code>isFetching</code> flag, and replace the entire list of posts with a loading spinner again while the refetch is in progress. But, that could be a bit annoying, and besides - we already have all these posts, why should we completely hide them?</p>
<p>Instead, we could make the existing list of posts partially transparent to indicate the data is stale, but keep them visible while the refetch is happening. As soon as the request completes, we can return to showing the posts list as normal.</p>
<p>```jsx title=“features/posts/PostsList.js” import React, { useMemo } from “react”; import { Link } from “react-router-dom”; // highlight-next-line import classnames from “classnames”;</p>
<p>// omit other imports and PostExcerpt</p>
<p>export const PostsList = () =&gt; { const { data: posts = [], isLoading, isFetching, isSuccess, isError, error, // highlight-next-line refetch, } = useGetPostsQuery();</p>
<p>const sortedPosts = useMemo(() =&gt; { const sortedPosts = posts.slice(); sortedPosts.sort((a, b) =&gt; b.date.localeCompare(a.date)); return sortedPosts; }, [posts]);</p>
<p>let content;</p>
<p>if (isLoading) { content = <Spinner text="Loading..." />; } else if (isSuccess) { // highlight-start const renderedPosts = sortedPosts.map((post) =&gt; ( <PostExcerpt key={post.id} post={post} /> ));</p>
<pre><code>const containerClassname = classnames(&quot;posts-container&quot;, {
  disabled: isFetching,
});

content = &lt;div className={containerClassname}&gt;{renderedPosts}&lt;/div&gt;;
// highlight-end</code></pre>
} else if (isError) { content =
<div>
{error.toString()}
</div>
<p>; }</p>
return (
<section className="posts-list">
<h2>
Posts
</h2>
// highlight-next-line <button onClick={refetch}>Refetch Posts</button> {content}
</section>
<p>); }; ```</p>
<p>If we add a new post and then click “Refetch Posts”, we should now see the posts list go semi-transparent for a couple seconds, then re-render with the new post added at the top.</p>
<h3 id="automatic-refreshing-with-cache-invalidation">Automatic Refreshing with Cache Invalidation</h3>
<p>Having users manually click to refetch data is occasionally necessary, but definitely not a good solution for normal usage.</p>
<p>We know that our “server” has a complete list of all posts, including the one we just added. Ideally, we want to have our app automatically refetch the updated list of posts as soon as the mutation request has completed. That way we know our client-side cached data is in sync with what the server has.</p>
<p><strong>RTK Query lets us define relationships between queries and mutations to enable automatic data refetching, using “tags”</strong>. A “tag” is a string or small object that lets you name certain types of data, and <em>invalidate</em> portions of the cache. When a cache tag is invalidated, RTK Query will automatically refetch the endpoints that were marked with that tag.</p>
<p>Basic tag usage requires adding three pieces of information to our API slice:</p>
<ul>
<li>A root <code>tagTypes</code> field in the API slice object, declaring an array of string tag names for data types such as <code>'Post'</code></li>
<li>A <code>providesTags</code> array in query endpoints, listing a set of tags describing the data in that query</li>
<li>An <code>invalidatesTags</code> array in mutation endpoints, listing a set of tags that are invalidated every time that mutation runs</li>
</ul>
<p>We can add a single tag called <code>'Post'</code> to our API slice that will let us automatically refetch our <code>getPosts</code> endpoint any time we add a new post:</p>
<p><code>js title="features/api/apiSlice.js" export const apiSlice = createApi({   reducerPath: "api",   baseQuery: fetchBaseQuery({ baseUrl: "/fakeApi" }),   // highlight-next-line   tagTypes: ["Post"],   endpoints: (builder) =&gt; ({     getPosts: builder.query({       query: () =&gt; "/posts",       // highlight-next-line       providesTags: ["Post"],     }),     getPost: builder.query({       query: (postId) =&gt; `/posts/${postId}`,     }),     addNewPost: builder.mutation({       query: (initialPost) =&gt; ({         url: "/posts",         method: "POST",         body: initialPost,       }),       // highlight-next-line       invalidatesTags: ["Post"],     }),   }), });</code></p>
<p>That’s all we need! Now, if we click “Save Post”, you should see the <code>&lt;PostsList&gt;</code> component automatically gray out after a couple seconds, and then rerender with the newly added post at the top.</p>
<p>Note that there’s nothing special about the literal string <code>'Post'</code> here. We could have called it <code>'Fred'</code>, <code>'qwerty'</code>, or anything else. It just needs to be the same string in each field, so that RTK Query knows “when this mutation happens, invalidate all endpoints that have that same tag string listed”.</p>
<h2 id="what-youve-learned-14">What You’ve Learned</h2>
<p>With RTK Query, the actual details of how to manage data fetching, caching, and loading state are abstracted away. This simplifies application code considerably, and lets us focus on higher-level concerns about intended app behavior instead. Since RTK Query is implemented using the same Redux Toolkit APIs we’ve already seen, we can still use the Redux DevTools to view the changes in our state over time.</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-5-createApi/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-essentials-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>:::tip Summary</p>
<ul>
<li><strong>RTK Query is a data fetching and caching solution included in Redux Toolkit</strong>
<ul>
<li>RTK Query abstracts the process of managing cached server data for you, and eliminates the need to write logic for loading state, storing results, and making requests</li>
<li>RTK Query builds on top of the same patterns used in Redux, like async thunks</li>
</ul></li>
<li><strong>RTK Query uses a single “API slice” per application, defined using <code>createApi</code></strong>
<ul>
<li>RTK Query provides UI-agnostic and React-specific versions of <code>createApi</code></li>
<li>API slices define multiple “endpoints” for different server operations</li>
<li>The API slice includes auto-generated React hooks if using the React integration</li>
</ul></li>
<li><strong>Query endpoints allow fetching and caching data from the server</strong>
<ul>
<li>Query hooks return a <code>data</code> value, plus loading status flags</li>
<li>The query can be re-fetched manually, or automatically using “tags” for cache invalidation</li>
</ul></li>
<li><strong>Mutation endpoints allow updating data on the server</strong>
<ul>
<li>Mutation hooks return a “trigger” function that sends an update request, plus loading status</li>
<li>The trigger function returns a Promise that can be “unwrapped” and awaited</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-13">What’s Next?</h2>
<p>RTK Query provides solid default behavior, but also includes many options for customizing how requests are managed and working with cached data. In <a href="./part-8-rtk-query-advanced.md">Part 8: RTK Query Advanced Patterns</a>, we’ll see how to use these options to implement useful features like optimistic updates.</p>
<hr />
<p>id: part-8-rtk-query-advanced title: ‘Redux Essentials, Part 8: RTK Query Advanced Patterns’ sidebar_label: ‘RTK Query Advanced Patterns’ description: ‘The official Redux Essentials tutorial: learn advanced patterns for fetching data with RTK Query’</p>
<hr />
<p>import { DetailedExplanation } from ‘../../components/DetailedExplanation’</p>
<p>:::tip What You’ll Learn</p>
<ul>
<li>How to use tags with IDs to manage cache invalidation and refetching</li>
<li>How to work with the RTK Query cache outside of React</li>
<li>Techniques for manipulating response data</li>
<li>Implementing optimistic updates and streaming updates</li>
</ul>
<p>:::</p>
<p>:::info Prerequisites</p>
<ul>
<li>Completion of <a href="./part-7-rtk-query-basics.md">Part 7</a> to understand RTK Query setup and basic usage</li>
</ul>
<p>:::</p>
<h2 id="introduction-14">Introduction</h2>
<p>In <a href="./part-7-rtk-query-basics.md">Part 7: RTK Query Basics</a>, we saw how to set up and use the RTK Query API to handle data fetching and caching in our application. We added an “API slice” to our Redux store, defined “query” endpoints to fetch posts data, and a “mutation” endpoint to add a new post.</p>
<p>In this section, we’ll continue migrating our example app to use RTK Query for the other data types, and see how to use some of its advanced features to simplify the codebase and improve user experience.</p>
<div class="info">
<p>Some of the changes in this section aren’t strictly necessary - they’re included to demonstrate RTK Query’s features and show some of the things you <em>can</em> do, so you can see how to use these features if you need them.</p>
</div>
<h2 id="editing-posts-1">Editing Posts</h2>
<p>We’ve already added a mutation endpoint to save new Post entries to the server, and used that in our <code>&lt;AddNewPostForm&gt;</code>. Next, we need to handle updating the <code>&lt;EditPostForm&gt;</code> to let us edit an existing post.</p>
<h3 id="updating-the-edit-post-form">Updating the Edit Post Form</h3>
<p>As with adding posts, the first step is to define a new mutation endpoint in our API slice. This will look much like the mutation for adding a post, but the endpoint needs to include the post ID in the URL and use an HTTP <code>PATCH</code> request to indicate that it’s updating some of the fields.</p>
<p>``<code>js title="features/api/apiSlice.js" export const apiSlice = createApi({   reducerPath: "api",   baseQuery: fetchBaseQuery({ baseUrl: "/fakeApi" }),   tagTypes: ["Post"],   endpoints: (builder) =&gt; ({     getPosts: builder.query({       query: () =&gt; "/posts",       providesTags: ["Post"],     }),     getPost: builder.query({       query: (postId) =&gt;</code>/posts/<span class="math inline">${postId}`,  }),  addNewPost: builder.mutation({  query: (initialPost) =&gt; ({  url: "/posts",  method: "POST",  body: initialPost,  }),  invalidatesTags: ["Post"],  }),  // highlight-start  editPost: builder.mutation({  query: (post) =&gt; ({  url: `/posts/$</span>{post.id}`, method: “PATCH”, body: post, }), }), // highlight-end }), });</p>
<p>export const { useGetPostsQuery, useGetPostQuery, useAddNewPostMutation, // highlight-next-line useEditPostMutation, } = apiSlice; ```</p>
<p>Once that’s added, we can update the <code>&lt;EditPostForm&gt;</code>. It needs to read the original <code>Post</code> entry from the store, use that to initialize the component state to edit the fields, and then send the updated changes to the server. Currently, we’re reading the <code>Post</code> entry with <code>selectPostById</code>, and manually dispatching a <code>postUpdated</code> thunk for the request.</p>
<p>We can use the same <code>useGetPostQuery</code> hook that we used in <code>&lt;SinglePostPage&gt;</code> to read the <code>Post</code> entry from the cache in the store, and we’ll use the new <code>useEditPostMutation</code> hook to handle saving the changes.</p>
<p>```jsx title=“features/posts/EditPostForm.js” import React, { useState } from “react”; import { useHistory } from “react-router-dom”;</p>
<p>import { Spinner } from “../../components/Spinner”; // highlight-next-line import { useGetPostQuery, useEditPostMutation } from “../api/apiSlice”;</p>
<p>export const EditPostForm = ({ match }) =&gt; { const { postId } = match.params;</p>
<p>// highlight-next-line const { data: post } = useGetPostQuery(postId); // highlight-next-line const [updatePost, { isLoading }] = useEditPostMutation();</p>
<p>const [title, setTitle] = useState(post.title); const [content, setContent] = useState(post.content);</p>
<p>const history = useHistory();</p>
<p>const onTitleChanged = (e) =&gt; setTitle(e.target.value); const onContentChanged = (e) =&gt; setContent(e.target.value);</p>
<p>const onSavePostClicked = async () =&gt; { if (title &amp;&amp; content) { // highlight-next-line await updatePost({ id: postId, title, content }); history.push(<code>/posts/${postId}</code>); } };</p>
<p>// omit rendering logic }; ```</p>
<h3 id="cache-data-subscription-lifetimes">Cache Data Subscription Lifetimes</h3>
<p>Let’s try this out and see what happens. Open up your browser’s DevTools, go to the Network tab, and refresh the main page. You should see a <code>GET</code> request to <code>/posts</code> as we fetch the initial data. When you click on a “View Post” button, you should see a second request to <code>/posts/:postId</code> that returns that single post entry.</p>
<p>Now click “Edit Post” inside the single post page. The UI switches over to show <code>&lt;EditPostForm&gt;</code>, but this time there’s no network request for the individual post. Why not?</p>
<figure>
<img src="/img/tutorials/essentials/devtools-cached-requests.png" alt="RTK Query network requests" /><figcaption>RTK Query network requests</figcaption>
</figure>
<p><strong>RTK Query allows multiple components to subscribe to the same data, and will ensure that each unique set of data is only fetched once.</strong> Internally, RTK Query keeps a reference counter of active “subscriptions” to each endpoint + cache key combination. If Component A calls <code>useGetPostQuery(42)</code>, that data will be fetched. If Component B then mounts and also calls <code>useGetPostQuery(42)</code>, it’s the exact same data being requested. The two hook usages will return the exact same results, including fetched <code>data</code> and loading status flags.</p>
<p>When the number of active subscriptions goes down to 0, RTK Query starts an internal timer. <strong>If the timer expires before any new subscriptions for the data are added, RTK Query will remove that data from the cache automatically</strong>, because the app no longer needs the data. However, if a new subscription <em>is</em> added before the timer expires, the timer is canceled, and the already-cached data is used without needing to refetch it.</p>
<p>In this case, our <code>&lt;SinglePostPage&gt;</code> mounted and requested that individual <code>Post</code> by ID. When we clicked on “Edit Post”, the <code>&lt;SinglePostPage&gt;</code> component was unmounted by the router, and the active subscription was removed due to unmounting. RTK Query immediately started a “remove this post data” timer. But, the <code>&lt;EditPostPage&gt;</code> component mounted right away and subscribed to the same <code>Post</code> data with the same cache key. So, RTK Query canceled the timer and kept using the same cached data instead of fetching it from the server.</p>
<p>By default, <strong>unused data is removed from the cache after 60 seconds</strong>, but this can be configured in either the root API slice definition or overridden in the individual endpoint definitions using the <code>keepUnusedDataFor</code> flag, which specifies a cache lifetime in seconds.</p>
<h3 id="invalidating-specific-items">Invalidating Specific Items</h3>
<p>Our <code>&lt;EditPostForm&gt;</code> component can now save the edited post to the server, but we have a problem. If we click “Save Post” while editing, it returns us to the <code>&lt;SinglePostPage&gt;</code>, but it’s still showing the old data without the edits. The <code>&lt;SinglePostPage&gt;</code> is still using the cached <code>Post</code> entry that was fetched earlier. For that matter, if we return to the main page and look at the <code>&lt;PostsList&gt;</code>, it’s also showing the old data. <strong>We need a way to force a refetch of <em>both</em> the individual <code>Post</code> entry, and the entire list of posts</strong>.</p>
<p>Earlier, we saw how we can use “tags” to invalidate parts of our cached data. We declared that the <code>getPosts</code> query endpoint <em>provides</em> a <code>'Post'</code> tag, and that the <code>addNewPost</code> mutation endpoint <em>invalidates</em> that same <code>'Post'</code> tag. That way, every time we add a new post, we force RTK Query to refetch the entire list of posts from the <code>getQuery</code> endpoint.</p>
<p>We could add a <code>'Post'</code> tag to both the <code>getPost</code> query and the <code>editPost</code> mutation, but that would force all the other individual posts to be refetched as well. Fortunately, <strong>RTK Query lets us define specific tags, which let us be more selective in invalidating data</strong>. These specific tags look like <code>{type: 'Post', id: 123}</code>.</p>
<p>Our <code>getPosts</code> query defines a <code>providesTags</code> field that is an array of strings. The <code>providesTags</code> field can also accept a callback function that receives the <code>result</code> and <code>arg</code>, and returns an array. This allows us to create tag entries based on IDs of data that is being fetched. Similarly, <code>invalidatesTags</code> can be a callback as well.</p>
<p>In order to get the right behavior, we need to set up each endpoint with the right tags:</p>
<ul>
<li><code>getPosts</code>: provides a general <code>'Post'</code> tag for the whole list, as well as a specific <code>{type: 'Post', id}</code> tag for each received post object</li>
<li><code>getPost</code>: provides a specific <code>{type: 'Post', id}</code> object for the individual post object</li>
<li><code>addNewPost</code>: invalidates the general <code>'Post'</code> tag, to refetch the whole list</li>
<li><code>editPost</code>: invalidates the specific <code>{type: 'Post', id}</code> tag. This will force a refetch of both the <em>individual</em> post from <code>getPost</code>, as well as the <em>entire</em> list of posts from <code>getPosts</code>, because they both provide a tag that matches that <code>{type, id}</code> value.</li>
</ul>
<p><code>js title="features/api/apiSlice.js" export const apiSlice = createApi({   reducerPath: "api",   baseQuery: fetchBaseQuery({ baseUrl: "/fakeApi" }),   tagTypes: ["Post"],   endpoints: (builder) =&gt; ({     getPosts: builder.query({       query: () =&gt; "/posts",       // highlight-start       providesTags: (result = [], error, arg) =&gt; [         "Post",         ...result.map(({ id }) =&gt; ({ type: "Post", id })),       ],       // highlight-end     }),     getPost: builder.query({       query: (postId) =&gt; `/posts/${postId}`,       // highlight-start       providesTags: (result, error, arg) =&gt; [{ type: "Post", id: arg }],       // highlight-end     }),     addNewPost: builder.mutation({       query: (initialPost) =&gt; ({         url: "/posts",         method: "POST",         body: initialPost,       }),       // highlight-next-line       invalidatesTags: ["Post"],     }),     editPost: builder.mutation({       query: (post) =&gt; ({         url: `posts/${post.id}`,         method: "PATCH",         body: post,       }),       // highlight-next-line       invalidatesTags: (result, error, arg) =&gt; [{ type: "Post", id: arg.id }],     }),   }), });</code></p>
<p>It’s possible for the <code>result</code> argument in these callbacks to be undefined if the response has no data or there’s an error, so we have to handle that safely. For <code>getPosts</code> we can do that by using a default argument array value to map over, and for <code>getPost</code> we’re already returning a single-item array based on the argument ID. For <code>editPost</code>, we know the ID of the post from the partial post object that was passed into the trigger function, so we can read it from there.</p>
<p>With those changes in place, let’s go back and try editing a post again, with the Network tab open in the browser DevTools.</p>
<figure>
<img src="/img/tutorials/essentials/devtools-cached-invalidation-refetching.png" alt="RTK Query invalidation and refetching" /><figcaption>RTK Query invalidation and refetching</figcaption>
</figure>
<p>When we save the edited post this time, we should see two requests happen back-to-back:</p>
<ul>
<li>The <code>PATCH /posts/:postId</code> from the <code>editPost</code> mutation</li>
<li>A <code>GET /posts/:postId</code> as the <code>getPost</code> query is refetched</li>
</ul>
<p>Then, if we click back to the main “Posts” tab, we should also see:</p>
<ul>
<li>A <code>GET /posts</code> as the <code>getPosts</code> query is refetched</li>
</ul>
<p>Because we provided the relationships between the endpoints using tags, <strong>RTK Query knew that it needed to refetch the individual post and the list of posts when we made that edit and the specific tag with that ID was invalidated</strong> - no further changes needed! Meanwhile, as we were editing the post, the cache removal timer for the <code>getPosts</code> data expired, so it was removed from the cache. When we opened the <code>&lt;PostsList&gt;</code> component again, RTK Query saw that it did not have the data in cache and refetched it.</p>
<p>There is one caveat here. By specifying a plain <code>'Post'</code> tag in <code>getPosts</code> and invalidating it in <code>addNewPost</code>, we actually end up forcing a refetch of all <em>individual</em> posts as well. If we really want to just refetch the list of posts for the <code>getPost</code> endpoint, you can include an additional tag with an arbitrary ID, like <code>{type: 'Post', id: 'LIST'}</code>, and invalidate that tag instead. The RTK Query docs have <a href="https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#tag-invalidation-behavior">a table that describes what will happen if certain general/specific tag combinations are invalidated</a>.</p>
<div class="info">
<p>RTK Query has many other options for controlling when and how to refetch data, including “conditional fetching”, “lazy queries”, and “prefetching”, and query definitions can be customized in a variety of ways. See the RTK Query usage guide docs for more details on using these features:</p>
<ul>
<li><a href="https://redux-toolkit.js.org/rtk-query/usage/automated-refetching">RTK Query: Automated Re-Fetching</a></li>
<li><a href="https://redux-toolkit.js.org/rtk-query/usage/conditional-fetching">RTK Query: Conditional Fetching</a></li>
<li><a href="https://redux-toolkit.js.org/rtk-query/usage/prefetching">RTK Query: Prefetching</a></li>
<li><a href="https://redux-toolkit.js.org/rtk-query/usage/customizing-queries">RTK Query: Customizing Queries</a></li>
<li><a href="https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#uselazyquery">RTK Query: <code>useLazyQuery</code></a></li>
</ul>
</div>
<h2 id="managing-users-data">Managing Users Data</h2>
<p>We’ve finished converting our posts data management over to use RTK Query. Next up, we’ll convert the list of users.</p>
<p>Since we’ve already seen how to use the RTK Query hooks for fetching and reading data, for this section we’re going to try a different approach. RTK Query’s core API is UI-agnostic and can be used with any UI layer, not just React. Normally you should stick with using the hooks, but here we’re going to work with the user data using <em>just</em> the RTK Query core API so you can see how to use it.</p>
<h3 id="fetching-users-manually">Fetching Users Manually</h3>
<p>We’re currently defining a <code>fetchUsers</code> async thunk in <code>usersSlice.js</code>, and dispatching that thunk manually in <code>index.js</code> so that the list of users is available as soon as possible. We can do that same process using RTK Query.</p>
<p>We’ll start by defining a <code>getUsers</code> query endpoint in <code>apiSlice.js</code>, similar to our existing endpoints. We’ll export the <code>useGetUsersQuery</code> hook just for consistency, but for now we’re not going to use it.</p>
<p>```js title=“features/api/apiSlice.js” export const apiSlice = createApi({ reducerPath: “api”, baseQuery: fetchBaseQuery({ baseUrl: “/fakeApi” }), tagTypes: [“Post”], endpoints: (builder) =&gt; ({ // omit other endpoints</p>
<pre><code>// highlight-start
getUsers: builder.query({
  query: () =&gt; &quot;/users&quot;,
}),
// highlight-end</code></pre>
<p>}), });</p>
<p>export const { useGetPostsQuery, useGetPostQuery, // highlight-next-line useGetUsersQuery, useAddNewPostMutation, useEditPostMutation, } = apiSlice; ```</p>
<p>If we inspect the API slice object, it includes an <code>endpoints</code> field, with one endpoint object inside for each endpoint we’ve defined.</p>
<figure>
<img src="/img/tutorials/essentials/api-slice-contents.png" alt="API slice endpoint contents" /><figcaption>API slice endpoint contents</figcaption>
</figure>
<p>Each endpoint object contains:</p>
<ul>
<li>The same primary query/mutation hook that we exported from the root API slice object, but named as <code>useQuery</code> or <code>useMutation</code></li>
<li>For query endpoints, an additional set of query hooks for scenarios like “lazy queries” or partial subscriptions</li>
<li>A set of <a href="https://redux-toolkit.js.org/api/matching-utilities">“matcher” utilities</a> to check for the <code>pending/fulfilled/rejected</code> actions dispatched by requests for this endpoint</li>
<li>An <code>initiate</code> thunk that triggers a request for this endpoint</li>
<li>A <code>select</code> function that creates <a href="../../usage/deriving-data-selectors.md">memoized selectors</a> that can retrieve the cached result data + status entries for this endpoint</li>
</ul>
<p>If we want to fetch the list of users outside of React, we can dispatch the <code>getUsers.initiate()</code> thunk in our index file:</p>
<p>```jsx title=“index.js” // omit other imports // highlight-next-line import { apiSlice } from “./features/api/apiSlice”;</p>
<p>// Start our mock API server worker.start({ onUnhandledRequest: “bypass” });</p>
<p>// highlight-next-line store.dispatch(apiSlice.endpoints.getUsers.initiate());</p>
<p>ReactDOM.render( &lt;React.StrictMode&gt; <Provider store={store}> <App /> </Provider> &lt;/React.StrictMode&gt;, document.getElementById(“root”) ); ```</p>
<p>This dispatch happens automatically inside the query hooks, but we can start it manually if needed.</p>
<div class="caution">
<p>Manually dispatching an RTKQ request thunk will create a subscription entry, but it’s then up to you to <a href="https://redux-toolkit.js.org/rtk-query/usage/usage-without-react-hooks#removing-a-subscription">unsubscribe from that data later</a> - otherwise the data stays in the cache permanently. In this case, we always need user data, so we can skip unsubscribing.</p>
</div>
<h3 id="selecting-users-data">Selecting Users Data</h3>
<p>We currently have selectors like <code>selectAllUsers</code> and <code>selectUserById</code> that are generated by our <code>createEntityAdapter</code> users adapter, and are reading from <code>state.users</code>. If we reload the page, all of our user-related display is broken because the <code>state.users</code> slice has no data. Now that we’re fetching data for RTK Query’s cache, we should replace those selectors with equivalents that read from the cache instead.</p>
<p>The <code>endpoint.select()</code> function in the API slice endpoints will create a new memoized selector function <em>every</em> time we call it. <code>select()</code> takes a cache key as its argument, and this must be the <em>same</em> cache key that you pass as an argument to either the query hooks or the <code>initiate()</code> thunk. The generated selector uses that cache key to know exactly which cached result it should return from the cache state in the store.</p>
<p>In this case, our <code>getUsers</code> endpoint doesn’t need any parameters - we always fetch the entire list of users. So, we can create a cache selector with no argument, and the cache key becomes <code>undefined</code>.</p>
<p>```js title=“features/users/usersSlice.js” import { createSlice, createEntityAdapter, createSelector, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>// highlight-next-line import { apiSlice } from “../api/apiSlice”;</p>
<p>/* Temporarily ignore adapter - we’ll use this again shortly const usersAdapter = createEntityAdapter()</p>
<p>const initialState = usersAdapter.getInitialState() */</p>
<p>// highlight-start // Calling <code>someEndpoint.select(someArg)</code> generates a new selector that will return // the query result object for a query with those parameters. // To generate a selector for a specific query argument, call <code>select(theQueryArg)</code>. // In this case, the users query has no params, so we don’t pass anything to select() export const selectUsersResult = apiSlice.endpoints.getUsers.select();</p>
<p>const emptyUsers = [];</p>
<p>export const selectAllUsers = createSelector( selectUsersResult, (usersResult) =&gt; usersResult?.data ?? emptyUsers );</p>
<p>export const selectUserById = createSelector( selectAllUsers, (state, userId) =&gt; userId, (users, userId) =&gt; users.find((user) =&gt; user.id === userId) ); // highlight-end</p>
<p>/* Temporarily ignore selectors - we’ll come back to this later export const { selectAll: selectAllUsers, selectById: selectUserById, } = usersAdapter.getSelectors((state) =&gt; state.users) */ ```</p>
<p>Once we have that initial <code>selectUsersResult</code> selector, we can replace the existing <code>selectAllUsers</code> selector with one that returns the array of users from the cache result, and then replace <code>selectUserById</code> with one that finds the right user from that array.</p>
<p>For now we’re going to comment out those selectors from the <code>usersAdapter</code> - we’re going to make another change later that switches back to using those.</p>
<p>Our components are already importing <code>selectAllUsers</code> and <code>selectUserById</code>, so this change should just work! Try refreshing the page and clicking through the posts list and single post view. The correct user names should appear in each displayed post, and in the dropdown in the <code>&lt;AddPostForm&gt;</code>.</p>
<p>Since the <code>usersSlice</code> is no longer even being used at all, we can go ahead and delete the <code>createSlice</code> call from this file, and remove <code>users: usersReducer</code> from our store setup. We’ve still got a couple bits of code that reference <code>postsSlice</code>, so we can’t quite remove that yet - we’ll get to that shortly.</p>
<h3 id="injecting-endpoints">Injecting Endpoints</h3>
<p>It’s common for larger applications to “code-split” features into separate bundles, and then “lazy load” them on demand as the feature is used for the first time. We said that RTK Query normally has a single “API slice” per application, and so far we’ve defined all of our endpoints directly in <code>apiSlice.js</code>. What happens if we want to code-split some of our endpoint definitions, or move them into another file to keep the API slice file from getting too big?</p>
<p><strong>RTK Query supports splitting out endpoint definitions with <code>apiSlice.injectEndpoints()</code></strong>. That way, we can still have a single API slice with a single middleware and cache reducer, but we can move the definition of some endpoints to other files. This enables code-splitting scenarios, as well as co-locating some endpoints alongside feature folders if desired.</p>
<p>To illustrate this process, let’s switch the <code>getUsers</code> endpoint to be injected in <code>usersSlice.js</code>, instead of defined in <code>apiSlice.js</code>.</p>
<p>We’re already importing <code>apiSlice</code> into <code>usersSlice.js</code> so that we can access the <code>getUsers</code> endpoint, so we can switch to calling <code>apiSlice.injectEndpoints()</code> here instead.</p>
<p>```js title=“features/users/usersSlice.js” import { apiSlice } from “../api/apiSlice”;</p>
<p>// highlight-start export const extendedApiSlice = apiSlice.injectEndpoints({ endpoints: (builder) =&gt; ({ getUsers: builder.query({ query: () =&gt; “/users”, }), }), });</p>
<p>export const { useGetUsersQuery } = extendedApiSlice;</p>
<p>export const selectUsersResult = extendedApiSlice.endpoints.getUsers.select(); // highlight-end ```</p>
<p><code>injectEndpoints()</code> <strong>mutates the original API slice object to add the additional endpoint definitions, and then returns it</strong>. The actual caching reducer and middleware that we originally added to the store still work okay as-is. At this point, <code>apiSlice</code> and <code>extendedApiSlice</code> are the same object, but it can be helpful to refer to the <code>extendedApiSlice</code> object instead of <code>apiSlice</code> here as a reminder to ourselves. (This is more important if you’re using TypeScript, because only the <code>extendedApiSlice</code> value has the added types for the new endpoints.)</p>
<p>At the moment, the only file that references the <code>getUsers</code> endpoint is our index file, which is dispatching the <code>initiate</code> thunk. We need to update that to import the extended API slice instead:</p>
<p>```js title=“index.js” // highlight-next-line import { extendedApiSlice } from “./features/users/usersSlice”;</p>
<p>// Start our mock API server worker.start({ onUnhandledRequest: “bypass” });</p>
<p>// highlight-next-line store.dispatch(extendedApiSlice.endpoints.getUsers.initiate()); ```</p>
<p>Alternately, you could just export the specific endpoints themselves from the slice file.</p>
<h2 id="manipulating-response-data">Manipulating Response Data</h2>
<p>So far, all of our query endpoints have simply stored the response data from the server exactly as it was received in the body. <code>getPosts</code> and <code>getUsers</code> both expect the server to return an array, and <code>getPost</code> expects the individual <code>Post</code> object as the body.</p>
<p>It’s common for clients to need to extract pieces of data from the server response, or to transform the data in some way before caching it. For example, what if the <code>/getPost</code> request returns a body like <code>{post: {id}}</code>, with the data nested?</p>
<p>There’s a couple ways that we <em>could</em> handle this conceptually. One option would be to extract the <code>responseData.post</code> field and store that in the cache, instead of the entire body. Another would be to store the entire response data in the cache, but have our components specify just a specific piece of that cached data that they need.</p>
<h3 id="transforming-responses">Transforming Responses</h3>
<p><strong>Endpoints can define a <code>transformResponse</code> handler that can extract or modify the data received from the server before it’s cached</strong>. For the <code>getPost</code> example, we could have <code>transformResponse: (responseData) =&gt; responseData.post</code>, and it would cache just the actual <code>Post</code> object instead of the entire body of the response.</p>
<p>In <a href="./part-6-performance-normalization.md">Part 6: Performance and Normalization</a>, we discussed reasons why it’s useful to store data in a normalized structure. In particular, it lets us look up and update items based on an ID, rather than having to loop over an array to find the right item.</p>
<p>Our <code>selectUserById</code> selector currently has to loop over the cached array of users to find the right <code>User</code> object. If we were to transform the response data to be stored using a normalized approach, we could simplify that to directly find the user by ID.</p>
<p>We were previously using <code>createEntityAdapter</code> in <code>usersSlice</code> to manage normalized users data. We can integrate <code>createEntityAdapter</code> into our <code>extendedApiSlice</code>, and actually use <code>createEntityAdapter</code> to transform the data before it’s cached. We’ll uncomment the <code>usersAdapter</code> lines we originally had, and use its update functions and selectors again.</p>
<p>```js title=“features/users/usersSlice.js” import { apiSlice } from “../api/apiSlice”;</p>
<p>// highlight-start const usersAdapter = createEntityAdapter();</p>
<p>const initialState = usersAdapter.getInitialState(); // highlight-end</p>
<p>export const extendedApiSlice = apiSlice.injectEndpoints({ endpoints: (builder) =&gt; ({ getUsers: builder.query({ query: () =&gt; “/users”, // highlight-start transformResponse: (responseData) =&gt; { return usersAdapter.setAll(initialState, responseData); }, // highlight-end }), }), });</p>
<p>export const { useGetUsersQuery } = extendedApiSlice;</p>
<p>// Calling <code>someEndpoint.select(someArg)</code> generates a new selector that will return // the query result object for a query with those parameters. // To generate a selector for a specific query argument, call <code>select(theQueryArg)</code>. // In this case, the users query has no params, so we don’t pass anything to select() export const selectUsersResult = extendedApiSlice.endpoints.getUsers.select();</p>
<p>const selectUsersData = createSelector( selectUsersResult, (usersResult) =&gt; usersResult.data );</p>
<p>// highlight-start export const { selectAll: selectAllUsers, selectById: selectUserById } = usersAdapter.getSelectors((state) =&gt; selectUsersData(state) ?? initialState); // highlight-end ```</p>
<p>We’ve added a <code>transformResponse</code> option to the <code>getUsers</code> endpoint. It receives the entire response data body as its argument, and should return the actual data to be cached. By calling <code>usersAdapter.setAll(initialState, responseData)</code>, it will return the standard <code>{ids: [], entities: {}}</code> normalized data structure containing all of the received items.</p>
<p>The <code>adapter.getSelectors()</code> function needs to be given an “input selector” so it knows where to find that normalized data. In this case, the data is nested down inside the RTK Query cache reducer, so we select the right field out of the cache state.</p>
<h3 id="normalized-vs-document-caches">Normalized vs Document Caches</h3>
<p>It’s worth stepping back for a minute to discuss what we just did further.</p>
<p>You may have heard the term “normalized cache” in relation to other data fetching libraries like Apollo. It’s important to understand that <strong>RTK Query uses a “document cache” approach, not a “normalized cache”</strong>.</p>
<p>A fully normalized cache tries to deduplicate similar items across <em>all</em> queries, based on item type and ID. As an example, say that we have an API slice with <code>getTodos</code> and <code>getTodo</code> endpoints, and our components make the following queries:</p>
<ul>
<li><code>getTodos()</code></li>
<li><code>getTodos({filter: 'odd'})</code></li>
<li><code>getTodo({id: 1})</code></li>
</ul>
<p>Each of these query results would include a Todo object that looks like <code>{id: 1}</code>.</p>
<p>In a fully normalized de-duplicating cache, only a single copy of this Todo object would be stored. However, <strong>RTK Query saves each query result independently in the cache</strong>. So, this would result in three separate copies of this Todo being cached in the Redux store. However, if all the endpoints are consistently providing the same tags (such as <code>{type: 'Todo', id: 1}</code>), then invalidating that tag will force all the matching endpoints to refetch their data for consistency.</p>
<p>RTK Query deliberately <strong>does <em>not</em> implement a cache that would deduplicate identical items across multiple requests</strong>. There are several reasons for this:</p>
<ul>
<li>A fully normalized shared-across-queries cache is a <em>hard</em> problem to solve</li>
<li>We don’t have the time, resources, or interest in trying to solve that right now</li>
<li>In many cases, simply re-fetching data when it’s invalidated works well and is easier to understand</li>
<li>At a minimum, RTKQ can help solve the general use case of “fetch some data”, which is a big pain point for a lot of people</li>
</ul>
<p>In comparison, we just normalized the response data for the <code>getUsers</code> endpoint, in that it’s being stored as an <code>{[id]: value}</code> lookup table. However, <strong>this is <em>not</em> the same thing as a “normalized cache” - we only transformed <em>how this one response is stored</em></strong> rather than deduplicating results across endpoints or requests.</p>
<h3 id="selecting-values-from-results">Selecting Values from Results</h3>
<p>The last component that is reading from the old <code>postsSlice</code> is <code>&lt;UserPage&gt;</code>, which filters the list of posts based on the current user. We’ve already seen that we can get the entire list of posts with <code>useGetPostsQuery()</code> and then transform it in the component, such as sorting inside of a <code>useMemo</code>. The query hooks also give us the ability to select pieces of the cached state by providing a <code>selectFromResult</code> option, and only re-render when the selected pieces change.</p>
<p>We can use <code>selectFromResult</code> to have <code>&lt;UserPage&gt;</code> read just a filtered list of posts from the cache. However, in order for <code>selectFromResult</code> to avoid unnecessary re-renders, we need to ensure that whatever data we extract is memoized correctly. To do this, we should create a new selector instance that the <code>&lt;UsersPage&gt;</code> component can reuse every time it renders, so that the selector memoizes the result based on its inputs.</p>
<p>```jsx title=“features/users/UsersPage.js” // highlight-next-line import { createSelector } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import { selectUserById } from “../users/usersSlice”; // highlight-next-line import { useGetPostsQuery } from “../api/apiSlice”;</p>
<p>export const UserPage = ({ match }) =&gt; { const { userId } = match.params;</p>
<p>const user = useSelector((state) =&gt; selectUserById(state, userId));</p>
<p>// highlight-start const selectPostsForUser = useMemo(() =&gt; { // Return a unique selector instance for this page so that // the filtered results are correctly memoized return createSelector( (res) =&gt; res.data, (res, userId) =&gt; userId, (data, userId) =&gt; data.filter((post) =&gt; post.user === userId) ); }, []); // highlight-end</p>
<p>// Use the same posts query, but extract only part of its data const { postsForUser } = useGetPostsQuery(undefined, { // highlight-start selectFromResult: (result) =&gt; ({ // We can optionally include the other metadata fields from the result here …result, // Include a field called <code>postsForUser</code> in the hook result object, // which will be a filtered list of posts postsForUser: selectPostsForUser(result, userId), }), // highlight-end });</p>
<p>// omit rendering logic }; ```</p>
<p>There’s a key difference with the memoized selector function we’ve created here. Normally, <a href="../../usage/deriving-data-selectors.md">selectors expect the entire Redux <code>state</code> as their first argument</a>, and extract or derive a value from <code>state</code>. However, in this case we’re only dealing with the “result” value that is kept in the cache. The result object has a <code>data</code> field inside with the actual values we need, as well as some of the request metadata fields.</p>
<p>Our <code>selectFromResult</code> callback receives the <code>result</code> object containing the original request metadata and the <code>data</code> from the server, and should return some extracted or derived values. Because query hooks add an additional <code>refetch</code> method to whatever is returned here, it’s preferably to always return an object from <code>selectFromResult</code> with the fields inside that you need.</p>
<p>Since <code>result</code> is being kept in the Redux store, we can’t mutate it - we need to return a new object. The query hook will do a “shallow” comparison on this returned object, and only re-render the component if one of the fields has changed. We can optimize re-renders by only returning the specific fields needed by this component - if we don’t need the rest of the metadata flags, we could omit them entirely. If you do need them, you can spread the original <code>result</code> value to include them in the output.</p>
<p>In this case, we’ll call the field <code>postsForUser</code>, and we can destructure that new field from the hook result. By calling <code>selectPostsForUser(result, userId)</code> every time, it will memoize the filtered array and only recalculate it if the fetched data or the user ID changes.</p>
<h3 id="comparing-transformation-approaches">Comparing Transformation Approaches</h3>
<p>We’ve now seen three different ways that we can manage transforming responses:</p>
<ul>
<li>Keep original response in cache, read full result in component and derive values</li>
<li>Keep original response in cache, read derived result with <code>selectFromResponse</code></li>
<li>Transform response before storing in cache</li>
</ul>
<p>Each of these approaches can be useful in different situations. Here’s some suggestions for when you should consider using them:</p>
<ul>
<li><code>transformResponse</code>: all consumers of the endpoint want a specific format, such as normalizing the response to enable faster lookups by ID</li>
<li><code>selectFromResult</code>: some consumers of the endpoint only need partial data, such as a filtered list</li>
<li>per-component / <code>useMemo</code>: when only some specific components need to transform the cached data</li>
</ul>
<h2 id="advanced-cache-updates">Advanced Cache Updates</h2>
<p>We’ve completed updating our posts and users data, so all that’s left is working with reactions and notifications. Switching these to use RTK Query will give us a chance to try out some of the advanced techniques available for working with RTK Query’s cached data, and allow us to provide a better experience for our users.</p>
<h3 id="persisting-reactions">Persisting Reactions</h3>
<p>Originally, we only tracked reactions on the client side and did not persist them to the server. Let’s add a new <code>addReaction</code> mutation and use that to update the corresponding <code>Post</code> on the server every time the user clicks a reaction button.</p>
<p>``<code>js title="features/api/apiSlice.js" export const apiSlice = createApi({   reducerPath: "api",   baseQuery: fetchBaseQuery({ baseUrl: "/fakeApi" }),   tagTypes: ["Post"],   endpoints: (builder) =&gt; ({     // omit other endpoints     // highlight-start     addReaction: builder.mutation({       query: ({ postId, reaction }) =&gt; ({         url:</code>posts/${postId}/reactions`, method: “POST”, // In a real app, we’d probably need to base this on user ID somehow // so that a user can’t do the same reaction more than once body: { reaction }, }), invalidatesTags: (result, error, arg) =&gt; [ { type: “Post”, id: arg.postId }, ], }), // highlight-end }), });</p>
<p>export const { useGetPostsQuery, useGetPostQuery, useAddNewPostMutation, useEditPostMutation, // highlight-next-line useAddReactionMutation, } = apiSlice; ```</p>
<p>Similar to our other mutations, we take some parameters and make a request to the server, with some data in the body of the request. Since this example app is small, we’ll just give the name of the reaction, and let the server increment the counter for that reaction type on this post.</p>
<p>We already know that we need to refetch this post in order to see any of the data change on the client, so we can invalidate this specific <code>Post</code> entry based on its ID.</p>
<p>With that in place, let’s update <code>&lt;ReactionButtons&gt;</code> to use this mutation.</p>
<p>```jsx title=“features/posts/ReactionButtons.js” import React from “react”;</p>
<p>// highlight-next-line import { useAddReactionMutation } from “../api/apiSlice”;</p>
<p>const reactionEmoji = { thumbsUp: “👍”, hooray: “🎉”, heart: “❤️”, rocket: “🚀”, eyes: “👀”, };</p>
<p>export const ReactionButtons = ({ post }) =&gt; { // highlight-next-line const [addReaction] = useAddReactionMutation();</p>
<p>const reactionButtons = Object.entries(reactionEmoji).map( ([reactionName, emoji]) =&gt; { return ( &lt;button key={reactionName} type=“button” className=“muted-button reaction-button” onClick={() =&gt; { // highlight-next-line addReaction({ postId: post.id, reaction: reactionName }); }} &gt; {emoji} {post.reactions[reactionName]} </button> ); } );</p>
return
<div>
{reactionButtons}
</div>
<p>; }; ```</p>
<p>Let’s see this in action! Go to the main <code>&lt;PostsList&gt;</code>, and click one of the reactions to see what happens.</p>
<figure>
<img src="/img/tutorials/essentials/disabled-posts-fetching.png" alt="PostsList disabled while fetching" /><figcaption>PostsList disabled while fetching</figcaption>
</figure>
<p>Uh-oh. The entire <code>&lt;PostsList&gt;</code> component was grayed out, because we just refetched the <em>entire</em> list of posts in response to that one post being updated. This is deliberately more visible because our mock API server is set to have a 2-second delay before responding, but even if the response is faster, this still isn’t a good user experience.</p>
<h3 id="implementing-optimistic-updates">Implementing Optimistic Updates</h3>
<p>For a small update like adding a reaction, we probably don’t need to re-fetch the entire list of posts. Instead, we could try just updating the already-cached data on the client to match what we expect to have happen on the server. Also, if we update the cache immediately, the user gets instant feedback when the click the button instead of having to wait for the response to come back. <strong>This approach of updating client state right away is called an “optimistic update”</strong>, and it’s a common pattern in web apps.</p>
<p><strong>RTK Query lets you implement optimistic updates by modifying the client-side cache based on “request lifecycle” handlers</strong>. Endpoints can define an <code>onQueryStarted</code> function that will be called when a request starts, and we can run additional logic in that handler.</p>
<p>```js title=“features/api/apiSlice.js” export const apiSlice = createApi({ reducerPath: “api”, baseQuery: fetchBaseQuery({ baseUrl: “/fakeApi” }), tagTypes: [“Post”], endpoints: (builder) =&gt; ({ // omit other endpoints</p>
<pre><code>addReaction: builder.mutation({
  query: ({ postId, reaction }) =&gt; ({
    url: `posts/${postId}/reactions`,
    method: &quot;POST&quot;,
    // In a real app, we&#39;d probably need to base this on user ID somehow
    // so that a user can&#39;t do the same reaction more than once
    body: { reaction },
  }),
  // highlight-start
  async onQueryStarted({ postId, reaction }, { dispatch, queryFulfilled }) {
    // `updateQueryData` requires the endpoint name and cache key arguments,
    // so it knows which piece of cache state to update
    const patchResult = dispatch(
      apiSlice.util.updateQueryData(&quot;getPosts&quot;, undefined, (draft) =&gt; {
        // The `draft` is Immer-wrapped and can be &quot;mutated&quot; like in createSlice
        const post = draft.find((post) =&gt; post.id === postId);
        if (post) {
          post.reactions[reaction]++;
        }
      })
    );
    try {
      await queryFulfilled;
    } catch {
      patchResult.undo();
    }
  },
  // highlight-end
}),</code></pre>
<p>}), }); ```</p>
<p>The <code>onQueryStarted</code> handler receives two parameters. The first is the cache key <code>arg</code> that was passed when the request started. The second is an object that contains some of the same fields as the <code>thunkApi</code> in <code>createAsyncThunk</code> ( <code>{dispatch, getState, extra, requestId}</code>), but also a <code>Promise</code> called <code>queryFulfilled</code>. This <code>Promise</code> will resolve when the request returns, and either fulfill or reject based on the request.</p>
<p>The API slice object includes a <code>updateQueryData</code> util function that lets us update cached values. It takes three arguments: the name of the endpoint to update, the same cache key value used to identify the specific cached data, and a callback that updates the cached data. <strong><code>updateQueryData</code> uses Immer, so you can “mutate” the drafted cache data the same way you would in <code>createSlice</code></strong>.</p>
<p>We can implement the optimistic update by finding the specific <code>Post</code> entry in the <code>getPosts</code> cache, and “mutating” it to increment the reaction counter.</p>
<p><code>updateQueryData</code> generates an action object with a patch diff of the changes we made. When we dispatch that action, the return value is a <code>patchResult</code> object. If we call <code>patchResult.undo()</code>, it automatically dispatches an action that reverses the patch diff changes.</p>
<p>By default, we expect that the request will succeed. In case the request fails, we can <code>await queryFulfilled</code>, catch a failure, and undo the patch changes to revert the optimistic update.</p>
<p>For this case, we’ve also removed the <code>invalidatesTags</code> line we’d just added, since we <em>don’t</em> want to refetch the posts when we click a reaction button.</p>
<p>Now, if we click several times on a reaction button quickly, we should see the number increment in the UI each time. If we look at the Network tab, we’ll also see each individual request go out to the server as well.</p>
<h3 id="streaming-cache-updates">Streaming Cache Updates</h3>
<p>Our final feature is the notifications tab. When we originally built this feature in <a href="./part-6-performance-normalization.md#adding-notifications">Part 6</a>, we said that “in a real app, the server would push updates to our client every time something happens”. We initially faked that feature by adding a “Refresh Notifications” button, and having it make an HTTP <code>GET</code> request for more notifications entries.</p>
<p>It’s common for apps to make an <em>initial</em> request to fetch data from the server, and then open up a Websocket connection to receive additional updates over time. <strong>RTK Query provides an <code>onCacheEntryAdded</code> endpoint lifecycle handler that lets us implement “streaming updates” to cached data</strong>. We’ll use that capability to implement a more realistic approach to managing notifications.</p>
<p>Our <code>src/api/server.js</code> file has a mock Websocket server already configured, similar to the mock HTTP server. We’ll write a new <code>getNotifications</code> endpoint that fetches the initial list of notifications, and then establishes the Websocket connection to listen for future updates. We still need to manually tell the mock server <em>when</em> to send new notifications, so we’ll continue faking that by having a button we click to force the update.</p>
<p>We’ll inject the <code>getNotifications</code> endpoint in <code>notificationsSlice</code> like we did with <code>getUsers</code>, just to show it’s possible.</p>
<p>```js title=“features/notifications/notificationsSlice.js” import { forceGenerateNotifications } from “../../api/server”; import { apiSlice } from “../api/apiSlice”;</p>
<p>export const extendedApi = apiSlice.injectEndpoints({ endpoints: (builder) =&gt; ({ getNotifications: builder.query({ query: () =&gt; “/notifications”, transformResponse: (res) =&gt; res.notifications, async onCacheEntryAdded( arg, { updateCachedData, cacheDataLoaded, cacheEntryRemoved } ) { // create a websocket connection when the cache subscription starts const ws = new WebSocket(“ws://localhost”); try { // wait for the initial query to resolve before proceeding await cacheDataLoaded;</p>
<pre><code>      // when data is received from the socket connection to the server,
      // update our query result with the received message
      const listener = (event) =&gt; {
        const message = JSON.parse(event.data);
        switch (message.type) {
          case &quot;notifications&quot;: {
            updateCachedData((draft) =&gt; {
              // Insert all received notifications from the websocket
              // into the existing RTKQ cache array
              draft.push(...message.payload);
              draft.sort((a, b) =&gt; b.date.localeCompare(a.date));
            });
            break;
          }
          default:
            break;
        }
      };

      ws.addEventListener(&quot;message&quot;, listener);
    } catch {
      // no-op in case `cacheEntryRemoved` resolves before `cacheDataLoaded`,
      // in which case `cacheDataLoaded` will throw
    }
    // cacheEntryRemoved will resolve when the cache subscription is no longer active
    await cacheEntryRemoved;
    // perform cleanup steps once the `cacheEntryRemoved` promise resolves
    ws.close();
  },
}),</code></pre>
<p>}), });</p>
<p>export const { useGetNotificationsQuery } = extendedApi;</p>
<p>const emptyNotifications = [];</p>
<p>export const selectNotificationsResult = extendedApi.endpoints.getNotifications.select();</p>
<p>const selectNotificationsData = createSelector( selectNotificationsResult, (notificationsResult) =&gt; notificationsResult.data ?? emptyNotifications );</p>
<p>export const fetchNotificationsWebsocket = () =&gt; (dispatch, getState) =&gt; { const allNotifications = selectNotificationsData(getState()); const [latestNotification] = allNotifications; const latestTimestamp = latestNotification?.date ?? ""; // Hardcode a call to the mock server to simulate a server push scenario over websockets forceGenerateNotifications(latestTimestamp); };</p>
<p>// omit existing slice code ```</p>
<p>Like with <code>onQueryStarted</code>, the <code>onCacheEntryAdded</code> lifecycle handler receives the <code>arg</code> cache key as its first parameter, and an options object with the <code>thunkApi</code> values as the second parameter. The options object also contains an <code>updateCachedData</code> util function, and two lifecycle <code>Promise</code>s - <code>cacheDataLoaded</code> and <code>cacheEntryRemoved</code>. <code>cacheDataLoaded</code> resolves when the <em>initial</em> data for this subscription is added to the store. This happens when the first subscription for this endpoint + cache key is added. As long as 1+ subscribers for the data are still active, the cache entry is kept alive. When the number of subscribers goes to 0 and the cache lifetime timer expires, the cache entry will be removed, and <code>cacheEntryRemoved</code> will resolve. Typically, the usage pattern is:</p>
<ul>
<li><code>await cacheDataLoaded</code> right away</li>
<li>Create a server-side data subscription like a Websocket</li>
<li>When an update is received, use <code>updateCachedData</code> to “mutate” the cached values based on the update</li>
<li><code>await cacheEntryRemoved</code> at the end</li>
<li>Clean up subscriptions afterwwards</li>
</ul>
<p>Our mock Websocket server file exposes a <code>forceGenerateNotifications</code> method to mimic pushing data out to the client. That depends on knowing the most recent notification timestamp, so we add a thunk we can dispatch that reads the latest timestamp from the cache state and tells the mock server to generate newer notifications.</p>
<p>Inside of <code>onCacheEntryAdded</code>, we create a real <code>Websocket</code> connection to <code>localhost</code>. In a real app, this could be any kind of external subscription or polling connection you need to receive ongoing updates. Whenever the mock server sends us an update, we push all of the received notifications into the cache and re-sort it.</p>
<p>When the cache entry is removed, we clean up the Websocket subscription. In this app, the notifications cache entry will never be removed because we never unsubscribe from the data, but it’s important to see how the cleanup would work for a real app.</p>
<h3 id="tracking-client-side-state">Tracking Client-Side State</h3>
<p>We need to make one final set of updates. Our <code>&lt;Navbar&gt;</code> component has to initiate the fetching of notifications, and <code>&lt;NotificationsList&gt;</code> needs to show the notification entries with the correct read/unread status. However, we were previously adding the read/unread fields on the client side in our <code>notificationsSlice</code> reducer when we received the entries, and now the notification entries are being kept in the RTK Query cache.</p>
<p>We can rewrite <code>notificationsSlice</code> so that it listens for any received notifications, and tracks some additional state on the client side for each notification entry.</p>
<p>There’s two cases when new notification entries are received: when we fetch the initial list over HTTP, and when we receive an update pushed over the Websocket connection. Ideally, we want to use the same logic in response to both cases. We can use RTK’s <a href="https://redux-toolkit.js.org/api/matching-utilities">“matching utilities”</a> to write one case reducer that runs in response to multiple action types.</p>
<p>Let’ see what <code>notificationsSlice</code> looks like after we add this logic.</p>
<p>```js title=“features/notifications/notificationsSlice.js” import { // highlight-next-line createAction, createSlice, createEntityAdapter, createSelector, // highlight-next-line isAnyOf, } from “<span class="citation" data-cites="reduxjs/toolkit">@reduxjs/toolkit</span>”;</p>
<p>import { forceGenerateNotifications } from “../../api/server”; import { apiSlice } from “../api/apiSlice”;</p>
<p>// highlight-start const notificationsReceived = createAction( “notifications/notificationsReceived” ); // highlight-end</p>
<p>export const extendedApi = apiSlice.injectEndpoints({ endpoints: (builder) =&gt; ({ getNotifications: builder.query({ query: () =&gt; “/notifications”, async onCacheEntryAdded( arg, // highlight-next-line { updateCachedData, cacheDataLoaded, cacheEntryRemoved, dispatch } ) { // create a websocket connection when the cache subscription starts const ws = new WebSocket(“ws://localhost”); try { // wait for the initial query to resolve before proceeding await cacheDataLoaded;</p>
<pre><code>      // when data is received from the socket connection to the server,
      // update our query result with the received message
      const listener = (event) =&gt; {
        const message = JSON.parse(event.data);
        switch (message.type) {
          case &quot;notifications&quot;: {
            updateCachedData((draft) =&gt; {
              // Insert all received notifications from the websocket
              // into the existing RTKQ cache array
              draft.push(...message.payload);
              draft.sort((a, b) =&gt; b.date.localeCompare(a.date));
            });
            // highlight-start
            // Dispatch an additional action so we can track &quot;read&quot; state
            dispatch(notificationsReceived(message.payload));
            // highlight-end
            break;
          }
          default:
            break;
        }
      };

      ws.addEventListener(&quot;message&quot;, listener);
    } catch {
      // no-op in case `cacheEntryRemoved` resolves before `cacheDataLoaded`,
      // in which case `cacheDataLoaded` will throw
    }
    // cacheEntryRemoved will resolve when the cache subscription is no longer active
    await cacheEntryRemoved;
    // perform cleanup steps once the `cacheEntryRemoved` promise resolves
    ws.close();
  },
}),</code></pre>
<p>}), });</p>
<p>export const { useGetNotificationsQuery } = extendedApi;</p>
<p>// omit selectors and websocket thunk</p>
<p>// highlight-start const notificationsAdapter = createEntityAdapter();</p>
<p>const matchNotificationsReceived = isAnyOf( notificationsReceived, extendedApi.endpoints.getNotifications.matchFulfilled ); // highlight-end</p>
<p>const notificationsSlice = createSlice({ name: “notifications”, initialState: notificationsAdapter.getInitialState(), reducers: { allNotificationsRead(state, action) { Object.values(state.entities).forEach((notification) =&gt; { notification.read = true; }); }, }, extraReducers(builder) { // highlight-start builder.addMatcher(matchNotificationsReceived, (state, action) =&gt; { // Add client-side metadata for tracking new notifications const notificationsMetadata = action.payload.map((notification) =&gt; ({ id: notification.id, read: false, isNew: true, }));</p>
<pre><code>  Object.values(state.entities).forEach((notification) =&gt; {
    // Any notifications we&#39;ve read are no longer new
    notification.isNew = !notification.read;
  });

  notificationsAdapter.upsertMany(state, notificationsMetadata);
});
// highlight-end</code></pre>
<p>}, });</p>
<p>// omit slice exports ```</p>
<p>There’s a lot going on, but let’s break down the changes one at a time.</p>
<p>There isn’t currently a good way for the <code>notificationsSlice</code> reducer to know when we’ve received an updated list of new notifications via the Websocket. So, we’ll import <code>createAction</code>, define a new action type specifically for the “received some notifications” case, and dispatch that action after updating the cache state.</p>
<p>We want to run the same “add read/new metadata” logic for <em>both</em> the “fulfilled <code>getNotifications</code>” action <em>and</em> the “received from Websocket” action. We can create a new “matcher” function by calling <code>isAnyOf()</code> and passing in each of those action creators. The <code>matchNotificationsReceived</code> matcher function will return true if the current action matches either of those types.</p>
<p>Finally, we can use the <code>builder.addMatcher()</code> API inside of <code>extraReducers</code> to add a case reducer that runs whenever we match one of those two action types. Inside of there, we add a new “read/isNew” metadata entry that corresponds to each notification by ID, and store that inside of <code>notificationsSlice</code>.</p>
<p>With those changes in place, we can update our UI components to fetch and display notifications.</p>
<p>```jsx title=“app/Navbar.js” import React from “react”; import { useDispatch, useSelector } from “react-redux”; import { Link } from “react-router-dom”;</p>
<p>import { // highlight-start fetchNotificationsWebsocket, selectNotificationsMetadata, useGetNotificationsQuery, // highlight-end } from “../features/notifications/notificationsSlice”;</p>
<p>export const Navbar = () =&gt; { const dispatch = useDispatch();</p>
<p>// highlight-start // Trigger initial fetch of notifications and keep the websocket open to receive updates useGetNotificationsQuery();</p>
<p>const notificationsMetadata = useSelector(selectNotificationsMetadata); const numUnreadNotifications = notificationsMetadata.filter( (n) =&gt; !n.read ).length;</p>
<p>const fetchNewNotifications = () =&gt; { dispatch(fetchNotificationsWebsocket()); }; // highlight-end</p>
<p>let unreadNotificationsBadge;</p>
<p>if (numUnreadNotifications &gt; 0) { unreadNotificationsBadge = ( <span data-classname="badge">{numUnreadNotifications}</span> ); }</p>
<p>// omit rendering logic }; ```</p>
<p>In <code>&lt;NavBar&gt;</code>, we trigger the initial notifications fetch with <code>useGetNotificationsQuery()</code>, and switch to reading the metadata objects from <code>state.notificationsSlice</code>. Clicking the “Refresh” button now triggers the mock Websocket server to push out another set of notifications.</p>
<p>Our <code>&lt;NotificationsList&gt;</code> similarly switches over to reading the cached data and metadata.</p>
<p>```jsx title=“features/notifications/NotificationsList.js” import { // highlight-start useGetNotificationsQuery, allNotificationsRead, selectMetadataEntities, // highlight-end } from ‘./notificationsSlice’</p>
<p>export const NotificationsList = () =&gt; { const dispatch = useDispatch() // highlight-start const { data: notifications = [] } = useGetNotificationsQuery() const notificationsMetadata = useSelector(selectMetadataEntities) // highlight-end const users = useSelector(selectAllUsers)</p>
<p>useLayoutEffect(() =&gt; { dispatch(allNotificationsRead()) })</p>
<p>const renderedNotifications = notifications.map((notification) =&gt; { const date = parseISO(notification.date) const timeAgo = formatDistanceToNow(date) const user = users.find((user) =&gt; user.id === notification.user) || { name: ‘Unknown User’, }</p>
<pre><code>// highlight-next-line
const metadata = notificationsMetadata[notification.id]

const notificationClassname = classnames(&#39;notification&#39;, {
  // highlight-next-line
  new: metadata.isNew,
})</code></pre>
<p>// omit rendering logic } ```</p>
<p>We read the list of notifications from cache and the new metadata entries from the notificationsSlice, and continue displaying them the same way as before.</p>
<p>As a final step, we can do some additional cleanup here - the <code>postsSlice</code> is no longer being used, so that can be removed entirely.</p>
<p>With that, we’ve finished converting our application over to use RTK Query! All of the data fetching has been switched over to use RTKQ, and we’ve improved the user experience by adding optimistic updates and streaming updates.</p>
<h2 id="what-youve-learned-15">What You’ve Learned</h2>
<p>As we’ve seen, RTK Query includes some powerful options for controlling how we manage cached data. While you may not need all of these options right away, they provide flexibility and key capabilities to help implement specific application behaviors.</p>
<p>Let’s take one last look at the whole application in action:</p>
<iframe class="codesandbox" src="https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-6-rtkqConversion/?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;runonclick=1" title="redux-essentials-example-app" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>:::tip Summary</p>
<ul>
<li><strong>Specific cache tags can be used for finer-grained cache invalidation</strong>
<ul>
<li>Cache tags can be either <code>'Post'</code> or <code>{type: 'Post', id}</code></li>
<li>Endpoints can provide or invalidate cache tags based on results and arg cache keys</li>
</ul></li>
<li><strong>RTK Query’s APIs are UI-agnostic and can be used outside of React</strong>
<ul>
<li>Endpoint objects include functions for initating requests, generating result selectors, and matching request action objects</li>
</ul></li>
<li><strong>Responses can be transformed in different ways as needed</strong>
<ul>
<li>Endpoints can define a <code>transformResponse</code> callback to modify the data before caching</li>
<li>Hooks can be given a <code>selectFromResponse</code> option to extract/transform data</li>
<li>Components can read an entire value and transform with <code>useMemo</code></li>
</ul></li>
<li><strong>RTK Query has advanced options for manipulating cached data for better user experience</strong>
<ul>
<li>The <code>onQueryStarted</code> lifecycle can be used for optimistic updates by updating cache immediately before a request returns</li>
<li>The <code>onCacheEntryAdded</code> lifecycle can be used for streaming updates by updating cache over time based on server push connections</li>
</ul></li>
</ul>
<p>:::</p>
<h2 id="whats-next-14">What’s Next?</h2>
<p>Congratulations, <strong>you’ve completed the Redux Essentials tutorial!</strong> You should now have a solid understanding of what Redux Toolkit and React-Redux are, how to write and organize Redux logic, Redux data flow and usage with React, and how to use APIs like <code>configureStore</code> and <code>createSlice</code>. You should also see how RTK Query can simplify the process of fetching and using cached data.</p>
<p>The <a href="./part-6-performance-normalization.md">“What’s Next?” section in Part 6</a> has links to additional resources for app ideas, tutorials, and documentation.</p>
<p>For more details on using RTK Query, see <a href="https://redux-toolkit.js.org/rtk-query/usage/queries">the RTK Query usage guide docs</a> and <a href="https://redux-toolkit.js.org/rtk-query/api/createApi">API reference</a>.</p>
<p>If you’re looking for help with Redux questions, come join <a href="https://www.reactiflux.com">the <code>#redux</code> channel in the Reactiflux server on Discord</a>.</p>
<p><strong>Thanks for reading through this tutorial, and we hope you enjoy building applications with Redux!</strong></p>
</body>
</html>
